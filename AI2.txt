Cranelift exnref Support – Current Understanding
================================================

High-Level Goal
- Bring Wasmer’s Cranelift backend (`lib/compiler-cranelift`) to parity with the LLVM backend for the WebAssembly exception-handling (exnref) proposal, so Wasmer can execute modules using structured exceptions without falling back to LLVM.
- Align Wasmer’s design with Wasmtime’s prior art: reuse Cranelift IR constructs (exception tables, try_call, etc.) but adapt them to Wasmer’s two-stage personality runtime (stage 1 inside libunwind, stage 2 inside `wasmer_eh_personality2` using vmctx for tag resolution).

Current Architecture & Key Concepts
- **Compiler pieces**: `translator/code_translator.rs` lowers Wasm operators to CLIF; `func_state.rs` tracks control-flow/handler state; `func_environ.rs` mediates runtime libcalls.
- **Runtime glue**: `lib/vm/src/libcalls/eh::*` implements two-stage personality, throw/rethrow, payload packing. VM builtins expose function pointers via `vmcontext`.
- **Exception semantics**: Wasm tags map to store-unique IDs at runtime; catch clauses can be tag-specific or catch-all. Catch blocks must receive payloads and optionally the raw `exnref` for `catch_ref`.
- **Cranelift features in use**:
  * `try_call`/`try_call_indirect` emit call sites with associated `ExceptionTableData`.
  * `BlockArg::TryCallRet` / `TryCallExn` pass values into continuation and catch blocks.
  * `FuncTranslationState::handlers` maintains the active handler stack for correct try-call wiring.
- **Wasmer-specific requirements**:
  * Stage 1 personality (libunwind hook) must be referenced so object files link correctly.
  * Stage 2 (`wasmer_eh_personality2`) must be callable from landing pads to translate store-level tag IDs back to module-local indexes and drive dispatch.
  * Emitted object metadata must describe exception handler ranges so the engine can register them at instantiation time.

Work Completed (recap)
- Type plumbing for `exnref` and block parameters.
- Translation state extended to mimic Wasmtime’s handler checkpoints.
- Environment trait gained exception-centric hooks (tag arity, throw, unbox, personality selector).
- Runtime calls for allocation/throw/rethrow wired through Cranelift environment.
- `TryTable` lowering now builds a single landing pad that invokes `wasmer_eh_personality2`, branches to catch blocks, and rethrows unmatched exceptions.
- Call translation (`call`, `call_indirect`, `throw`, `throw_ref`) uses try-call and handler lists.
- Control-frame teardown restores handler checkpoints even on unreachable paths.
- Added VM builtin slot for `wasmer_eh_personality2` so JIT code can grab stage-2 personality pointer.

Outstanding Technical Gaps
1. **Stage-1 personality relocation**  
   - Cranelift-produced object files must reference `wasmer_eh_personality` so the system unwinder recognizes Wasmer frames.  
   - Need to observe `result.buffer.call_sites()` / unwind info and append a `RelocationTarget::LibCall(LibCall::EHPersonality)` when exception tables are present (similar to LLVM backend).  
   - Ensure GOT or direct relocation matches existing runtime expectations on macOS/Linux.

2. **Exception table serialization for runtime**  
   - Currently Cranelift translation creates `ExceptionTableData`, but `lib/compiler-cranelift/src/compiler.rs` discards the information.  
   - Must mirror Wasmtime’s `clif_to_env_exception_tables`, using Wasmer’s equivalent builder (likely in `lib/compiler/src/...`) or introduce one if missing.  
   - Resulting custom section has to be attached to `CompiledFunction`/`Compilation` so engine can register catch handlers (see how LLVM backend populates exception metadata).

3. **Engine integration audit**  
   - Verify `Artifact::register_compiled_code` (engine inner) consumes the new exception metadata.  
   - Confirm compact-unwind / DWARF registration uses the stage-1 personality pointer captured above.  
   - Ensure VM offsets / builtin tables supply both personality stages in all paths (including serialization/deserialization of artifacts).

4. **Validation & coverage**  
   - Rerun `cargo nextest run … exception_handling` once the above pieces land.  
   - Add/enable additional regression tests if available (e.g., runtime integration tests, Wasix snapshots).  
   - Document remaining platform gaps (Windows still unsupported per `tests/ignores.txt`).

5. **Refinement / cleanup**  
   - Double-check block sealing and branching in landing pad logic against Cranelift invariants.  
   - Review interactions with GC/prototype features (ensure exception handling coexists with reference types, multi-value).  
   - Update AI.txt progress log after each milestone; summarize final implementation plan when suites pass.

Immediate Next Actions
1. Modify `lib/compiler-cranelift/src/compiler.rs` to:
   - Observe `result.buffer.call_sites()` and convert them into Wasmer’s exception table section format.  
   - When exception handlers exist, push a relocation entry referencing `LibCall::EHPersonality`.
2. Update artifact/custom-section plumbing (if required) so exception metadata survives into engine registration.
3. Re-run the exception-handling test suite and capture outcomes before tackling any residual failures.

Known Unknowns / Follow-up Questions
- Exact API in Wasmer core for supplying exception tables—need to locate or implement complement to Wasmtime’s `ExceptionTableBuilder`.
- Whether additional VM builtin slots are necessary for stage-1 personality or if relocation suffices.
- Impact on serialization/deserialization of compiled artifacts (ensure new metadata is preserved across cached artifacts).

Status Report – Cranelift EH Integration (current)
-------------------------------------------------
- Added the new `lib/compiler-cranelift/src/eh.rs` helper and hooked it into `compiler.rs`, so LSDA/tag custom sections are now generated from Cranelift call-site metadata, registered as custom sections, and referenced from `.eh_frame`.
- Updated `WriterRelocate` and related code to assign LSDA symbols without redundant casts and to push relocations for the stage-1 personality function; also prepared the CIE to carry LSDA addresses.
- Build is still failing on three fronts:
  * `eh.rs` imports the private `cranelift_codegen::machinst` module; need to switch to the public re-exports (`FinalizedMachCallSite`, `FinalizedMachExceptionHandler`, `ExceptionContextLoc`) and bring `EntityRef` into scope for `tag.index()`.
  * Using the private `gimli::write::constants` module; must import `gimli::constants::DW_EH_PE_absptr` (or use the top-level constants) when configuring the CIE.
  * Borrow checker conflict in `compile_module_internal`: we call `compiled_function_unwind_info(&context)` while still holding mutable borrows of `context` for code emission; need to restructure to drop the mutable borrow before the call (e.g., extract `result` first, then use the immutable reference).

Next Steps
----------
1. Fix the compilation errors above (adjust imports, switch to public gimli constants, and refactor the borrow pattern around `compiled_function_unwind_info`).
2. Re-run `cargo nextest … exception_handling` to verify the crate builds and capture any runtime/test failures.
3. Once the build succeeds, audit the engine registration path to ensure LSDA/tag sections and personality relocations propagate, then iterate on any remaining failures.

Status Update – EH tables now emitted, runtime failing
-----------------------------------------------------
- The Cranelift crate now compiles cleanly: `eh.rs` imports the public re-exports plus `EntityRef`, `compiler.rs` relies on `gimli::constants::DW_EH_PE_absptr`, and the LSDA extraction happens before invoking `compiled_function_unwind_info`, keeping the borrow checker happy.
- Added `WriterRelocate::write_eh_pointer` and force every FDE to carry an LSDA pointer (null for handler-free functions), so `.eh_frame` writes successfully with relocations targeting the new LSDA/tag custom sections.
- `cargo nextest … exception_handling` still fails on `easy_throw.wast` for the Cranelift backend, but the failure moved to runtime: multiple directives now trap with `RuntimeError: out of bounds memory access`, suggesting the LSDA data or landing pad dispatch is miswired rather than missing.

Immediate Focus
---------------
1. Dump or decode the generated LSDA for the failing function (e.g., via temporary logging) to verify the call-site ranges, action table chains, and tag table contents.
2. Instrument the stage-1 personality (`wasmer_eh_personality` / `find_eh_action`) to confirm the LSDA pointer resolves to valid data and that the action walker sees the expected tags instead of wandering off into host memory.
3. Once the root cause is clear, adjust the LSDA encoding or registration logic accordingly, then rerun the spec test before broadening coverage.

Latest Findings
---------------
- Added temporary debug instrumentation (`WASMER_DEBUG_EH=1`) to print per-function LSDA metadata. For `easy_throw.wast`, we now see one call site with a catch-all and another with a tagged handler; both emit 28-byte LSDAs with the expected landing-pad offsets (84→87 and 76→79) and, for the tagged case, a relocation into the tag section.
- Despite the tables looking sane, the spec tests still trap with `RuntimeError: out of bounds memory access`, and the stage-1/2 personality logging never fires—suggesting the trap occurs before libunwind even begins unwinding (likely inside the throw stub or landing pad itself).
- Next hypothesis: inspect the generated landing pad blocks (e.g., by disassembling the Cranelift output or adding further instrumentation) to confirm they load VMContext/exception payload correctly, and ensure the throw helpers aren’t scribbling invalid memory prior to unwinding.

New Debug Data
--------------
- Instrumented `throw`, the personalities, and the SystemV unwind registration path. `throw` resolves unique tags and the engine publishes `.eh_frame` sections whose relocated bytes point at `wasmer_eh_personality`, the function body, and the LSDA custom section (personality pointer shows up as a non-zero host address).
- Even with stage-1 logging forced on, no `[wasmer][eh] stage1 …` output appears; libunwind never calls our personality before the runtime aborts with the OOB trap. This suggests the unwinder isn’t recognizing the Wasm frames despite the registration.
- Next steps: double-check the Cranelift ISA flags to ensure unwind info emission is enabled, verify the emitted machine code actually contains landing pads, and inspect the runtime’s stage-2 plumbing (vmctx builtin slot, selector call) once stage-1 is confirmed reachable.

Latest Comparison & API Notes
-----------------------------
- Checked `lib/api` and the runtime harness: both Cranelift and LLVM flow through the same `EngineBuilder` path, and the WAST runner enables `features.exceptions(true)` for the exception suite. No missing API-side toggle differentiates Cranelift from LLVM here.
- Dumped the failing function’s CLIF and the emitted `.eh_frame`; they look structurally correct and register with the engine. Yet `uw::_Unwind_RaiseException` still returns `URC_END_OF_STACK` without invoking `wasmer_eh_personality`, meaning libunwind is ignoring the Wasm frame.
- Immediate focus: diff the Cranelift-generated FDE/CIE against LLVM’s output for the same module, and verify the recorded PC ranges and addresses. If they diverge or reference stub symbols instead of real function pointers, libunwind will skip the frame—explaining the missing personality call.
