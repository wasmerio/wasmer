// Rust test file autogenerated with cargo build (build/spectests.rs).
// Please do NOT modify it by hand, as it will be reset on next build.
// Test based on spectests/get_local.wast
#![allow(
    warnings,
    dead_code
)]
use std::{f32, f64};
use wabt::wat2wasm;

use wasmer_clif_backend::CraneliftCompiler;
use wasmer_runtime::types::Value;
use wasmer_runtime::{module::Module, Instance};

use crate::spectests::_common::{generate_imports, NaNCheck};

// Line 3
fn create_module_1() -> Instance {
    let module_str = "(module
      (type (;0;) (func (result i32)))
      (type (;1;) (func (result i64)))
      (type (;2;) (func (result f32)))
      (type (;3;) (func (result f64)))
      (type (;4;) (func (param i32) (result i32)))
      (type (;5;) (func (param i64) (result i64)))
      (type (;6;) (func (param f32) (result f32)))
      (type (;7;) (func (param f64) (result f64)))
      (type (;8;) (func (param i64 f32 f64 i32 i32)))
      (type (;9;) (func (param i64 f32 f64 i32 i32) (result f64)))
      (func (;0;) (type 0) (result i32)
        (local i32)
        get_local 0)
      (func (;1;) (type 1) (result i64)
        (local i64)
        get_local 0)
      (func (;2;) (type 2) (result f32)
        (local f32)
        get_local 0)
      (func (;3;) (type 3) (result f64)
        (local f64)
        get_local 0)
      (func (;4;) (type 4) (param i32) (result i32)
        get_local 0)
      (func (;5;) (type 5) (param i64) (result i64)
        get_local 0)
      (func (;6;) (type 6) (param f32) (result f32)
        get_local 0)
      (func (;7;) (type 7) (param f64) (result f64)
        get_local 0)
      (func (;8;) (type 8) (param i64 f32 f64 i32 i32)
        (local f32 i64 i64 f64)
        get_local 0
        i64.eqz
        drop
        get_local 1
        f32.neg
        drop
        get_local 2
        f64.neg
        drop
        get_local 3
        i32.eqz
        drop
        get_local 4
        i32.eqz
        drop
        get_local 5
        f32.neg
        drop
        get_local 6
        i64.eqz
        drop
        get_local 7
        i64.eqz
        drop
        get_local 8
        f64.neg
        drop)
      (func (;9;) (type 9) (param i64 f32 f64 i32 i32) (result f64)
        (local f32 i64 i64 f64)
        f32.const 0x1.6p+2 (;=5.5;)
        set_local 5
        i64.const 6
        set_local 6
        f64.const 0x1p+3 (;=8;)
        set_local 8
        get_local 0
        f64.convert_u/i64
        get_local 1
        f64.promote/f32
        get_local 2
        get_local 3
        f64.convert_u/i32
        get_local 4
        f64.convert_s/i32
        get_local 5
        f64.promote/f32
        get_local 6
        f64.convert_u/i64
        get_local 7
        f64.convert_u/i64
        get_local 8
        f64.add
        f64.add
        f64.add
        f64.add
        f64.add
        f64.add
        f64.add
        f64.add)
      (export \"type-local-i32\" (func 0))
      (export \"type-local-i64\" (func 1))
      (export \"type-local-f32\" (func 2))
      (export \"type-local-f64\" (func 3))
      (export \"type-param-i32\" (func 4))
      (export \"type-param-i64\" (func 5))
      (export \"type-param-f32\" (func 6))
      (export \"type-param-f64\" (func 7))
      (export \"type-mixed\" (func 8))
      (export \"read\" (func 9)))
    ";
    let wasm_binary = wat2wasm(module_str.as_bytes()).expect("WAST not valid or malformed");
    let module = wasmer_runtime::compile(&wasm_binary[..], &CraneliftCompiler::new())
        .expect("WASM can't be compiled");
    module
        .instantiate(generate_imports())
        .expect("WASM can't be instantiated")
}

fn start_module_1(instance: &mut Instance) {
    // TODO Review is explicit start needed? Start now called in runtime::Instance::new()
    //instance.start();
}

// Line 64
fn c1_l64_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c1_l64_action_invoke");
    let result = instance.call("type-local-i32", &[]);
    assert_eq!(result, Ok(Some(Value::I32(0 as i32))));
    result.map(|_| ())
}

// Line 65
fn c2_l65_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c2_l65_action_invoke");
    let result = instance.call("type-local-i64", &[]);
    assert_eq!(result, Ok(Some(Value::I64(0 as i64))));
    result.map(|_| ())
}

// Line 66
fn c3_l66_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c3_l66_action_invoke");
    let result = instance.call("type-local-f32", &[]);
    assert_eq!(result, Ok(Some(Value::F32((0.0f32)))));
    result.map(|_| ())
}

// Line 67
fn c4_l67_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c4_l67_action_invoke");
    let result = instance.call("type-local-f64", &[]);
    assert_eq!(result, Ok(Some(Value::F64((0.0f64)))));
    result.map(|_| ())
}

// Line 69
fn c5_l69_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c5_l69_action_invoke");
    let result = instance.call("type-param-i32", &[Value::I32(2 as i32)]);
    assert_eq!(result, Ok(Some(Value::I32(2 as i32))));
    result.map(|_| ())
}

// Line 70
fn c6_l70_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c6_l70_action_invoke");
    let result = instance.call("type-param-i64", &[Value::I64(3 as i64)]);
    assert_eq!(result, Ok(Some(Value::I64(3 as i64))));
    result.map(|_| ())
}

// Line 71
fn c7_l71_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c7_l71_action_invoke");
    let result = instance.call("type-param-f32", &[Value::F32((4.4f32))]);
    assert_eq!(result, Ok(Some(Value::F32((4.4f32)))));
    result.map(|_| ())
}

// Line 72
fn c8_l72_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c8_l72_action_invoke");
    let result = instance.call("type-param-f64", &[Value::F64((5.5f64))]);
    assert_eq!(result, Ok(Some(Value::F64((5.5f64)))));
    result.map(|_| ())
}

// Line 75
fn c9_l75_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c9_l75_action_invoke");
    let result = instance.call(
        "type-mixed",
        &[
            Value::I64(1 as i64),
            Value::F32((2.2f32)),
            Value::F64((3.3f64)),
            Value::I32(4 as i32),
            Value::I32(5 as i32),
        ],
    );
    assert_eq!(result, Ok(None));
    result.map(|_| ())
}

// Line 81
fn c10_l81_action_invoke(instance: &mut Instance) -> Result<(), String> {
    println!("Executing function {}", "c10_l81_action_invoke");
    let result = instance.call(
        "read",
        &[
            Value::I64(1 as i64),
            Value::F32((2.0f32)),
            Value::F64((3.3f64)),
            Value::I32(4 as i32),
            Value::I32(5 as i32),
        ],
    );
    assert_eq!(result, Ok(Some(Value::F64((34.8f64)))));
    result.map(|_| ())
}

// Line 91
#[test]
fn c11_l91_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 126, 3, 2, 1, 0, 10, 8, 1, 6, 1, 1, 127,
        32, 0, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 95
#[test]
fn c12_l95_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 1, 1, 125, 32, 0,
        69, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 99
#[test]
fn c13_l99_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 11, 1, 9, 2, 1, 124, 1,
        126, 32, 1, 154, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 107
#[test]
fn c14_l107_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 126, 3, 2, 1, 0, 10, 6, 1, 4, 0, 32,
        0, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 111
#[test]
fn c15_l111_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 1, 125, 0, 3, 2, 1, 0, 10, 7, 1, 5, 0, 32, 0, 69,
        11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 115
#[test]
fn c16_l115_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 2, 124, 126, 0, 3, 2, 1, 0, 10, 7, 1, 5, 0, 32,
        1, 154, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 123
#[test]
fn c17_l123_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 10, 1, 8, 2, 1, 127, 1,
        126, 32, 3, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 127
#[test]
fn c18_l127_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 13, 1, 11, 2, 1, 127, 1,
        126, 32, 247, 164, 234, 6, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 132
#[test]
fn c19_l132_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 2, 127, 126, 0, 3, 2, 1, 0, 10, 6, 1, 4, 0, 32,
        2, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 136
#[test]
fn c20_l136_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 14, 1, 12, 2, 1, 127, 1,
        126, 32, 247, 242, 206, 212, 2, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 141
#[test]
fn c21_l141_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 1, 127, 0, 3, 2, 1, 0, 10, 10, 1, 8, 2, 1, 127,
        1, 126, 32, 3, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

// Line 145
#[test]
fn c22_l145_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 1, 126, 0, 3, 2, 1, 0, 10, 13, 1, 11, 2, 1, 127,
        1, 126, 32, 247, 168, 153, 102, 11,
    ];
    let module = wasmer_runtime::compile(&wasm_binary, &CraneliftCompiler::new());
    assert!(module.is_err(), "WASM should not compile as is invalid");
}

#[test]
fn test_module_1() {
    let mut instance = create_module_1();
    // We group the calls together
    start_module_1(&mut instance);
    c1_l64_action_invoke(&mut instance);
    c2_l65_action_invoke(&mut instance);
    c3_l66_action_invoke(&mut instance);
    c4_l67_action_invoke(&mut instance);
    c5_l69_action_invoke(&mut instance);
    c6_l70_action_invoke(&mut instance);
    c7_l71_action_invoke(&mut instance);
    c8_l72_action_invoke(&mut instance);
    c9_l75_action_invoke(&mut instance);
    c10_l81_action_invoke(&mut instance);
}
