"""
Directs the executor to include this field or fragment only when the user is not logged in.
"""
directive @includeIfLoggedIn on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
Directs the executor to skip this field or fragment when the user is not logged in.
"""
directive @skipIfLoggedIn on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

interface Node {
  """The ID of the object"""
  id: ID!
}

type PublicKey implements Node {
  """The ID of the object"""
  id: ID!
  owner: User!
  keyId: String!
  key: String!
  revokedAt: DateTime
  uploadedAt: DateTime!
  verifyingSignature: Signature
  revoked: Boolean!
}

type User implements Node & PackageOwner & Owner {
  firstName: String!
  lastName: String!
  email: String!
  dateJoined: DateTime!

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  isEmailValidated: Boolean!
  bio: String
  location: String
  websiteUrl: String

  """The ID of the object"""
  id: ID!
  globalName: String!
  globalId: ID!
  avatar(size: Int = 80): String!
  isViewer: Boolean!
  hasUsablePassword: Boolean
  fullName: String!
  githubUrl: String
  twitterUrl: String
  companyRole: String
  companyDescription: String
  publicActivity(offset: Int, before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  billing: Billing
  waitlist(name: String!): WaitlistMember
  namespaces(role: GrapheneRole, offset: Int, before: String, after: String, first: Int, last: Int): NamespaceConnection!
  packages(collaborating: Boolean = false, offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  apps(collaborating: Boolean = false, sortBy: DeployAppsSortBy, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
  domains(offset: Int, before: String, after: String, first: Int, last: Int): DNSDomainConnection!
  isStaff: Boolean
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  packageTransfersIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageTransferRequestConnection!
  packageInvitesIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorInviteConnection!
  namespaceInvitesIncoming(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  apiTokens(before: String, after: String, first: Int, last: Int): APITokenConnection!
  notifications(before: String, after: String, first: Int, last: Int): UserNotificationConnection!
  dashboardActivity(offset: Int, before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  loginMethods: [LoginMethod!]!
  githubUser: SocialAuth
  githubScopes: [String]!
}

"""Setup for backwards compatibility with existing frontends."""
interface PackageOwner {
  globalName: String!
  globalId: ID!
}

"""An owner of a package."""
interface Owner {
  globalName: String!
  globalId: ID!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

type ActivityEventConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ActivityEventEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `ActivityEvent` and its cursor."""
type ActivityEventEdge {
  """The item at the end of the edge"""
  node: ActivityEvent

  """A cursor for use in pagination"""
  cursor: String!
}

type ActivityEvent implements Node {
  """The ID of the object"""
  id: ID!
  body: EventBody!
  actorIcon: String!
  createdAt: DateTime!
}

type EventBody {
  text: String!
  ranges: [NodeBodyRange!]!
}

type NodeBodyRange {
  entity: Node!
  offset: Int!
  length: Int!
}

type WaitlistMember implements Node {
  waitlist: Waitlist!
  joinedAt: DateTime!
  approvedAt: DateTime

  """The ID of the object"""
  id: ID!
  member: Owner!
  approved: Boolean!
}

type Waitlist implements Node {
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type NamespaceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Namespace` and its cursor."""
type NamespaceEdge {
  """The item at the end of the edge"""
  node: Namespace

  """A cursor for use in pagination"""
  cursor: String!
}

type Namespace implements Node & PackageOwner & Owner {
  """The ID of the object"""
  id: ID!
  name: String!
  displayName: String
  description: String!
  avatar: String!
  avatarUpdatedAt: DateTime
  twitterHandle: String
  githubHandle: String
  websiteUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
  maintainerInvites(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserConnection!
  globalName: String!
  globalId: ID!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  apps(sortBy: DeployAppsSortBy, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  collaborators(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorConnection!
  publicActivity(before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  pendingInvites(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  viewerHasRole(role: GrapheneRole!): Boolean!
  viewerAsCollaborator(role: GrapheneRole): NamespaceCollaborator

  """Whether the current user is invited to the namespace"""
  viewerIsInvited: Boolean!

  """The invitation for the current user to the namespace"""
  viewerInvitation: NamespaceCollaboratorInvite
  packageTransfersIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageTransferRequestConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
  domains(offset: Int, before: String, after: String, first: Int, last: Int): DNSDomainConnection!
}

type NamespaceCollaboratorInviteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceCollaboratorInviteEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
A Relay edge containing a `NamespaceCollaboratorInvite` and its cursor.
"""
type NamespaceCollaboratorInviteEdge {
  """The item at the end of the edge"""
  node: NamespaceCollaboratorInvite

  """A cursor for use in pagination"""
  cursor: String!
}

type NamespaceCollaboratorInvite implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  user: User
  inviteEmail: String
  namespace: Namespace!
  role: RegistryNamespaceMaintainerInviteRoleChoices!
  accepted: NamespaceCollaborator
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
}

enum RegistryNamespaceMaintainerInviteRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type NamespaceCollaborator implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  role: RegistryNamespaceMaintainerRoleChoices!
  namespace: Namespace!
  createdAt: DateTime!
  updatedAt: DateTime!
  invite: NamespaceCollaboratorInvite
}

enum RegistryNamespaceMaintainerRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type UserConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `User` and its cursor."""
type UserEdge {
  """The item at the end of the edge"""
  node: User

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Package` and its cursor."""
type PackageEdge {
  """The item at the end of the edge"""
  node: Package

  """A cursor for use in pagination"""
  cursor: String!
}

type Package implements Likeable & Node & PackageOwner {
  """The ID of the object"""
  id: ID!
  name: String!
  private: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  maintainers: [User]! @deprecated(reason: "Please use collaborators instead")
  curated: Boolean!
  ownerObjectId: Int!
  lastVersion: PackageVersion

  """The app icon. It should be formatted in the same way as Apple icons"""
  icon: String!
  totalDownloads: Int!
  iconUpdatedAt: DateTime
  watchersCount: Int!
  webcs(offset: Int, before: String, after: String, first: Int, last: Int): WebcImageConnection!

  """List of app templates for this package"""
  appTemplates(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection!
  packagewebcSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageWebcConnection!
  versions: [PackageVersion]!
  collectionSet: [Collection!]!
  categories(offset: Int, before: String, after: String, first: Int, last: Int): CategoryConnection!
  keywords(offset: Int, before: String, after: String, first: Int, last: Int): PackageKeywordConnection!
  likersCount: Int!
  viewerHasLiked: Boolean!
  globalName: String!
  globalId: ID!
  alias: String
  namespace: String!
  displayName: String!

  """The name of the package without the owner"""
  packageName: String!

  """The app icon. It should be formatted in the same way as Apple icons"""
  appIcon: String! @deprecated(reason: "Please use icon instead")

  """The total number of downloads of the package"""
  downloadsCount: Int

  """The public keys for all the published versions"""
  publicKeys: [PublicKey!]!
  collaborators(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorConnection!
  pendingInvites(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorInviteConnection!
  viewerHasRole(role: GrapheneRole!): Boolean!
  viewerAsCollaborator(role: GrapheneRole): PackageCollaborator
  owner: PackageOwner!
  isTransferring: Boolean!
  activeTransferRequest: PackageTransferRequest
  isArchived: Boolean!
  viewerIsWatching: Boolean!
  showDeployButton: Boolean!
  similarPackageVersions(before: String, after: String, first: Int, last: Int): PackageSearchConnection!

  """Whether the current user is invited to the package"""
  viewerIsInvited: Boolean!

  """The invitation for the current user to the package"""
  viewerInvitation: PackageCollaboratorInvite
}

interface Likeable {
  id: ID!
  likersCount: Int!
  viewerHasLiked: Boolean!
}

type PackageVersion implements Node & PackageReleaseInterface & PackageInstance {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  package: Package!
  webc: WebcImage
  webcV3: WebcImage

  """List of direct dependencies of this package version"""
  dependencies(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  publishedBy: User!
  tag: String!
  clientName: String
  webcGenerationErrors: String
  version: String!
  description: String!
  manifest: String!
  license: String
  licenseFile: String
  readme: String
  witMd: String
  repository: String
  homepage: String
  staticObjectsCompiled: Boolean!
  nativeExecutablesCompiled: Boolean!
  signature: Signature
  isArchived: Boolean!
  file: String!

  """"""
  fileSize: BigInt!
  totalDownloads: Int!
  bindingsState: RegistryPackageVersionBindingsStateChoices!
  nativeExecutablesState: RegistryPackageVersionNativeExecutablesStateChoices!
  deployappversionSet(offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  lastversionPackage(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  commands: [Command!]!
  nativeexecutableSet(offset: Int, before: String, after: String, first: Int, last: Int): NativeExecutableConnection!
  bindingsgeneratorSet(offset: Int, before: String, after: String, first: Int, last: Int): BindingsGeneratorConnection!
  javascriptlanguagebindingSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionNPMBindingConnection!
  pythonlanguagebindingSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionPythonBindingConnection!
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  piritaFile: String @deprecated(reason: "Please use distribution.piritaDownloadUrl instead.")
  piritaFileSize: Int @deprecated(reason: "Please use distribution.piritaSize instead.")
  pirita256hash: String @deprecated(reason: "Please use distribution.piritaSha256Hash instead.")
  distribution(version: WebcVersion): PackageDistribution!
  filesystem: [PackageVersionFilesystem]!
  isLastVersion: Boolean!
  witFile: String
  isSigned: Boolean!
  moduleInterfaces: [InterfaceVersion!]!
  modules: [PackageVersionModule!]!
  getPiritaContents(volume: String! = "atom", base: String! = ""): [PiritaFilesystemItem!]!
  getWebcContents(volume: String! = "atom", base: String! = "/"): [WEBCFilesystemItem!]!
  nativeExecutables(triple: String, wasmerCompilerVersion: String): [NativeExecutable]
  bindings: [PackageVersionLanguageBinding]!
  npmBindings: PackageVersionNPMBinding
  pythonBindings: PackageVersionPythonBinding
  bindingsSet(before: String, after: String, first: Int, last: Int): PackageVersionBindingConnection
  hasBindings: Boolean!
  hasCommands: Boolean!
  showDeployButton: Boolean!
  isCorrupt: Boolean!
}

interface PackageReleaseInterface {
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  isArchived: Boolean!
  clientName: String
  publishedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  package: Package!
  webc: WebcImage
  webcV3: WebcImage
  tag: String!
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type WebcImage implements Node {
  """The ID of the object"""
  id: ID!
  version: RegistryWebcImageVersionChoices!

  """"""
  fileSize: BigInt!
  manifest: JSONString!
  volumes: JSONString!
  offsets: JSONString!
  webcSha256: String!
  targzSha256: String
  createdAt: DateTime!
  updatedAt: DateTime!
  webcUrl: String!
}

enum RegistryWebcImageVersionChoices {
  """v2"""
  V2

  """v3"""
  V3
}

"""
The `BigInt` scalar type represents non-fractional whole numeric values.
`BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
compatible type.
"""
scalar BigInt

type PackageVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersion` and its cursor."""
type PackageVersionEdge {
  """The item at the end of the edge"""
  node: PackageVersion

  """A cursor for use in pagination"""
  cursor: String!
}

enum RegistryPackageVersionBindingsStateChoices {
  """Bindings are not detected"""
  NOT_PRESENT

  """Bindings are being built"""
  GENERATING

  """Bindings generation has failed"""
  ERROR

  """Bindings are built and present"""
  GENERATED_AND_PRESENT
}

enum RegistryPackageVersionNativeExecutablesStateChoices {
  """Native Executables are not detected"""
  NOT_PRESENT

  """Native Executables are being built"""
  GENERATING

  """Native Executables generation has failed"""
  ERROR

  """Native Executables are built and present"""
  GENERATED_AND_PRESENT
}

type DeployAppVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeployAppVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DeployAppVersion` and its cursor."""
type DeployAppVersionEdge {
  """The item at the end of the edge"""
  node: DeployAppVersion

  """A cursor for use in pagination"""
  cursor: String!
}

type DeployAppVersion implements Node {
  """The ID of the object"""
  id: ID!
  app: DeployApp!
  yamlConfig: String!
  userYamlConfig: String!
  clientName: String!
  signature: String
  description: String
  publishedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  configWebc: String @deprecated(reason: "webc support has been deprecated for apps")
  config: String! @deprecated(reason: "Please use jsonConfig instead")
  jsonConfig: String!
  url: String!
  permalink: String!
  urls: [String]!
  version: String!
  isActive: Boolean!
  manifest: String!
  logs(
    """
    Get logs starting from this timestamp. Takes EPOCH timestamp in seconds.
    """
    startingFrom: Float

    """Get logs starting from this timestamp. Takes ISO timestamp."""
    startingFromISO: DateTime

    """Fetch logs until this timestamp. Takes EPOCH timestamp in seconds."""
    until: Float

    """List of streams to fetch logs from. e.g. stdout, stderr."""
    streams: [LogStream]

    """List of instance ids to fetch logs from."""
    instanceIds: [String]
    before: String
    after: String
    first: Int
    last: Int
  ): LogConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
  sourcePackageVersion: PackageVersion!
  aggregateMetrics: AggregateMetrics!
  volumes: [AppVersionVolume]
  favicon: URL
  screenshot: URL
}

type DeployApp implements Node & Owner {
  """The ID of the object"""
  id: ID!
  createdBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  activeVersion: DeployAppVersion!
  globalName: String!
  globalId: ID!
  url: String!
  adminUrl: String!
  permalink: String!
  urls: [String]!
  description: String
  name: String!
  owner: Owner!
  versions(sortBy: DeployAppVersionsSortBy, createdAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  aggregateMetrics: AggregateMetrics!
  aliases(offset: Int, before: String, after: String, first: Int, last: Int): AppAliasConnection!
  usageMetrics(forRange: MetricRange!, variant: MetricType!): [UsageMetric]!
  deleted: Boolean!
  favicon: URL
  screenshot: URL
}

enum DeployAppVersionsSortBy {
  NEWEST
  OLDEST
}

type AggregateMetrics {
  cpuTime: String!
  memoryTime: String!
  ingress: String!
  egress: String!
  noRequests: String!
  noFailedRequests: String!
  monthlyCost: String!
}

type AppAliasConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppAliasEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppAlias` and its cursor."""
type AppAliasEdge {
  """The item at the end of the edge"""
  node: AppAlias

  """A cursor for use in pagination"""
  cursor: String!
}

type AppAlias implements Node {
  name: String!
  app: DeployApp!
  isDefault: Boolean!
  hostname: String!
  text: String!
  kind: DeployAppAliasKindChoices!

  """The ID of the object"""
  id: ID!
  url: String!
}

enum DeployAppAliasKindChoices {
  """Deployment"""
  DEPLOYMENT

  """Domain"""
  DOMAIN
}

type UsageMetric {
  variant: MetricType!
  value: Float!
  unit: MetricUnit!
  timestamp: DateTime!
}

enum MetricType {
  cpu_time
  memory_time
  network_egress
  network_ingress
  no_of_requests
  no_of_failed_requests
  cost
}

"""Units for metrics"""
enum MetricUnit {
  """represents the unit of "seconds"."""
  SEC

  """represents the unit of "milliseconds"."""
  MS

  """represents the unit of "kilobytes"."""
  KB

  """represents the unit of "kilobytes per second"."""
  KBS

  """represents the unit of "number of requests"."""
  NO_REQUESTS

  """represents the unit of "cost" in USD."""
  DOLLARS
}

enum MetricRange {
  LAST_24_HOURS
  LAST_30_DAYS
  LAST_1_HOUR
}

"""
The `URL` scalar type represents a URL as text, represented as UTF-8
character sequences.
"""
scalar URL

type LogConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LogEdge]!
}

"""A Relay edge containing a `Log` and its cursor."""
type LogEdge {
  """The item at the end of the edge"""
  node: Log

  """A cursor for use in pagination"""
  cursor: String!
}

enum LogStream {
  STDOUT
  STDERR
  RUNTIME
}

type AppVersionVolume {
  name: String!
  mountPaths: [AppVersionVolumeMountPath]!
  size: Int
  usedSize: Int
}

type AppVersionVolumeMountPath {
  path: String!
  subpath: String!
}

type Command {
  command: String!
  packageVersion: PackageVersion!
  module: PackageVersionModule!
}

type PackageVersionModule {
  name: String!
  source: String!
  abi: String
  publicUrl: String!
  atom: PiritaFilesystemFile!
  rangeHeader: String!
}

type PiritaFilesystemFile {
  name(display: PiritaFilesystemNameDisplay): String!
  size: Int!
  offset: Int!
}

enum PiritaFilesystemNameDisplay {
  RELATIVE
  ABSOLUTE
}

type NativeExecutableConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NativeExecutableEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `NativeExecutable` and its cursor."""
type NativeExecutableEdge {
  """The item at the end of the edge"""
  node: NativeExecutable

  """A cursor for use in pagination"""
  cursor: String!
}

type NativeExecutable implements Node {
  """The ID of the object"""
  id: ID!
  module: String! @deprecated(reason: "Use filename instead")
  filename: String!
  filesize: Int!
  targetTriple: String!
  downloadUrl: String!
}

type BindingsGeneratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BindingsGeneratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `BindingsGenerator` and its cursor."""
type BindingsGeneratorEdge {
  """The item at the end of the edge"""
  node: BindingsGenerator

  """A cursor for use in pagination"""
  cursor: String!
}

type BindingsGenerator implements Node {
  """The ID of the object"""
  id: ID!
  packageVersion: PackageVersion!
  active: Boolean!
  commandName: String!
  registryJavascriptlanguagebindings(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionNPMBindingConnection!
  registryPythonlanguagebindings(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionPythonBindingConnection!
}

type PackageVersionNPMBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionNPMBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersionNPMBinding` and its cursor."""
type PackageVersionNPMBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionNPMBinding

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageVersionNPMBinding implements PackageVersionLanguageBinding & Node {
  """The ID of the object"""
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  npmDefaultInstallPackageName(url: String): String! @deprecated(reason: "Please use packageName instead")
}

interface PackageVersionLanguageBinding {
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
}

enum ProgrammingLanguage {
  PYTHON
  JAVASCRIPT
}

type PackageVersionPythonBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionPythonBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
A Relay edge containing a `PackageVersionPythonBinding` and its cursor.
"""
type PackageVersionPythonBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionPythonBinding

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageVersionPythonBinding implements PackageVersionLanguageBinding & Node {
  """The ID of the object"""
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  pythonDefaultInstallPackageName(url: String): String!
}

type PackageDistribution {
  """
  Download URL of the tar.gz file.
  If the package was published with webc only,this will contain download URL for webc file instead.
  """
  downloadUrl: String!
  expiresInSeconds: Int
  size: Int
  piritaDownloadUrl: String
  piritaExpiresInSeconds: Int
  piritaSize: Int
  piritaSha256Hash: String
  webcDownloadUrl: String
  webcExpiresInSeconds: Int
  webcSize: Int
  webcSha256Hash: String
  webcVersion: WebcVersion
}

enum WebcVersion {
  V2
  V3
}

type PackageVersionFilesystem {
  wasm: String!
  host: String!
}

type InterfaceVersion implements Node {
  """The ID of the object"""
  id: ID!
  interface: Interface!
  version: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  publishedBy: User!
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
}

type Interface implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  displayName: String!
  description: String!
  homepage: String
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
  versions(offset: Int, before: String, after: String, first: Int, last: Int): InterfaceVersionConnection!
  lastVersion: InterfaceVersion
}

type InterfaceVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [InterfaceVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `InterfaceVersion` and its cursor."""
type InterfaceVersionEdge {
  """The item at the end of the edge"""
  node: InterfaceVersion

  """A cursor for use in pagination"""
  cursor: String!
}

union PiritaFilesystemItem = PiritaFilesystemFile | PiritaFilesystemDir

type PiritaFilesystemDir {
  name(display: PiritaFilesystemNameDisplay): String!
}

type WEBCFilesystemItem {
  name: String!
  checksum: String!
  size: Int!
  offset: Int!
}

type PackageVersionBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersionBinding` and its cursor."""
type PackageVersionBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionBinding

  """A cursor for use in pagination"""
  cursor: String!
}

union PackageVersionBinding = PackageVersionNPMBinding | PackageVersionPythonBinding

type WebcImageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WebcImageEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `WebcImage` and its cursor."""
type WebcImageEdge {
  """The item at the end of the edge"""
  node: WebcImage

  """A cursor for use in pagination"""
  cursor: String!
}

type AppTemplateConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppTemplateEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppTemplate` and its cursor."""
type AppTemplateEdge {
  """The item at the end of the edge"""
  node: AppTemplate

  """A cursor for use in pagination"""
  cursor: String!
}

type AppTemplate implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
  description: String!
  demoUrl: String!
  repoUrl: String!
  category: AppTemplateCategory!
  isPublic: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  readme: String!
  useCases: JSONString!
  framework: String!
  language: String!
  repoLicense: String!
  usingPackage: Package
  defaultImage: String
}

type AppTemplateCategory implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  appTemplates(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection!
}

type PackageWebcConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageWebcEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageWebc` and its cursor."""
type PackageWebcEdge {
  """The item at the end of the edge"""
  node: PackageWebc

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageWebc implements Node & PackageReleaseInterface & PackageInstance {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  package: Package!
  webc: WebcImage
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  isArchived: Boolean!
  clientName: String
  publishedBy: User!
  webcV3: WebcImage
  tag: String!
  webcUrl: String!
}

type Collection {
  slug: String!
  displayName: String!
  description: String!
  createdAt: DateTime!
  banner: String!
  packages(before: String, after: String, first: Int, last: Int): PackageConnection!
}

type CategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CategoryEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Category` and its cursor."""
type CategoryEdge {
  """The item at the end of the edge"""
  node: Category

  """A cursor for use in pagination"""
  cursor: String!
}

type Category implements Node {
  """The ID of the object"""
  id: ID!

  """A category is a label that can be attached to a package."""
  name: String!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection
}

type PackageKeywordConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageKeywordEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageKeyword` and its cursor."""
type PackageKeywordEdge {
  """The item at the end of the edge"""
  node: PackageKeyword

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageKeyword implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
}

type PackageCollaboratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageCollaboratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageCollaborator` and its cursor."""
type PackageCollaboratorEdge {
  """The item at the end of the edge"""
  node: PackageCollaborator

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageCollaborator implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  role: RegistryPackageMaintainerRoleChoices!
  package: Package!
  createdAt: DateTime!
  updatedAt: DateTime!
  invite: PackageCollaboratorInvite
}

enum RegistryPackageMaintainerRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type PackageCollaboratorInvite implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  user: User
  inviteEmail: String
  package: Package!
  role: RegistryPackageMaintainerInviteRoleChoices!
  accepted: PackageCollaborator
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
}

enum RegistryPackageMaintainerInviteRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type PackageCollaboratorInviteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageCollaboratorInviteEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageCollaboratorInvite` and its cursor."""
type PackageCollaboratorInviteEdge {
  """The item at the end of the edge"""
  node: PackageCollaboratorInvite

  """A cursor for use in pagination"""
  cursor: String!
}

enum GrapheneRole {
  OWNER
  ADMIN
  EDITOR
  VIEWER
}

type PackageTransferRequest implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  previousOwnerObjectId: Int!
  newOwnerObjectId: Int!
  package: Package!
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
  previousOwner: PackageOwner!
  newOwner: PackageOwner!
}

type PackageSearchConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageSearchEdge]!
  totalCount: Int
}

"""A Relay edge containing a `PackageSearch` and its cursor."""
type PackageSearchEdge {
  """The item at the end of the edge"""
  node: PackageVersion

  """A cursor for use in pagination"""
  cursor: String!
}

type DeployAppConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeployAppEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DeployApp` and its cursor."""
type DeployAppEdge {
  """The item at the end of the edge"""
  node: DeployApp

  """A cursor for use in pagination"""
  cursor: String!
}

enum DeployAppsSortBy {
  NEWEST
  OLDEST
  MOST_ACTIVE
}

type NamespaceCollaboratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceCollaboratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `NamespaceCollaborator` and its cursor."""
type NamespaceCollaboratorEdge {
  """The item at the end of the edge"""
  node: NamespaceCollaborator

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageTransferRequestConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageTransferRequestEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageTransferRequest` and its cursor."""
type PackageTransferRequestEdge {
  """The item at the end of the edge"""
  node: PackageTransferRequest

  """A cursor for use in pagination"""
  cursor: String!
}

type DNSDomainConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DNSDomainEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DNSDomain` and its cursor."""
type DNSDomainEdge {
  """The item at the end of the edge"""
  node: DNSDomain

  """A cursor for use in pagination"""
  cursor: String!
}

type DNSDomain implements Node {
  name: String!

  """This zone will be accessible at /dns/{slug}/."""
  slug: String!
  zoneFile: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """The ID of the object"""
  id: ID!
  records: [DNSRecord]
  owner: Owner!
}

union DNSRecord = ARecord | AAAARecord | CNAMERecord | TXTRecord | MXRecord | NSRecord | CAARecord | DNAMERecord | PTRRecord | SOARecord | SRVRecord | SSHFPRecord

type ARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  address: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

interface DNSRecordInterface {
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
}

type AAAARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  address: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type CNAMERecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """This domain name will alias to this canonical name."""
  cName: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type TXTRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  data: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type MXRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  preference: Int!
  exchange: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type NSRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  nsdname: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type CAARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  flags: Int!
  tag: DnsmanagerCertificationAuthorityAuthorizationRecordTagChoices!
  value: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

enum DnsmanagerCertificationAuthorityAuthorizationRecordTagChoices {
  """issue"""
  ISSUE

  """issue wildcard"""
  ISSUEWILD

  """Incident object description exchange format"""
  IODEF
}

type DNAMERecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """
  This domain name will alias to the entire subtree of that delegation domain.
  """
  dName: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type PTRRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  ptrdname: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type SOARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """Primary master name server for this zone."""
  mname: String!

  """Email address of the administrator responsible for this zone."""
  rname: String!

  """
  A slave name server will initiate a zone transfer if this serial is incremented.
  """
  serial: BigInt!

  """
  Number of seconds after which secondary name servers should query the master to detect zone changes.
  """
  refresh: BigInt!

  """
  Number of seconds after which secondary name servers should retry to request the serial number from the master if the master does not respond.
  """
  retry: BigInt!

  """
  Number of seconds after which secondary name servers should stop answering request for this zone if the master does not respond.
  """
  expire: BigInt!

  """Time to live for purposes of negative caching."""
  minimum: BigInt!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type SRVRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """The symbolic name of the desired service."""
  service: String!

  """
  The transport protocol of the desired service, usually either TCP or UDP.
  """
  protocol: String!

  """The priority of the target host, lower value means more preferred."""
  priority: Int!

  """
  A relative weight for records with the same priority, higher value means higher chance of getting picked.
  """
  weight: Int!
  port: Int!

  """
  The canonical hostname of the machine providing the service, ending in a dot.
  """
  target: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type SSHFPRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  algorithm: DnsmanagerSshFingerprintRecordAlgorithmChoices!
  type: DnsmanagerSshFingerprintRecordTypeChoices!
  fingerprint: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

enum DnsmanagerSshFingerprintRecordAlgorithmChoices {
  """RSA"""
  A_1

  """DSA"""
  A_2

  """ECDSA"""
  A_3

  """Ed25519"""
  A_4
}

enum DnsmanagerSshFingerprintRecordTypeChoices {
  """SHA-1"""
  A_1

  """SHA-256"""
  A_2
}

type APITokenConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [APITokenEdge]!
}

"""A Relay edge containing a `APIToken` and its cursor."""
type APITokenEdge {
  """The item at the end of the edge"""
  node: APIToken

  """A cursor for use in pagination"""
  cursor: String!
}

type APIToken {
  id: ID!
  user: User!
  identifier: String
  createdAt: DateTime!
  revokedAt: DateTime
  lastUsedAt: DateTime
  nonceSet(offset: Int, before: String, after: String, first: Int, last: Int): NonceConnection!
}

type NonceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NonceEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Nonce` and its cursor."""
type NonceEdge {
  """The item at the end of the edge"""
  node: Nonce

  """A cursor for use in pagination"""
  cursor: String!
}

type Nonce implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  callbackUrl: String!
  createdAt: DateTime!
  isValidated: Boolean!
  secret: String!
  token: String!
  expired: Boolean!
  authUrl: String!
}

type UserNotificationConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserNotificationEdge]!
  hasPendingNotifications: Boolean!
  pendingNotificationsCount: Int!
}

"""A Relay edge containing a `UserNotification` and its cursor."""
type UserNotificationEdge {
  """The item at the end of the edge"""
  node: UserNotification

  """A cursor for use in pagination"""
  cursor: String!
}

type UserNotification implements Node {
  """The ID of the object"""
  id: ID!
  icon: String
  body: EventBody!
  seenState: UserNotificationSeenState!
  kind: UserNotificationKind
  createdAt: DateTime!
}

enum UserNotificationSeenState {
  UNSEEN
  SEEN
  SEEN_AND_READ
}

union UserNotificationKind = UserNotificationKindPublishedPackageVersion | UserNotificationKindIncomingPackageTransfer | UserNotificationKindIncomingPackageInvite | UserNotificationKindIncomingNamespaceInvite | UserNotificationKindValidateEmail

type UserNotificationKindPublishedPackageVersion {
  packageVersion: PackageVersion!
}

type UserNotificationKindIncomingNamespaceInvite {
  namespaceInvite: NamespaceCollaboratorInvite!
}

type UserNotificationKindValidateEmail {
  user: User!
}

"""

    Enum of ways a user can login. One user can have many login methods
    associated with their account.
    
"""
enum LoginMethod {
  GOOGLE
  GITHUB
  PASSWORD
}

type SocialAuth implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  provider: String!
  uid: String!
  extraData: JSONString!
  created: DateTime!
  modified: DateTime!
  username: String!
}

type Signature {
  id: ID!
  publicKey: PublicKey!
  data: String!
  createdAt: DateTime!
}

type StripeCustomer {
  id: ID!
}

type Billing {
  stripeCustomer: StripeCustomer!
  payments: [PaymentIntent]!
  paymentMethods: [PaymentMethod]!
}

type PaymentIntent implements Node {
  """The datetime this object was created in stripe."""
  created: DateTime

  """Three-letter ISO currency code"""
  currency: String!

  """
  Status of this PaymentIntent, one of requires_payment_method, requires_confirmation, requires_action, processing, requires_capture, canceled, or succeeded. You can read more about PaymentIntent statuses here.
  """
  status: DjstripePaymentIntentStatusChoices!

  """The ID of the object"""
  id: ID!
  amount: String!
}

enum DjstripePaymentIntentStatusChoices {
  """
  Cancellation invalidates the intent for future confirmation and cannot be undone.
  """
  CANCELED

  """Required actions have been handled."""
  PROCESSING

  """Payment Method require additional action, such as 3D secure."""
  REQUIRES_ACTION

  """Capture the funds on the cards which have been put on holds."""
  REQUIRES_CAPTURE

  """Intent is ready to be confirmed."""
  REQUIRES_CONFIRMATION

  """Intent created and requires a Payment Method to be attached."""
  REQUIRES_PAYMENT_METHOD

  """The funds are in your account."""
  SUCCEEDED
}

union PaymentMethod = CardPaymentMethod

type CardPaymentMethod implements Node {
  """The ID of the object"""
  id: ID!
  brand: CardBrand!
  country: String!
  expMonth: Int!
  expYear: Int!
  funding: CardFunding!
  last4: String!
  isDefault: Boolean!
}

"""
Card brand.

Can be amex, diners, discover, jcb, mastercard, unionpay, visa, or unknown.
"""
enum CardBrand {
  AMEX
  DINERS
  DISCOVER
  JCB
  MASTERCARD
  UNIONPAY
  VISA
  UNKNOWN
}

"""
Card funding type.

Can be credit, debit, prepaid, or unknown.
"""
enum CardFunding {
  CREDIT
  DEBIT
  PREPAID
  UNKNOWN
}

type Payment {
  id: ID
  amount: String
  paidOn: DateTime
}

"""Log entry for deploy app."""
type Log {
  """Timestamp in nanoseconds"""
  timestamp: Float!

  """ISO 8601 string in UTC"""
  datetime: DateTime!

  """Log message"""
  message: String!

  """Log stream"""
  stream: LogStream
}

"""This is for backwards compatibility with the old PackageInstance type."""
interface PackageInstance {
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  isArchived: Boolean!
  clientName: String
  publishedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  package: Package!
  webc: WebcImage
  webcV3: WebcImage
  tag: String!
}

type UserNotificationKindIncomingPackageTransfer {
  packageTransferRequest: PackageTransferRequest!
}

type UserNotificationKindIncomingPackageInvite {
  packageInvite: PackageCollaboratorInvite!
}

input DeploymentV1 {
  name: String!
  workload: WorkloadV1!
}

input WorkloadV1 {
  capability: CapabilityMapV1
  name: String = null
  runner: WorkloadRunnerV1!
}

input AppV1Spec {
  aliases: [String] = []
  workload: WorkloadV2!
}

input WorkloadV2 {
  source: String!
}

input CapabilityCpuV1 {
  maximumThreads: Int
  maximumUsage: Int
}

input FileSystemPermissionsV1 {
  delete: Boolean
  read: Boolean
  write: Boolean
}

input FileSystemVolumeMountV1 {
  path: String!
  permissions: [FileSystemPermissionsV1]
}

input FileSystemVolumeSourceLocalV1 {
  maximumSize: String!
}

input FileSystemVolumeSourceV1 {
  local: FileSystemVolumeSourceLocalV1!
}

input FileSystemVolumeConfigV1 {
  mounts: [FileSystemVolumeMountV1]!
  name: String!
  source: FileSystemVolumeSourceV1!
}

input CapabilityFileSystemV1 {
  volumes: [FileSystemVolumeConfigV1]!
}

input CapabilityPersistentMemoryV1 {
  volumes: [String]
}

input CapabilityMemorySwapV1 {
  maximumSize: String
  memoryId: String
}

input CapabilityNetworkV1 {
  egress: NetworkEgressV1
}

input NetworkEgressV1 {
  enabled: Boolean
}

input CapabilityNetworkDnsV1 {
  enabled: Boolean
  servers: [String]
  allowedHosts: NetworkDnsAllowedHostsV1
}

input NetworkDnsAllowedHostsV1 {
  allowAllHosts: Boolean
  hosts: [String]
  regexPatterns: [String]
  wildcardPatterns: [String]
}

input CapabilityNetworkGatewayV1 {
  domains: [String]
  enforceHttps: Boolean
}

input CapabilityMapV1 {
  memorySwap: CapabilityCpuV1
}

input WebcSourceV1 {
  name: String!
  namespace: String!
  repository: String! = "https://registry.wasmer.wtf"
  tag: String
  authToken: String
}

input WorkloadRunnerV1 {
  webProxy: RunnerWebProxyV1
  wcgi: RunnerWCGIV1
}

"""Run a webassembly file."""
input RunnerWCGIV1 {
  source: WorkloadRunnerWasmSourceV1!
  dialect: String
}

input RunnerWebProxyV1 {
  source: WorkloadRunnerWasmSourceV1!
}

input WorkloadRunnerWasmSourceV1 {
  webc: WebcSourceV1!
}

type Query {
  latestTOS: TermsOfService!
  getDeployAppVersion(name: String!, owner: String, version: String): DeployAppVersion
  getAllDomains(namespace: String, offset: Int, before: String, after: String, first: Int, last: Int): DNSDomainConnection!
  getAllDNSRecords(sortBy: DNSRecordsSortBy, updatedAfter: DateTime, before: String, after: String, first: Int, last: Int): DNSRecordConnection!
  getDomain(name: String!): DNSDomain
  getDeployApp(
    name: String!

    """Owner of the app. Defaults to logged in user."""
    owner: String
  ): DeployApp
  getAppByGlobalAlias(alias: String!): DeployApp
  getDeployApps(sortBy: DeployAppsSortBy, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  getAppVersions(sortBy: DeployAppVersionsSortBy, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  getAppTemplates(categorySlug: String, offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection
  getAppTemplate(slug: String!): AppTemplate
  getAppTemplateCategories(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateCategoryConnection
  viewer: User
  getUser(username: String!): User
  getPasswordResetToken(token: String!): GetPasswordResetToken
  getAuthNonce(name: String!): Nonce

  """Can the logged in user create app templates?"""
  canDeployAppToGithub: Boolean!

  """Check if a repo exists in the logged in user's github account."""
  checkRepoExists(
    """The namespace of the repo to check."""
    namespace: String!

    """The name of the repo to check."""
    name: String!
  ): Boolean!

  """Generate a unique repo name in the logged in user's github account."""
  newRepoName(
    """The github namespace of the repo to create the repo in."""
    namespace: String!

    """The template to use."""
    templateSlug: String!
  ): String!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection
  recentPackageVersions(curated: Boolean, offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  allPackageVersions(sortBy: PackageVersionSortBy, createdAfter: DateTime, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  allPackageReleases(sortBy: PackageVersionSortBy, createdAfter: DateTime, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): PackageWebcConnection!
  getWebcImage(hash: String!): WebcImage
  getNamespace(name: String!): Namespace
  getPackage(name: String!): Package
  getPackages(names: [String!]!): [Package]!
  getPackageVersion(name: String!, version: String = "latest"): PackageVersion
  getPackageVersions(names: [String!]!): [PackageVersion]
  getPackageVersionByHash(name: String!, hash: String!): PackageVersion
  getInterface(name: String!): Interface
  getInterfaces(names: [String!]!): [Interface]!
  getInterfaceVersion(name: String!, version: String = "latest"): InterfaceVersion
  getContract(name: String!): Interface @deprecated(reason: "Please use getInterface instead")
  getContracts(names: [String!]!): [Interface]! @deprecated(reason: "Please use getInterfaces instead")
  getContractVersion(name: String!, version: String): InterfaceVersion @deprecated(reason: "Please use getInterfaceVersion instead")
  getCommand(name: String!): Command
  getCommands(names: [String!]!): [Command]
  getCollections(before: String, after: String, first: Int, last: Int): CollectionConnection
  getSignedUrlForPackageUpload(name: String, version: String = "latest", filename: String, expiresAfterSeconds: Int = 60): SignedUrl
  getPackageHash(name: String, hash: String!): PackageWebc
  getPackageRelease(hash: String!): PackageWebc
  categories(offset: Int, before: String, after: String, first: Int, last: Int): CategoryConnection!
  blogposts(tags: [String!], before: String, after: String, first: Int, last: Int): BlogPostConnection!
  getBlogpost(slug: String, featured: Boolean): BlogPost
  allBlogpostTags(offset: Int, before: String, after: String, first: Int, last: Int): BlogPostTagConnection
  search(query: String!, packages: PackagesFilter, namespaces: NamespacesFilter, users: UsersFilter, apps: AppFilter, blogposts: BlogPostsFilter, appTemplates: AppTemplateFilter, before: String, after: String, first: Int, last: Int): SearchConnection!
  searchAutocomplete(kind: [SearchKind!], query: String!, before: String, after: String, first: Int, last: Int): SearchConnection!
  getGlobalObject(slug: String!): GlobalObject
  node(
    """The ID of the object"""
    id: ID!
  ): Node
  nodes(ids: [ID!]!): [Node]
  info: RegistryInfo
}

type TermsOfService implements Node {
  """The ID of the object"""
  id: ID!
  content: String!
  createdAt: DateTime!
  viewerHasAccepted: Boolean!
}

type DNSRecordConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DNSRecordEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DNSRecord` and its cursor."""
type DNSRecordEdge {
  """The item at the end of the edge"""
  node: DNSRecord

  """A cursor for use in pagination"""
  cursor: String!
}

enum DNSRecordsSortBy {
  NEWEST
  OLDEST
}

type AppTemplateCategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppTemplateCategoryEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppTemplateCategory` and its cursor."""
type AppTemplateCategoryEdge {
  """The item at the end of the edge"""
  node: AppTemplateCategory

  """A cursor for use in pagination"""
  cursor: String!
}

type GetPasswordResetToken {
  valid: Boolean!
  user: User
}

enum PackageVersionSortBy {
  NEWEST
  OLDEST
}

type CollectionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CollectionEdge]!
}

"""A Relay edge containing a `Collection` and its cursor."""
type CollectionEdge {
  """The item at the end of the edge"""
  node: Collection

  """A cursor for use in pagination"""
  cursor: String!
}

type SignedUrl {
  url: String!
}

type BlogPostConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BlogPostEdge]!
}

"""A Relay edge containing a `BlogPost` and its cursor."""
type BlogPostEdge {
  """The item at the end of the edge"""
  node: BlogPost

  """A cursor for use in pagination"""
  cursor: String!
}

type BlogPost implements Node {
  """The ID of the object"""
  id: ID!
  live: Boolean!

  """The page title as you'd like it to be seen by the public"""
  title: String!

  """
  The name of the page as it will appear in URLs e.g http://domain.com/blog/[my-slug]/
  """
  slug: String!
  owner: User
  body: String!
  publishDate: DateTime
  theme: BlogBlogPostThemeChoices!
  url: String!
  coverImageUrl: String
  opengraphImageUrl: String
  tagline: String!
  relatedArticles: [BlogPost!]
  updatedAt: DateTime!
  tags: [BlogPostTag!]
  editUrl: String
}

enum BlogBlogPostThemeChoices {
  """Green"""
  GREEN

  """Purple"""
  PURPLE

  """Orange"""
  ORANGE

  """Blue"""
  BLUE
}

type BlogPostTag implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
}

type BlogPostTagConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BlogPostTagEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `BlogPostTag` and its cursor."""
type BlogPostTagEdge {
  """The item at the end of the edge"""
  node: BlogPostTag

  """A cursor for use in pagination"""
  cursor: String!
}

type SearchConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SearchEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Search` and its cursor."""
type SearchEdge {
  """The item at the end of the edge"""
  node: SearchResult

  """A cursor for use in pagination"""
  cursor: String!
}

union SearchResult = PackageVersion | User | Namespace | DeployApp | BlogPost | AppTemplate

input PackagesFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter packages by being curated."""
  curated: Boolean

  """Filter packages by publish date."""
  publishDate: SearchPublishDate

  """Filter packages by having bindings."""
  hasBindings: Boolean = false

  """Filter packages by being standalone."""
  isStandalone: Boolean = false

  """Filter packages by having commands."""
  hasCommands: Boolean = false

  """Filter packages by interface."""
  withInterfaces: [String]

  """Filter packages by deployable status."""
  deployable: Boolean

  """Filter packages by license."""
  license: String

  """Filter packages created after this date."""
  createdAfter: DateTime

  """Filter packages created before this date."""
  createdBefore: DateTime

  """Filter packages with version published after this date."""
  lastPublishedAfter: DateTime

  """Filter packages with version published before this date."""
  lastPublishedBefore: DateTime

  """Filter packages by size."""
  size: CountFilter

  """Filter packages by download count."""
  downloads: CountFilter

  """Filter packages by like count."""
  likes: CountFilter

  """Filter packages by owner."""
  owner: String

  """Filter packages by published by."""
  publishedBy: String

  """Order packages by field."""
  orderBy: PackageOrderBy = PUBLISHED_DATE
}

enum SearchOrderSort {
  ASC
  DESC
}

enum SearchPublishDate {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_YEAR
}

input CountFilter {
  count: Int = 0
  comparison: CountComparison = GREATER_THAN_OR_EQUAL
}

enum CountComparison {
  EQUAL
  GREATER_THAN
  LESS_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN_OR_EQUAL
}

enum PackageOrderBy {
  ALPHABETICALLY
  SIZE
  TOTAL_DOWNLOADS
  PUBLISHED_DATE
  CREATED_DATE
  TOTAL_LIKES
}

input NamespacesFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter namespaces by package count."""
  packageCount: CountFilter

  """Filter namespaces created after this date."""
  createdAfter: DateTime

  """Filter namespaces created before this date."""
  createdBefore: DateTime

  """Filter namespaces by user count."""
  userCount: CountFilter

  """Filter namespaces by collaborator."""
  collaborator: String

  """Order namespaces by field."""
  orderBy: NamespaceOrderBy = CREATED_DATE
}

enum NamespaceOrderBy {
  PACKAGE_COUNT
  COLLABORATOR_COUNT
  APP_COUNT
  CREATED_DATE
}

input UsersFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter users by package count."""
  packageCount: CountFilter

  """Filter users by namespace count."""
  namespaceCount: CountFilter

  """Filter users joined after this date."""
  joinedAfter: DateTime

  """Filter users joined before this date."""
  joinedBefore: DateTime

  """Order users by field."""
  orderBy: UserOrderBy = CREATED_DATE
}

enum UserOrderBy {
  PACKAGE_COUNT
  APP_COUNT
  CREATED_DATE
}

input AppFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter apps by deployed by."""
  deployedBy: String

  """Filter apps last deployed after this date."""
  lastDeployedAfter: DateTime

  """Filter apps last deployed before this date."""
  lastDeployedBefore: DateTime

  """Filter apps by owner."""
  owner: String

  """Order apps by field."""
  orderBy: AppOrderBy = CREATED_DATE

  """Filter apps by client name."""
  clientName: String
}

enum AppOrderBy {
  PUBLISHED_DATE
  CREATED_DATE
}

input BlogPostsFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Filter blog posts by tag."""
  tags: [String]
}

input AppTemplateFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = ASC

  """Order app templates by field."""
  orderBy: AppTemplateOrderBy = CREATED_DATE

  """Filter by app template framework"""
  framework: String

  """Filter by app template language"""
  language: String

  """Filter by one or more of the use-cases for the app template"""
  useCases: [String]
}

enum AppTemplateOrderBy {
  CREATED_DATE
}

enum SearchKind {
  PACKAGE
  NAMESPACE
  USER
}

union GlobalObject = User | Namespace

type RegistryInfo {
  """Base URL for this registry"""
  baseUrl: String!

  """Base URL for the default frontend"""
  defaultFrontend: String!

  """URL to the graphql endpoint"""
  graphqlUrl: String!

  """URL to the graphql endpoint"""
  createBlogpostUrl: String

  """Public metadata about packages"""
  packages: PackageInfo!

  """Public metadata about the graphql schema"""
  schema: SchemaInfo!
}

type PackageInfo {
  """Number of package versions published this month"""
  versionsPublishedThisMonth: Int!

  """Number of new packages published this month"""
  newPackagesThisMonth: Int!

  """Number of package downloads this month"""
  packageDownloadsThisMonth: Int!
}

type SchemaInfo {
  """Download link for graphql schema"""
  downloadUrl: String!

  """SHA256 hash of the schema data"""
  SHA256Hash: String!

  """Timestamp when the schema was last updated"""
  lastUpdated: DateTime!
}

type Mutation {
  """Viewer accepts the latest ToS."""
  acceptTOS(input: AcceptTOSInput!): AcceptTOSPayload
  publishDeployApp(input: PublishDeployAppInput!): PublishDeployAppPayload
  deleteApp(input: DeleteAppInput!): DeleteAppPayload

  """Add current user to the waitlist."""
  joinWaitlist(input: JoinWaitlistInput!): JoinWaitlistPayload

  """Add stripe payment to the user"""
  addPayment(input: AddPaymentInput!): AddPaymentPayload

  """
  Mutation to change the active version of a DeployApp to another DeployAppVersion.
  """
  markAppVersionAsActive(input: MarkAppVersionAsActiveInput!): MarkAppVersionAsActivePayload

  """Set a payment method as default for the user."""
  makePaymentDefault(input: SetDefaultPaymentMethodInput!): SetDefaultPaymentMethodPayload

  """
  Try to detach a payment method from customer.
  Fails if trying to detach a default method,
  or if it's the only payment method.
  """
  detachPaymentMethod(input: DetachPaymentMethodInput!): DetachPaymentMethodPayload
  generateDeployConfigToken(input: GenerateDeployConfigTokenInput!): GenerateDeployConfigTokenPayload
  renameApp(input: RenameAppInput!): RenameAppPayload
  renameAppAlias(input: RenameAppAliasInput!): RenameAppAliasPayload
  requestAppTransfer(input: RequestAppTransferInput!): RequestAppTransferPayload
  acceptAppTransferRequest(input: AcceptAppTransferRequestInput!): AcceptAppTransferRequestPayload
  removeAppTransferRequest(input: RemoveAppTransferRequestInput!): RemoveAppTransferRequestPayload
  createRepoForAppTemplate(input: CreateRepoForAppTemplateInput!): CreateRepoForAppTemplatePayload
  registerDomain(input: RegisterDomainInput!): RegisterDomainPayload
  upsertDNSRecord(input: UpsertDNSRecordInput!): UpsertDNSRecordPayload
  deleteDNSRecord(input: DeleteDNSRecordInput!): DeleteDNSRecordPayload
  upsertDomainFromZoneFile(input: UpsertDomainFromZoneFileInput!): UpsertDomainFromZoneFilePayload
  deleteDomain(input: DeleteDomainInput!): DeleteDomainPayload
  tokenAuth(input: ObtainJSONWebTokenInput!): ObtainJSONWebTokenPayload
  generateDeployToken(input: GenerateDeployTokenInput!): GenerateDeployTokenPayload
  verifyAccessToken(token: String): Verify
  refreshAccessToken(refreshToken: String): Refresh
  revokeAccessToken(refreshToken: String): Revoke
  registerUser(input: RegisterUserInput!): RegisterUserPayload
  socialAuth(input: SocialAuthJWTInput!): SocialAuthJWTPayload
  validateUserEmail(input: ValidateUserEmailInput!): ValidateUserEmailPayload
  requestPasswordReset(input: RequestPasswordResetInput!): RequestPasswordResetPayload
  requestValidationEmail(input: RequestValidationEmailInput!): RequestValidationEmailPayload
  changeUserPassword(input: ChangeUserPasswordInput!): ChangeUserPasswordPayload
  changeUserUsername(input: ChangeUserUsernameInput!): ChangeUserUsernamePayload
  changeUserEmail(input: ChangeUserEmailInput!): ChangeUserEmailPayload
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayload
  validateUserPassword(input: ValidateUserPasswordInput!): ValidateUserPasswordPayload
  generateApiToken(input: GenerateAPITokenInput!): GenerateAPITokenPayload
  revokeApiToken(input: RevokeAPITokenInput!): RevokeAPITokenPayload
  checkUserExists(input: CheckUserExistsInput!): CheckUserExistsPayload
  readNotification(input: ReadNotificationInput!): ReadNotificationPayload
  seePendingNotifications(input: SeePendingNotificationsInput!): SeePendingNotificationsPayload
  newNonce(input: NewNonceInput!): NewNoncePayload
  validateNonce(input: ValidateNonceInput!): ValidateNoncePayload
  mfa2totpGetToken(input: MFATOTPGetTokenInput!): MFATOTPTokenType
  mfa2totpVerify(input: MFATOTPVerifyInput!): MFATOTPVerifyPayload
  mfa2totpAuth(input: MFATOTPAuthInput!): MFAAuthResponse
  mfa2RecoveryGetToken(input: MFAGenerateRecoveryTokenInput!): MFARecoveryCodes
  mfa2RecoveryAuth(input: MFARecoveryAuthInput!): MFAAuthResponse
  mfa2EmailAuth(input: MFAEmailAuthInput!): MFAAuthResponse
  mfa2EmailGetToken(input: MFAGenerateEmailOTPInput!): MFAEmailGenerationResponse
  publishPublicKey(input: PublishPublicKeyInput!): PublishPublicKeyPayload
  publishPackage(input: PublishPackageInput!): PublishPackagePayload
  updatePackage(input: UpdatePackageInput!): UpdatePackagePayload
  likePackage(input: LikePackageInput!): LikePackagePayload
  unlikePackage(input: UnlikePackageInput!): UnlikePackagePayload
  watchPackage(input: WatchPackageInput!): WatchPackagePayload
  unwatchPackage(input: UnwatchPackageInput!): UnwatchPackagePayload
  archivePackage(input: ArchivePackageInput!): ArchivePackagePayload
  renamePackage(input: RenamePackageInput!): RenamePackagePayload
  changePackageVersionArchivedStatus(input: ChangePackageVersionArchivedStatusInput!): ChangePackageVersionArchivedStatusPayload
  createNamespace(input: CreateNamespaceInput!): CreateNamespacePayload
  updateNamespace(input: UpdateNamespaceInput!): UpdateNamespacePayload
  deleteNamespace(input: DeleteNamespaceInput!): DeleteNamespacePayload
  inviteNamespaceCollaborator(input: InviteNamespaceCollaboratorInput!): InviteNamespaceCollaboratorPayload
  acceptNamespaceCollaboratorInvite(input: AcceptNamespaceCollaboratorInviteInput!): AcceptNamespaceCollaboratorInvitePayload
  removeNamespaceCollaboratorInvite(input: RemoveNamespaceCollaboratorInviteInput!): RemoveNamespaceCollaboratorInvitePayload
  removeNamespaceCollaborator(input: RemoveNamespaceCollaboratorInput!): RemoveNamespaceCollaboratorPayload
  updateNamespaceCollaboratorRole(input: UpdateNamespaceCollaboratorRoleInput!): UpdateNamespaceCollaboratorRolePayload
  updateNamespaceCollaboratorInviteRole(input: UpdateNamespaceCollaboratorInviteRoleInput!): UpdateNamespaceCollaboratorInviteRolePayload
  invitePackageCollaborator(input: InvitePackageCollaboratorInput!): InvitePackageCollaboratorPayload
  acceptPackageCollaboratorInvite(input: AcceptPackageCollaboratorInviteInput!): AcceptPackageCollaboratorInvitePayload
  removePackageCollaboratorInvite(input: RemovePackageCollaboratorInviteInput!): RemovePackageCollaboratorInvitePayload
  updatePackageCollaboratorRole(input: UpdatePackageCollaboratorRoleInput!): UpdatePackageCollaboratorRolePayload
  updatePackageCollaboratorInviteRole(input: UpdatePackageCollaboratorInviteRoleInput!): UpdatePackageCollaboratorInviteRolePayload
  removePackageCollaborator(input: RemovePackageCollaboratorInput!): RemovePackageCollaboratorPayload
  requestPackageTransfer(input: RequestPackageTransferInput!): RequestPackageTransferPayload
  acceptPackageTransferRequest(input: AcceptPackageTransferRequestInput!): AcceptPackageTransferRequestPayload
  removePackageTransferRequest(input: RemovePackageTransferRequestInput!): RemovePackageTransferRequestPayload
  generateBindingsForAllPackages(input: GenerateBindingsForAllPackagesInput!): GenerateBindingsForAllPackagesPayload
  makePackagePublic(input: MakePackagePublicInput!): MakePackagePublicPayload
}

"""Viewer accepts the latest ToS."""
type AcceptTOSPayload {
  TOS: TermsOfService!
  clientMutationId: String
}

input AcceptTOSInput {
  clientMutationId: String
}

type PublishDeployAppPayload {
  deployAppVersion: DeployAppVersion!
  clientMutationId: String
}

input PublishDeployAppInput {
  """The configuration of the app."""
  config: Configuration!

  """The name of the app."""
  name: ID

  """The owner of the app."""
  owner: ID

  """The description of the app."""
  description: String

  """If true, the new version will be set as the default version."""
  makeDefault: Boolean = true

  """
  If true, Publishing will fail if the source package does not have a valid webc.
  """
  strict: Boolean = false
  clientMutationId: String
}

input Configuration {
  deployment: AppConfigV1
  yamlConfig: String
}

input AppConfigV1 {
  kind: String = "wasmer.io/App.v0"
  appId: ID
  name: String!
  description: String
  package: String!
}

type DeleteAppPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteAppInput {
  """App ID to delete."""
  id: ID!
  clientMutationId: String
}

"""Add current user to the waitlist."""
type JoinWaitlistPayload {
  waitlistMember: WaitlistMember!
  clientMutationId: String
}

input JoinWaitlistInput {
  name: String!
  clientMutationId: String
}

"""Add stripe payment to the user"""
type AddPaymentPayload {
  customerSecret: String!
  clientMutationId: String
}

input AddPaymentInput {
  clientMutationId: String
}

"""
Mutation to change the active version of a DeployApp to another DeployAppVersion.
"""
type MarkAppVersionAsActivePayload {
  app: DeployApp!
  clientMutationId: String
}

input MarkAppVersionAsActiveInput {
  """The ID of the DeployAppVersion to set as the new active version."""
  appVersion: ID!
  clientMutationId: String
}

"""Set a payment method as default for the user."""
type SetDefaultPaymentMethodPayload {
  success: Boolean!
  billing: Billing!
  clientMutationId: String
}

input SetDefaultPaymentMethodInput {
  paymentMethod: ID!
  clientMutationId: String
}

"""
Try to detach a payment method from customer.
Fails if trying to detach a default method,
or if it's the only payment method.
"""
type DetachPaymentMethodPayload {
  success: Boolean!
  billing: Billing!
  clientMutationId: String
}

input DetachPaymentMethodInput {
  paymentMethod: ID!
  clientMutationId: String
}

type GenerateDeployConfigTokenPayload {
  token: String!
  config: String!
  clientMutationId: String
}

input GenerateDeployConfigTokenInput {
  config: String!
  clientMutationId: String
}

type RenameAppPayload {
  success: Boolean!
  app: DeployApp!
  clientMutationId: String
}

input RenameAppInput {
  """App ID to delete."""
  id: ID!

  """New name for the app."""
  name: String!
  clientMutationId: String
}

type RenameAppAliasPayload {
  success: Boolean!
  alias: AppAlias!
  clientMutationId: String
}

input RenameAppAliasInput {
  """App alias ID to delete."""
  id: ID!

  """New name for the alias."""
  name: String!
  clientMutationId: String
}

type RequestAppTransferPayload {
  appTransferRequest: AppTransferRequest
  wasInstantlyTransferred: Boolean!
  clientMutationId: String
}

type AppTransferRequest implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  previousOwnerObjectId: Int!
  newOwnerObjectId: Int!
  app: DeployApp!
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
  previousOwner: Owner!
  newOwner: Owner!
}

input RequestAppTransferInput {
  appId: ID!
  newOwnerId: ID!
  clientMutationId: String
}

type AcceptAppTransferRequestPayload {
  app: DeployApp!
  appTransferRequest: AppTransferRequest!
  clientMutationId: String
}

input AcceptAppTransferRequestInput {
  appTransferRequestId: ID!
  clientMutationId: String
}

type RemoveAppTransferRequestPayload {
  app: DeployApp!
  clientMutationId: String
}

input RemoveAppTransferRequestInput {
  appTransferRequestId: ID!
  clientMutationId: String
}

type CreateRepoForAppTemplatePayload {
  success: Boolean!
  repoId: ID!
  clientMutationId: String
}

input CreateRepoForAppTemplateInput {
  templateId: ID!
  name: String!
  namespace: String!
  private: Boolean = false
  clientMutationId: String
}

type RegisterDomainPayload {
  success: Boolean!
  domain: DNSDomain
  clientMutationId: String
}

input RegisterDomainInput {
  name: String!
  namespace: String
  importRecords: Boolean = true
  clientMutationId: String
}

type UpsertDNSRecordPayload {
  success: Boolean!
  record: DNSRecord!
  clientMutationId: String
}

input UpsertDNSRecordInput {
  kind: RecordKind!
  domainId: String!
  name: String!
  value: String!
  ttl: Int
  recordId: String
  mx: DNSMXExtraInput
  clientMutationId: String
}

enum RecordKind {
  A
  AAAA
  CNAME
  MX
  NS
  TXT
  DNAME
  PTR
  SOA
  SRV
  CAA
  SSHFP
}

input DNSMXExtraInput {
  preference: Int!
}

type DeleteDNSRecordPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteDNSRecordInput {
  recordId: ID!
  clientMutationId: String
}

type UpsertDomainFromZoneFilePayload {
  success: Boolean!
  domain: DNSDomain!
  clientMutationId: String
}

input UpsertDomainFromZoneFileInput {
  zoneFile: String!
  deleteMissingRecords: Boolean
  clientMutationId: String
}

type DeleteDomainPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteDomainInput {
  domainId: ID!
  clientMutationId: String
}

type ObtainJSONWebTokenPayload {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  username: CaseInsensitiveString!
  clientMutationId: String
  token: String!
  refreshToken: String!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""
The `CaseInsensitiveString` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.
"""
scalar CaseInsensitiveString

input ObtainJSONWebTokenInput {
  clientMutationId: String
  username: String!
  password: String!
}

type GenerateDeployTokenPayload {
  token: String!
  deployConfigVersion: DeployAppVersion!
  clientMutationId: String
}

input GenerateDeployTokenInput {
  deployConfigVersionId: String!
  clientMutationId: String
}

type Verify {
  payload: GenericScalar!
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  refreshToken: String!
}

type Revoke {
  revoked: Int!
}

type RegisterUserPayload {
  token: String
  clientMutationId: String
}

input RegisterUserInput {
  fullName: String!
  email: String!
  username: CaseInsensitiveString!
  password: String!
  acceptedTos: Boolean
  clientMutationId: String
}

type SocialAuthJWTPayload {
  social: SocialAuth
  token: String
  clientMutationId: String
}

input SocialAuthJWTInput {
  provider: String!
  accessToken: String!
  register: Boolean = false
  clientMutationId: String
}

type ValidateUserEmailPayload {
  user: User
  clientMutationId: String
}

input ValidateUserEmailInput {
  """The user id"""
  userId: ID
  challenge: String!
  clientMutationId: String
}

type RequestPasswordResetPayload {
  email: String!
  errors: [ErrorType]
  clientMutationId: String
}

type ErrorType {
  field: String!
  messages: [String!]!
}

input RequestPasswordResetInput {
  email: String!
  clientMutationId: String
}

type RequestValidationEmailPayload {
  user: User
  success: Boolean!
  clientMutationId: String
}

input RequestValidationEmailInput {
  """The user id"""
  userId: ID
  clientMutationId: String
}

type ChangeUserPasswordPayload {
  token: String
  clientMutationId: String
}

input ChangeUserPasswordInput {
  """
  The token associated to change the password. If not existing it will use the request user by default
  """
  token: String
  oldPassword: String
  password: String!
  clientMutationId: String
}

type ChangeUserUsernamePayload {
  user: User
  token: String
  clientMutationId: String
}

input ChangeUserUsernameInput {
  """The new user username"""
  username: CaseInsensitiveString!
  clientMutationId: String
}

type ChangeUserEmailPayload {
  user: User!
  clientMutationId: String
}

input ChangeUserEmailInput {
  newEmail: String!
  clientMutationId: String
}

type UpdateUserInfoPayload {
  user: User
  clientMutationId: String
}

input UpdateUserInfoInput {
  """The user id"""
  userId: ID

  """The user full name"""
  fullName: String

  """The user bio"""
  bio: String

  """The user avatar"""
  avatar: String

  """
  The user Twitter (it can be the url, or the handle with or without the @)
  """
  twitter: String

  """
  The user Github (it can be the url, or the handle with or without the @)
  """
  github: String

  """The user website (it must be a valid url)"""
  websiteUrl: String

  """The user location"""
  location: String
  clientMutationId: String
}

type ValidateUserPasswordPayload {
  success: Boolean
  clientMutationId: String
}

input ValidateUserPasswordInput {
  password: String!
  clientMutationId: String
}

type GenerateAPITokenPayload {
  token: APIToken
  tokenRaw: String
  user: User
  clientMutationId: String
}

input GenerateAPITokenInput {
  identifier: String
  clientMutationId: String
}

type RevokeAPITokenPayload {
  token: APIToken
  success: Boolean
  clientMutationId: String
}

input RevokeAPITokenInput {
  """The API token ID"""
  tokenId: ID!
  clientMutationId: String
}

type CheckUserExistsPayload {
  exists: Boolean!

  """The user is only returned if the user input was the username"""
  user: User
  clientMutationId: String
}

input CheckUserExistsInput {
  """The user"""
  user: String!
  clientMutationId: String
}

type ReadNotificationPayload {
  notification: UserNotification
  clientMutationId: String
}

input ReadNotificationInput {
  notificationId: ID!
  clientMutationId: String
}

type SeePendingNotificationsPayload {
  success: Boolean
  clientMutationId: String
}

input SeePendingNotificationsInput {
  clientMutationId: String
}

type NewNoncePayload {
  nonce: Nonce!
  clientMutationId: String
}

input NewNonceInput {
  name: String!
  callbackUrl: String!
  clientMutationId: String
}

type ValidateNoncePayload {
  nonce: Nonce!
  clientMutationId: String
}

input ValidateNonceInput {
  id: ID!
  secret: String!
  clientMutationId: String
}

type MFATOTPTokenType {
  qr: String
  secretKey: String
}

input MFATOTPGetTokenInput {
  clientMutationId: String
}

type MFATOTPVerifyPayload {
  status: MFATOTPVerifyStatus
  clientMutationId: String
}

enum MFATOTPVerifyStatus {
  SUCCESS
  RECOVERY
}

input MFATOTPVerifyInput {
  answer: String!
  secretKey: String!
  clientMutationId: String
}

"""Response object for MFAAuth mutation."""
type MFAAuthResponse {
  success: Boolean!
  token: String
  refreshToken: String
  username: String
  refreshTokenExpiresIn: Int
}

input MFATOTPAuthInput {
  username: String!
  otp: String!
  clientMutationId: String
}

type MFARecoveryCodes {
  codes: [String]!
}

input MFAGenerateRecoveryTokenInput {
  clientMutationId: String
}

input MFARecoveryAuthInput {
  username: String!
  otp: String!
  clientMutationId: String
}

input MFAEmailAuthInput {
  username: String!
  otp: String!
  clientMutationId: String
}

type MFAEmailGenerationResponse {
  success: Boolean!
}

input MFAGenerateEmailOTPInput {
  clientMutationId: String
}

type PublishPublicKeyPayload {
  success: Boolean!
  publicKey: PublicKey!
  clientMutationId: String
}

input PublishPublicKeyInput {
  keyId: String!
  key: String!
  verifyingSignatureId: String
  clientMutationId: String
}

type PublishPackagePayload {
  success: Boolean!
  packageVersion: PackageVersion
  packageWebc: PackageWebc
  clientMutationId: String
}

input PublishPackageInput {
  manifest: String!
  name: String
  namespace: String
  version: String
  description: String
  license: String
  licenseFile: String
  readme: String
  repository: String
  homepage: String
  file: String
  signedUrl: String
  signature: InputSignature

  """The package icon"""
  icon: String

  """Whether the package is private"""
  private: Boolean = false

  """The upload format of the package"""
  uploadFormat: UploadFormat = targz

  """Whether to wait for webc generation to finish"""
  wait: Boolean = false
  clientMutationId: String
}

input InputSignature {
  publicKeyKeyId: String!
  data: String!
}

enum UploadFormat {
  targz
  webcv2
  webcv3
}

type UpdatePackagePayload {
  package: Package!
  clientMutationId: String
}

input UpdatePackageInput {
  packageId: ID!

  """The package icon"""
  icon: String
  clientMutationId: String
}

type LikePackagePayload {
  package: Package!
  clientMutationId: String
}

input LikePackageInput {
  packageId: ID!
  clientMutationId: String
}

type UnlikePackagePayload {
  package: Package!
  clientMutationId: String
}

input UnlikePackageInput {
  packageId: ID!
  clientMutationId: String
}

type WatchPackagePayload {
  package: Package!
  clientMutationId: String
}

input WatchPackageInput {
  packageId: ID!
  clientMutationId: String
}

type UnwatchPackagePayload {
  package: Package!
  clientMutationId: String
}

input UnwatchPackageInput {
  packageId: ID!
  clientMutationId: String
}

type ArchivePackagePayload {
  package: Package!
  clientMutationId: String
}

input ArchivePackageInput {
  packageId: ID!
  clientMutationId: String
}

type RenamePackagePayload {
  package: Package!
  clientMutationId: String
}

input RenamePackageInput {
  packageId: ID!
  newName: String!
  clientMutationId: String
}

type ChangePackageVersionArchivedStatusPayload {
  packageVersion: PackageVersion!
  clientMutationId: String
}

input ChangePackageVersionArchivedStatusInput {
  packageVersionId: ID!
  isArchived: Boolean
  clientMutationId: String
}

type CreateNamespacePayload {
  namespace: Namespace!
  user: User!
  clientMutationId: String
}

input CreateNamespaceInput {
  name: String!

  """The namespace display name"""
  displayName: String

  """The namespace description"""
  description: String

  """The namespace avatar"""
  avatar: String
  clientMutationId: String
}

type UpdateNamespacePayload {
  namespace: Namespace!
  clientMutationId: String
}

input UpdateNamespaceInput {
  namespaceId: ID!

  """The namespace slug name"""
  name: String

  """The namespace display name"""
  displayName: String

  """The namespace description"""
  description: String

  """The namespace avatar"""
  avatar: String

  """
  The user Twitter (it can be the url, or the handle with or without the @)
  """
  twitter: String

  """
  The user Github (it can be the url, or the handle with or without the @)
  """
  github: String

  """The user website (it must be a valid url)"""
  websiteUrl: String
  clientMutationId: String
}

type DeleteNamespacePayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteNamespaceInput {
  namespaceId: ID!
  clientMutationId: String
}

type InviteNamespaceCollaboratorPayload {
  invite: NamespaceCollaboratorInvite!
  namespace: Namespace!
  clientMutationId: String
}

input InviteNamespaceCollaboratorInput {
  namespaceId: ID!
  role: GrapheneRole!
  username: String
  email: String
  clientMutationId: String
}

type AcceptNamespaceCollaboratorInvitePayload {
  namespaceCollaboratorInvite: NamespaceCollaboratorInvite!
  clientMutationId: String
}

input AcceptNamespaceCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemoveNamespaceCollaboratorInvitePayload {
  namespace: Namespace!
  clientMutationId: String
}

input RemoveNamespaceCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemoveNamespaceCollaboratorPayload {
  namespace: Namespace!
  clientMutationId: String
}

input RemoveNamespaceCollaboratorInput {
  namespaceCollaboratorId: ID!
  clientMutationId: String
}

type UpdateNamespaceCollaboratorRolePayload {
  collaborator: NamespaceCollaborator!
  clientMutationId: String
}

input UpdateNamespaceCollaboratorRoleInput {
  namespaceCollaboratorId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type UpdateNamespaceCollaboratorInviteRolePayload {
  collaboratorInvite: NamespaceCollaboratorInvite!
  clientMutationId: String
}

input UpdateNamespaceCollaboratorInviteRoleInput {
  namespaceCollaboratorInviteId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type InvitePackageCollaboratorPayload {
  invite: PackageCollaboratorInvite!
  package: Package!
  clientMutationId: String
}

input InvitePackageCollaboratorInput {
  packageName: String!
  role: GrapheneRole!
  username: String
  email: String
  clientMutationId: String
}

type AcceptPackageCollaboratorInvitePayload {
  packageCollaboratorInvite: PackageCollaboratorInvite!
  clientMutationId: String
}

input AcceptPackageCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemovePackageCollaboratorInvitePayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type UpdatePackageCollaboratorRolePayload {
  collaborator: PackageCollaborator!
  clientMutationId: String
}

input UpdatePackageCollaboratorRoleInput {
  packageCollaboratorId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type UpdatePackageCollaboratorInviteRolePayload {
  collaboratorInvite: PackageCollaboratorInvite!
  clientMutationId: String
}

input UpdatePackageCollaboratorInviteRoleInput {
  packageCollaboratorInviteId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type RemovePackageCollaboratorPayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageCollaboratorInput {
  packageCollaboratorId: ID!
  clientMutationId: String
}

type RequestPackageTransferPayload {
  package: Package!
  wasInstantlyTransferred: Boolean!
  packageTransferRequest: PackageTransferRequest
  clientMutationId: String
}

input RequestPackageTransferInput {
  packageId: ID!
  newOwnerId: ID!
  clientMutationId: String
}

type AcceptPackageTransferRequestPayload {
  package: Package!
  packageTransferRequest: PackageTransferRequest!
  clientMutationId: String
}

input AcceptPackageTransferRequestInput {
  packageTransferRequestId: ID!
  clientMutationId: String
}

type RemovePackageTransferRequestPayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageTransferRequestInput {
  packageTransferRequestId: ID!
  clientMutationId: String
}

type GenerateBindingsForAllPackagesPayload {
  message: String!
  clientMutationId: String
}

input GenerateBindingsForAllPackagesInput {
  bindingsGeneratorId: ID
  bindingsGeneratorCommand: String
  clientMutationId: String
}

type MakePackagePublicPayload {
  package: Package!
  clientMutationId: String
}

input MakePackagePublicInput {
  """The ID of the package to make public"""
  id: ID!
  clientMutationId: String
}

type Subscription {
  streamLogs(
    appVersionId: ID!

    """
    Get logs starting from this timestamp. Takes ISO timestamp in UTC timezone.
    """
    startingFromISO: DateTime

    """
    Fetch logs until this timestamp. Takes ISO timestamp in UTC timezone. If specified, the subscription will at this time.
    """
    untilISO: DateTime

    """Filter logs by stream"""
    streams: [LogStream]

    """Filter logs by instance ids"""
    instanceIds: [String]

    """Search logs for this term"""
    searchTerm: String
  ): Log!
  waitOnRepoCreation(repoId: ID!): Boolean!
  appIsPublishedFromRepo(repoId: ID!): DeployAppVersion!
  packageVersionCreated(publishedBy: ID, ownerId: ID): PackageVersion!

  """Subscribe to package version ready"""
  packageVersionReady(packageVersionId: ID!): PackageVersionReadyResponse!
  userNotificationCreated(userId: ID!): UserNotificationCreated!
}

type PackageVersionReadyResponse {
  state: PackageVersionState!
  packageVersion: PackageVersion!
  success: Boolean!
}

enum PackageVersionState {
  WEBC_GENERATED
  BINDINGS_GENERATED
  NATIVE_EXES_GENERATED
}

type UserNotificationCreated {
  notification: UserNotification
  notificationDeletedId: ID
}
