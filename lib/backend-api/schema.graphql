"""
Directs the executor to include this field or fragment only when the user is not logged in.
"""
directive @includeIfLoggedIn on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
Directs the executor to skip this field or fragment when the user is not logged in.
"""
directive @skipIfLoggedIn on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

interface Node {
  """The ID of the object"""
  id: ID!
}

type PublicKey implements Node {
  """The ID of the object"""
  id: ID!
  owner: User!
  keyId: String!
  key: String!
  revokedAt: DateTime
  uploadedAt: DateTime!
  verifyingSignature: Signature
  revoked: Boolean!
}

type User implements Node & PackageOwner & Owner {
  firstName: String!
  lastName: String!
  email: String!
  dateJoined: DateTime!
  probationStartedAt: DateTime

  """Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only."""
  username: String!
  registerIntent: String
  isEmailValidated: Boolean!
  bio: String
  location: String
  websiteUrl: String
  wasmerInternal: Boolean!

  """The ID of the object"""
  id: ID!
  globalName: String!
  globalId: ID!
  viewerCan(action: OwnerAction!): Boolean!
  avatar(size: Int = 80): String!
  limitState: LimitState!
  isViewer: Boolean!
  hasUsablePassword: Boolean
  fullName: String!
  githubUrl: String
  twitterUrl: String
  companyRole: String
  companyDescription: String
  publicActivity(offset: Int, before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  billing: Billing
  waitlist(name: String!): WaitlistMember
  namespaces(role: GrapheneRole, offset: Int, before: String, after: String, first: Int, last: Int): NamespaceConnection!
  packages(collaborating: Boolean = false, offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  apps(collaborating: Boolean = false, sortBy: DeployAppsSortBy, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  usageMetrics(
    variant: MetricType!
    grouping: MetricGrouping

    """List of app IDs. Metrics gets filtered for the specific apps."""
    appIds: [ID]

    """Optional time range filter."""
    timeRange: TimeRangeInput
  ): [UsageMetric]!
  domains(offset: Int, before: String, after: String, first: Int, last: Int): DNSDomainConnection!
  isStaff: Boolean
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  packageTransfersIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageTransferRequestConnection!
  packageInvitesIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorInviteConnection!
  namespaceInvitesIncoming(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  apiTokens(before: String, after: String, first: Int, last: Int): APITokenConnection!
  notifications(before: String, after: String, first: Int, last: Int): UserNotificationConnection!
  dashboardActivity(offset: Int, before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  loginMethods: [LoginMethod!]!
  githubUser: SocialAuth
  githubScopes: [String]!
  githubRepositories: [GithubRepository]!
  isPro: Boolean!
  currentUsage(
    """List of app IDs. Usage gets filtered for the specific apps."""
    appIds: [ID]

    """Optional time range filter."""
    timeRange: TimeRangeInput
  ): OwnerUsageSummary
  webhooks: [Webhook]
}

"""Setup for backwards compatibility with existing frontends."""
interface PackageOwner {
  globalName: String!
  globalId: ID!
  viewerCan(action: OwnerAction!): Boolean!
}

enum OwnerAction {
  DEPLOY_APP
  PUBLISH_PACKAGE
}

"""An owner of a package."""
interface Owner {
  globalName: String!
  globalId: ID!
  viewerCan(action: OwnerAction!): Boolean!
}

"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

enum LimitState {
  not_limited
  nearing_limits
  under_probation
  limit_exceeded
}

type ActivityEventConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [ActivityEventEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
The Relay compliant `PageInfo` type, containing data necessary to paginate this connection.
"""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""A Relay edge containing a `ActivityEvent` and its cursor."""
type ActivityEventEdge {
  """The item at the end of the edge"""
  node: ActivityEvent

  """A cursor for use in pagination"""
  cursor: String!
}

type ActivityEvent implements Node {
  """The ID of the object"""
  id: ID!
  body: EventBody!
  actorIcon: String!
  createdAt: DateTime!
}

type EventBody {
  text: String!
  ranges: [NodeBodyRange!]!
}

type NodeBodyRange {
  entity: Node!
  offset: Int!
  length: Int!
}

type WaitlistMember implements Node {
  waitlist: Waitlist!
  joinedAt: DateTime!
  approvedAt: DateTime

  """The ID of the object"""
  id: ID!
  member: Owner!
  approved: Boolean!
}

type Waitlist implements Node {
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!

  """The ID of the object"""
  id: ID!
}

type NamespaceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Namespace` and its cursor."""
type NamespaceEdge {
  """The item at the end of the edge"""
  node: Namespace

  """A cursor for use in pagination"""
  cursor: String!
}

type Namespace implements Node & PackageOwner & Owner {
  """The ID of the object"""
  id: ID!
  probationStartedAt: DateTime
  name: String!
  displayName: String
  description: String!
  avatarUpdatedAt: DateTime
  twitterHandle: String
  githubHandle: String
  websiteUrl: String
  createdAt: DateTime!
  updatedAt: DateTime!
  wasmerInternal: Boolean!
  maintainerInvites(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int): UserConnection!
  globalName: String!
  globalId: ID!
  viewerCan(action: OwnerAction!): Boolean!
  limitState: LimitState!
  avatar: String!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  apps(sortBy: DeployAppsSortBy, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  collaborators(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorConnection!
  publicActivity(before: String, after: String, first: Int, last: Int): ActivityEventConnection!
  pendingInvites(offset: Int, before: String, after: String, first: Int, last: Int): NamespaceCollaboratorInviteConnection!
  viewerHasRole(role: GrapheneRole!): Boolean!
  viewerAsCollaborator(role: GrapheneRole): NamespaceCollaborator

  """Whether the current user is invited to the namespace"""
  viewerIsInvited: Boolean!

  """The invitation for the current user to the namespace"""
  viewerInvitation: NamespaceCollaboratorInvite
  packageTransfersIncoming(offset: Int, before: String, after: String, first: Int, last: Int): PackageTransferRequestConnection!
  usageMetrics(
    variant: MetricType!
    grouping: MetricGrouping

    """List of app IDs. Metrics gets filtered for the specific apps."""
    appIds: [ID]

    """Optional time range filter."""
    timeRange: TimeRangeInput
  ): [UsageMetric]!
  domains(offset: Int, before: String, after: String, first: Int, last: Int): DNSDomainConnection!
  isPro: Boolean!
  billing: Billing
  currentUsage(
    """List of app IDs. Usage gets filtered for the specific apps."""
    appIds: [ID]

    """Optional time range filter."""
    timeRange: TimeRangeInput
  ): OwnerUsageSummary
}

type NamespaceCollaboratorInviteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceCollaboratorInviteEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
A Relay edge containing a `NamespaceCollaboratorInvite` and its cursor.
"""
type NamespaceCollaboratorInviteEdge {
  """The item at the end of the edge"""
  node: NamespaceCollaboratorInvite

  """A cursor for use in pagination"""
  cursor: String!
}

type NamespaceCollaboratorInvite implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  user: User
  inviteEmail: String
  namespace: Namespace!
  role: RegistryNamespaceMaintainerInviteRoleChoices!
  accepted: NamespaceCollaborator
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
}

enum RegistryNamespaceMaintainerInviteRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type NamespaceCollaborator implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  role: RegistryNamespaceMaintainerRoleChoices!
  namespace: Namespace!
  createdAt: DateTime!
  updatedAt: DateTime!
  invite: NamespaceCollaboratorInvite
}

enum RegistryNamespaceMaintainerRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type UserConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `User` and its cursor."""
type UserEdge {
  """The item at the end of the edge"""
  node: User

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Package` and its cursor."""
type PackageEdge {
  """The item at the end of the edge"""
  node: Package

  """A cursor for use in pagination"""
  cursor: String!
}

type Package implements Likeable & Node & PackageOwner {
  """The ID of the object"""
  id: ID!
  name: String!
  namespace: String!
  private: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  maintainers: [User]! @deprecated(reason: "Please use collaborators instead")
  curated: Boolean!
  ownerObjectId: Int!
  lastVersion: PackageVersion

  """The app icon. It should be formatted in the same way as Apple icons"""
  icon: String!
  totalDownloads: Int!
  iconUpdatedAt: DateTime
  likersCount: Int!
  watchersCount: Int!
  webcs(offset: Int, before: String, after: String, first: Int, last: Int): WebcImageConnection!
  packagewebcSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageWebcConnection!
  versions: [PackageVersion]
  collectionSet: [Collection!]!

  """List of app templates for this package"""
  appTemplates(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection!
  categories(offset: Int, before: String, after: String, first: Int, last: Int): CategoryConnection!
  keywords(offset: Int, before: String, after: String, first: Int, last: Int): PackageKeywordConnection!
  viewerHasLiked: Boolean!
  globalName: String!
  globalId: ID!
  viewerCan(action: OwnerAction!): Boolean!
  alias: String
  displayName: String!

  """The name of the package without the owner"""
  packageName: String!

  """The app icon. It should be formatted in the same way as Apple icons"""
  appIcon: String! @deprecated(reason: "Please use icon instead")

  """The total number of downloads of the package"""
  downloadsCount: Int

  """The public keys for all the published versions"""
  publicKeys: [PublicKey!]!
  collaborators(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorConnection!
  pendingInvites(offset: Int, before: String, after: String, first: Int, last: Int): PackageCollaboratorInviteConnection!
  viewerHasRole(role: GrapheneRole!): Boolean!
  viewerAsCollaborator(role: GrapheneRole): PackageCollaborator
  owner: PackageOwner!
  isTransferring: Boolean!
  activeTransferRequest: PackageTransferRequest
  isArchived: Boolean!
  viewerIsWatching: Boolean!
  showDeployButton: Boolean!
  similarPackageVersions(before: String, after: String, first: Int, last: Int): PackageSearchConnection!

  """Whether the current user is invited to the package"""
  viewerIsInvited: Boolean!

  """The invitation for the current user to the package"""
  viewerInvitation: PackageCollaboratorInvite
}

interface Likeable {
  id: ID!
  likersCount: Int!
  viewerHasLiked: Boolean!
}

type PackageVersion implements Node & PackageReleaseInterface & PackageInstance {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  package: Package!
  webc: WebcImage
  webcV3: WebcImage

  """List of direct dependencies of this package version"""
  dependencies(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  publishedBy: User!
  tag: String!
  clientName: String
  webcGenerationErrors: String
  version: String!
  description: String!
  manifest: String!
  license: String
  licenseFile: String
  readme: String
  witMd: String
  repository: String
  homepage: String
  staticObjectsCompiled: Boolean!
  nativeExecutablesCompiled: Boolean!
  signature: Signature
  isArchived: Boolean!
  file: String!

  """"""
  fileSize: BigInt!
  totalDownloads: Int!
  bindingsState: RegistryPackageVersionBindingsStateChoices!
  nativeExecutablesState: RegistryPackageVersionNativeExecutablesStateChoices!
  packagewebcSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageWebcConnection!
  lastversionPackage(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection!
  commands: [Command!]!
  nativeexecutableSet(offset: Int, before: String, after: String, first: Int, last: Int): NativeExecutableConnection!
  bindingsgeneratorSet(offset: Int, before: String, after: String, first: Int, last: Int): BindingsGeneratorConnection!
  javascriptlanguagebindingSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionNPMBindingConnection!
  pythonlanguagebindingSet(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionPythonBindingConnection!
  deployappversionSet(offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  piritaFile: String @deprecated(reason: "Please use distribution.piritaDownloadUrl instead.")
  piritaFileSize: Int @deprecated(reason: "Please use distribution.piritaSize instead.")
  pirita256hash: String @deprecated(reason: "Please use distribution.piritaSha256Hash instead.")
  distribution(version: WebcVersion): PackageDistribution!
  filesystem: [PackageVersionFilesystem]!
  isLastVersion: Boolean!
  witFile: String
  isSigned: Boolean!
  moduleInterfaces: [InterfaceVersion!]!
  modules: [PackageVersionModule!]!
  getPiritaContents(volume: String! = "atom", base: String! = ""): [PiritaFilesystemItem!]!
  getWebcContents(volume: String! = "atom", base: String! = "/"): [WEBCFilesystemItem!]!
  nativeExecutables(triple: String, wasmerCompilerVersion: String): [NativeExecutable]
  bindings: [PackageVersionLanguageBinding]!
  npmBindings: PackageVersionNPMBinding
  pythonBindings: PackageVersionPythonBinding
  bindingsSet(before: String, after: String, first: Int, last: Int): PackageVersionBindingConnection
  hasBindings: Boolean!
  hasCommands: Boolean!
  showDeployButton: Boolean!
  isCorrupt: Boolean!
}

interface PackageReleaseInterface {
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  isArchived: Boolean!
  clientName: String
  publishedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  package: Package!
  webc: WebcImage
  webcV3: WebcImage
  tag: String!
}

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

type WebcImage implements Node {
  """The ID of the object"""
  id: ID!

  """The version of the webc image, defaults to v2."""
  version: WebcVersion!

  """"""
  fileSize: BigInt!
  manifest: JSONString!
  volumes: JSONString!
  offsets: JSONString!
  webcSha256: String!
  targzSha256: String
  createdAt: DateTime!
  updatedAt: DateTime!
  webcUrl: String!
}

enum WebcVersion {
  V2
  V3
}

"""
The `BigInt` scalar type represents non-fractional whole numeric values.
`BigInt` is not constrained to 32-bit like the `Int` type and thus is a less
compatible type.
"""
scalar BigInt

type PackageVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersion` and its cursor."""
type PackageVersionEdge {
  """The item at the end of the edge"""
  node: PackageVersion

  """A cursor for use in pagination"""
  cursor: String!
}

enum RegistryPackageVersionBindingsStateChoices {
  """Bindings are not detected"""
  NOT_PRESENT

  """Bindings are being built"""
  GENERATING

  """Bindings generation has failed"""
  ERROR

  """Bindings are built and present"""
  GENERATED_AND_PRESENT
}

enum RegistryPackageVersionNativeExecutablesStateChoices {
  """Native Executables are not detected"""
  NOT_PRESENT

  """Native Executables are being built"""
  GENERATING

  """Native Executables generation has failed"""
  ERROR

  """Native Executables are built and present"""
  GENERATED_AND_PRESENT
}

type PackageWebcConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageWebcEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageWebc` and its cursor."""
type PackageWebcEdge {
  """The item at the end of the edge"""
  node: PackageWebc

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageWebc implements Node & PackageReleaseInterface & PackageInstance {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  package: Package!
  webc: WebcImage
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  isArchived: Boolean!
  clientName: String
  publishedBy: User!
  webcV3: WebcImage
  tag: String!
  webcUrl: String!
}

type Command {
  command: String!
  packageVersion: PackageVersion!
  module: PackageVersionModule
}

type PackageVersionModule {
  name: String!
  source: String!
  abi: String
  publicUrl: String!
  atom: PiritaFilesystemFile!
  rangeHeader: String!
}

type PiritaFilesystemFile {
  name(display: PiritaFilesystemNameDisplay): String!
  size: Int!
  offset: Int!
}

enum PiritaFilesystemNameDisplay {
  RELATIVE
  ABSOLUTE
}

type NativeExecutableConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NativeExecutableEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `NativeExecutable` and its cursor."""
type NativeExecutableEdge {
  """The item at the end of the edge"""
  node: NativeExecutable

  """A cursor for use in pagination"""
  cursor: String!
}

type NativeExecutable implements Node {
  """The ID of the object"""
  id: ID!
  module: String! @deprecated(reason: "Use filename instead")
  filename: String!
  filesize: Int!
  targetTriple: String!
  downloadUrl: String!
}

type BindingsGeneratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BindingsGeneratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `BindingsGenerator` and its cursor."""
type BindingsGeneratorEdge {
  """The item at the end of the edge"""
  node: BindingsGenerator

  """A cursor for use in pagination"""
  cursor: String!
}

type BindingsGenerator implements Node {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  packageVersion: PackageVersion!
  active: Boolean!
  commandName: String!
  registryJavascriptlanguagebindings(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionNPMBindingConnection!
  registryPythonlanguagebindings(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionPythonBindingConnection!
}

type PackageVersionNPMBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionNPMBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersionNPMBinding` and its cursor."""
type PackageVersionNPMBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionNPMBinding

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageVersionNPMBinding implements PackageVersionLanguageBinding & Node {
  """The ID of the object"""
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  npmDefaultInstallPackageName(url: String): String! @deprecated(reason: "Please use packageName instead")
}

interface PackageVersionLanguageBinding {
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
}

enum ProgrammingLanguage {
  PYTHON
  JAVASCRIPT
}

type PackageVersionPythonBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionPythonBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""
A Relay edge containing a `PackageVersionPythonBinding` and its cursor.
"""
type PackageVersionPythonBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionPythonBinding

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageVersionPythonBinding implements PackageVersionLanguageBinding & Node {
  """The ID of the object"""
  id: ID!
  language: ProgrammingLanguage!

  """The URL of the generated artifacts on Wasmer CDN."""
  url: String!

  """When the binding was generated"""
  createdAt: DateTime!

  """Package version used to generate this binding"""
  generator: BindingsGenerator!
  name: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  kind: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")

  """Name of package source"""
  packageName: String!

  """Name of the package to import"""
  importablePackageName: String!

  """Code snippet example to use the package"""
  codeSnippetExample: String!
  module: String! @deprecated(reason: "Do not use this field, since bindings for all modules are generated at once now.")
  pythonDefaultInstallPackageName(url: String): String!
}

type DeployAppVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeployAppVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DeployAppVersion` and its cursor."""
type DeployAppVersionEdge {
  """The item at the end of the edge"""
  node: DeployAppVersion

  """A cursor for use in pagination"""
  cursor: String!
}

type DeployAppVersion implements Node {
  """The ID of the object"""
  id: ID!
  app: DeployApp!
  yamlConfig: String!
  userYamlConfig: String!
  clientName: String!
  signature: String
  description: String
  publishedBy: User!
  disabledAt: DateTime
  disabledBy: User
  disabledReason: String
  disabledPermanently: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  configWebc: String @deprecated(reason: "webc support has been deprecated for apps")
  config: String! @deprecated(reason: "Please use jsonConfig instead")
  jsonConfig: String!
  url: String!
  permalink: String!
  urls: [String]!
  version: String!
  isActive: Boolean!
  manifest: String!
  logs(
    """
    Get logs starting from this timestamp. Takes EPOCH timestamp in seconds.
    """
    startingFrom: Float

    """Get logs starting from this timestamp. Takes ISO timestamp."""
    startingFromISO: DateTime

    """Fetch logs until this timestamp. Takes EPOCH timestamp in seconds."""
    until: Float

    """List of streams to fetch logs from. e.g. stdout, stderr."""
    streams: [LogStream]

    """List of instance ids to fetch logs from."""
    instanceIds: [String]

    """Filter for this request id in logs"""
    requestId: String
    before: String
    after: String
    first: Int
    last: Int
  ): LogConnection!
  usageMetrics(
    variant: MetricType!
    grouping: MetricGrouping

    """Optional time range filter."""
    timeRange: TimeRangeInput
  ): [UsageMetric]!
  sourcePackageVersion: PackageVersion
  sourcePackageRelease: PackageWebc
  sourcePackage: Package!
  aggregateMetrics: AggregateMetrics!
  volumes: [AppVersionVolume]
  gitSource: AutobuildRepository
  favicon: URL
  screenshot(viewportSize: AppScreenshotViewportSize, appearance: AppScreenshotAppearance): URL
}

type DeployApp implements Node & Owner {
  """The ID of the object"""
  id: ID!
  state: String!
  forceHttps: Boolean!
  createdBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  activeVersion: DeployAppVersion
  managed: Boolean!
  willPerishAt: DateTime
  globalName: String!
  globalId: ID!
  viewerCan(action: OwnerAction!): Boolean!
  url: String!
  adminUrl: String!
  permalink: String!
  urls: [String]!
  description: String
  name: String!
  owner: Owner!
  versions(sortBy: DeployAppVersionsSortBy, createdAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  aggregateMetrics: AggregateMetrics!
  aliases(offset: Int, before: String, after: String, first: Int, last: Int): AppAliasConnection!
  domains(sortBy: AppAliasSortBy! = NEWEST, offset: Int, before: String, after: String, first: Int, last: Int): AppAliasConnection!
  secrets(offset: Int, before: String, after: String, first: Int, last: Int): SecretConnection!
  databases(offset: Int, before: String, after: String, first: Int, last: Int): AppDatabaseConnection!
  usageMetrics(
    variant: MetricType!
    grouping: MetricGrouping

    """Optional time range filter."""
    timeRange: TimeRangeInput
  ): [UsageMetric]!
  s3Url: URL
  s3Credentials: S3Credentials
  deleted: Boolean!
  favicon: URL
  screenshot(viewportSize: AppScreenshotViewportSize, appearance: AppScreenshotAppearance): URL
  deployments(before: String, after: String, first: Int, last: Int): DeploymentConnection
  buildConfiguration: BuildConfiguration
  mails: [AppMail]
  kind: Kind
}

enum DeployAppVersionsSortBy {
  NEWEST
  OLDEST
}

type AggregateMetrics {
  cpuTime: String!
  memoryTime: String!
  ingress: String!
  egress: String!
  noRequests: String!
  noFailedRequests: String!
  monthlyCost: String!
}

type AppAliasConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppAliasEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppAlias` and its cursor."""
type AppAliasEdge {
  """The item at the end of the edge"""
  node: AppAlias

  """A cursor for use in pagination"""
  cursor: String!
}

type AppAlias implements Node {
  createdAt: DateTime!
  updatedAt: DateTime!
  lastCheckedAt: DateTime
  firstCheckedAt: DateTime
  name: String!
  app: DeployApp!
  isDefault: Boolean!
  hostname: String!
  text: String!
  kind: DeployAppAliasKindChoices!
  redirectsTo: AppAlias

  """The ID of the object"""
  id: ID!
  url: String!
  state: AppAliasVerificationStates!

  """
  List of records backend expects to move forward with domain verification
  """
  expectedDnsRecords: [AppAliasDNSRecord]

  """HTTP code for redirection"""
  redirectionHttpCode: HTTPRedirectType

  """list of AppAlias objects that redirect to this one."""
  redirectsFrom: [AppAlias]
}

enum DeployAppAliasKindChoices {
  """Deployment"""
  DEPLOYMENT

  """Domain"""
  DOMAIN
}

enum AppAliasVerificationStates {
  UNVERIFIED
  VERIFIED
  APEX_WITHOUT_REDIRECTION
}

type AppAliasDNSRecord {
  recordType: String!
  host: String!
  value: String!
}

enum HTTPRedirectType {
  TEMPORARY_REDIRECT
  TEMPORARY_FOUND
  PERMANENT_REDIRECT
  PERMANENT_MOVED
}

enum AppAliasSortBy {
  NEWEST
  OLDEST
}

type SecretConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SecretEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Secret` and its cursor."""
type SecretEdge {
  """The item at the end of the edge"""
  node: Secret

  """A cursor for use in pagination"""
  cursor: String!
}

type Secret implements Node {
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!

  """The ID of the object"""
  id: ID!
}

type AppDatabaseConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppDatabaseEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppDatabase` and its cursor."""
type AppDatabaseEdge {
  """The item at the end of the edge"""
  node: AppDatabase

  """A cursor for use in pagination"""
  cursor: String!
}

type AppDatabase implements Node {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  name: String!
  username: String!
  app: DeployApp!

  """The ID of the object"""
  id: ID!
  host: String!
  port: String!
  phpmyadminUrl: String
  dbExplorerUrl: String
  password: String
}

type UsageMetric {
  variant: MetricType!
  value: Float!
  unit: MetricUnit!
  timestamp: DateTime!
}

enum MetricType {
  cpu_time
  memory_time
  network_egress
  network_ingress
  no_of_requests
  no_of_failed_requests
  cost
}

"""Units for metrics"""
enum MetricUnit {
  """represents the unit of "seconds"."""
  SEC

  """represents the unit of "milliseconds"."""
  MS

  """represents the unit of "hours"."""
  hours

  """represents the unit of "kilobytes"."""
  KB

  """represents the unit of "bytes"."""
  Bytes

  """represents the unit of "kilobytes per second"."""
  KBS

  """represents the unit of "number of requests"."""
  NO_REQUESTS

  """represents the unit of "cost" in USD."""
  DOLLARS
}

"""Groupings for metrics"""
enum MetricGrouping {
  BY_15_MINUTES
  BY_5_MINUTES
  BY_HOUR
  BY_DAY
  BY_WEEK
}

input TimeRangeInput {
  """Start of the time range."""
  fromDt: DateTime!

  """End of the time range."""
  toDt: DateTime
}

"""
The `URL` scalar type represents a URL as text, represented as UTF-8
character sequences.
"""
scalar URL

type S3Credentials {
  accessKey: String!
  secretKey: String!
  endpoint: String!
}

enum AppScreenshotViewportSize {
  MOBILE
  DESKTOP
}

enum AppScreenshotAppearance {
  LIGHT
  DARK
}

type DeploymentConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeploymentEdge]!
}

"""A Relay edge containing a `Deployment` and its cursor."""
type DeploymentEdge {
  """The item at the end of the edge"""
  node: Deployment

  """A cursor for use in pagination"""
  cursor: String!
}

union Deployment = NakedDeployment | AutobuildRepository

type NakedDeployment implements Node {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  appVersion: DeployAppVersion
}

type AutobuildRepository implements Node {
  """The ID of the object"""
  id: ID!
  appVersion: DeployAppVersion
  buildId: UUID!
  buildCmd: String
  installCmd: String
  user: User!
  name: String!
  namespace: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  appName: String
  repoUrl: String!
  prevCommitHash: String
  commitHash: String!
  commitMessage: String!
  commitAuthorUsername: String!
  status: StatusEnum!
  logUrl: String
  commitUrl: String
  buildConfiguration: BuildConfiguration
}

"""
Leverages the internal Python implementation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

enum StatusEnum {
  SUCCESS
  WORKING
  RUNNING
  FAILURE
  QUEUED
  TIMEOUT
  INTERNAL_ERROR
  CANCELLED
}

type BuildConfiguration implements Node {
  setupDb: Boolean!
  buildCmd: String!
  installCmd: String!
  canDeployWithoutRepo: Boolean!
  completionTimeInSeconds: Int!
  kind: BuildKind!
  repo: String!

  """The ID of the object"""
  id: ID!
  name: String!
}

type BuildKind implements Node {
  setupDb: Boolean!
  buildCmd: String!
  installCmd: String!
  canDeployWithoutRepo: Boolean!
  name: String!

  """The ID of the object"""
  id: ID!
}

type AppMail implements Node {
  emailAddr: String!
  login: String!
  passwordSecret: Secret!

  """The ID of the object"""
  id: ID!
}

union Kind = WordpressAppKind

type WordpressAppKind {
  adminUrl: String!
  liveConfig(forceFetch: Boolean): WordpressLiveConfig
}

type WordpressLiveConfig {
  checkedAt: DateTime!
  wordpressVersion: String!
  phpVersion: String!
  mysqlServer: String!
  plugins: [WordPressPlugin]!
  themes: [WordPressTheme]!
  isLive: Boolean!
  usersCount: Int!
  publishedPostsCount: Int!
  publishedPagesCount: Int!
}

type WordPressPlugin {
  slug: String!
  name: String!
  icon: String
  version: String!
  latestVersion: String
  active: Boolean!
  description: String
}

type WordPressTheme {
  slug: String!
  name: String!
  version: String!
  latestVersion: String
  active: Boolean!
  description: String
}

type LogConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [LogEdge]!
}

"""A Relay edge containing a `Log` and its cursor."""
type LogEdge {
  """The item at the end of the edge"""
  node: Log

  """A cursor for use in pagination"""
  cursor: String!
}

enum LogStream {
  STDOUT
  STDERR
  RUNTIME
}

type AppVersionVolume {
  id: ID!
  name: String!
  s3Url: String!
  mountPaths: [AppVersionVolumeMountPath]!
  size: BigInt
  usedSize: BigInt
}

type AppVersionVolumeMountPath {
  path: String!
  subpath: String
}

type PackageDistribution {
  """
  Download URL of the tar.gz file.
  If the package was published with webc only,this will contain download URL for webc file instead.
  """
  downloadUrl: String!
  expiresInSeconds: Int
  size: Int
  piritaDownloadUrl: String
  piritaExpiresInSeconds: Int
  piritaSize: Int
  piritaSha256Hash: String
  webcDownloadUrl: String
  webcExpiresInSeconds: Int
  webcSize: Int
  webcSha256Hash: String
  webcVersion: WebcVersion
  webcManifest: JSONString
}

type PackageVersionFilesystem {
  wasm: String!
  host: String!
}

type InterfaceVersion implements Node {
  """The ID of the object"""
  id: ID!
  interface: Interface!
  version: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  publishedBy: User!
  packageVersions(offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
}

type Interface implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  displayName: String!
  description: String!
  homepage: String
  icon: String
  createdAt: DateTime!
  updatedAt: DateTime!
  versions(offset: Int, before: String, after: String, first: Int, last: Int): InterfaceVersionConnection!
  lastVersion: InterfaceVersion
}

type InterfaceVersionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [InterfaceVersionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `InterfaceVersion` and its cursor."""
type InterfaceVersionEdge {
  """The item at the end of the edge"""
  node: InterfaceVersion

  """A cursor for use in pagination"""
  cursor: String!
}

union PiritaFilesystemItem = PiritaFilesystemFile | PiritaFilesystemDir

type PiritaFilesystemDir {
  name(display: PiritaFilesystemNameDisplay): String!
}

type WEBCFilesystemItem {
  name: String!
  checksum: String!
  size: Int!
  offset: Int!
}

type PackageVersionBindingConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageVersionBindingEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageVersionBinding` and its cursor."""
type PackageVersionBindingEdge {
  """The item at the end of the edge"""
  node: PackageVersionBinding

  """A cursor for use in pagination"""
  cursor: String!
}

union PackageVersionBinding = PackageVersionNPMBinding | PackageVersionPythonBinding

type WebcImageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [WebcImageEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `WebcImage` and its cursor."""
type WebcImageEdge {
  """The item at the end of the edge"""
  node: WebcImage

  """A cursor for use in pagination"""
  cursor: String!
}

type Collection {
  slug: String!
  displayName: String!
  description: String!
  createdAt: DateTime!
  banner: String!
  packages(before: String, after: String, first: Int, last: Int): PackageConnection!
}

type AppTemplateConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppTemplateEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppTemplate` and its cursor."""
type AppTemplateEdge {
  """The item at the end of the edge"""
  node: AppTemplate

  """A cursor for use in pagination"""
  cursor: String!
}

type AppTemplate implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
  description: String!
  demoUrl: String!
  repoUrl: String!
  branch: String
  category: AppTemplateCategory!
  isPublic: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  readme: String!
  useCases: JSONString!
  repoLicense: String!
  usingPackage: Package
  canDeployWithoutRepo: Boolean!
  completionTimeInSeconds: Int!
  highlighted: Boolean!
  defaultImage: String
  framework: String!
  templateFramework: TemplateFramework
  language: String!
  templateLanguage: TemplateLanguage
}

type AppTemplateCategory implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
  description: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  appTemplates(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection!
}

type TemplateFramework implements Node {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  slug: String!
}

type TemplateLanguage implements Node {
  """The ID of the object"""
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  slug: String!
}

type CategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CategoryEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Category` and its cursor."""
type CategoryEdge {
  """The item at the end of the edge"""
  node: Category

  """A cursor for use in pagination"""
  cursor: String!
}

type Category implements Node {
  """The ID of the object"""
  id: ID!

  """A category is a label that can be attached to a package."""
  name: String!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection
}

type PackageKeywordConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageKeywordEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageKeyword` and its cursor."""
type PackageKeywordEdge {
  """The item at the end of the edge"""
  node: PackageKeyword

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageKeyword implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
}

type PackageCollaboratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageCollaboratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageCollaborator` and its cursor."""
type PackageCollaboratorEdge {
  """The item at the end of the edge"""
  node: PackageCollaborator

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageCollaborator implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  role: RegistryPackageMaintainerRoleChoices!
  package: Package!
  createdAt: DateTime!
  updatedAt: DateTime!
  invite: PackageCollaboratorInvite
}

enum RegistryPackageMaintainerRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type PackageCollaboratorInvite implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  user: User
  inviteEmail: String
  package: Package!
  role: RegistryPackageMaintainerInviteRoleChoices!
  accepted: PackageCollaborator
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
}

enum RegistryPackageMaintainerInviteRoleChoices {
  """Owner"""
  OWNER

  """Admin"""
  ADMIN

  """Editor"""
  EDITOR

  """Viewer"""
  VIEWER
}

type PackageCollaboratorInviteConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageCollaboratorInviteEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageCollaboratorInvite` and its cursor."""
type PackageCollaboratorInviteEdge {
  """The item at the end of the edge"""
  node: PackageCollaboratorInvite

  """A cursor for use in pagination"""
  cursor: String!
}

enum GrapheneRole {
  OWNER
  ADMIN
  EDITOR
  VIEWER
}

type PackageTransferRequest implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  previousOwnerObjectId: Int!
  newOwnerObjectId: Int!
  package: Package!
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
  previousOwner: PackageOwner!
  newOwner: PackageOwner!
}

type PackageSearchConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageSearchEdge]!
  totalCount: Int
}

"""A Relay edge containing a `PackageSearch` and its cursor."""
type PackageSearchEdge {
  """The item at the end of the edge"""
  node: PackageVersion

  """A cursor for use in pagination"""
  cursor: String!
}

type DeployAppConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DeployAppEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DeployApp` and its cursor."""
type DeployAppEdge {
  """The item at the end of the edge"""
  node: DeployApp

  """A cursor for use in pagination"""
  cursor: String!
}

enum DeployAppsSortBy {
  NEWEST
  OLDEST
  MOST_ACTIVE
}

type NamespaceCollaboratorConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NamespaceCollaboratorEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `NamespaceCollaborator` and its cursor."""
type NamespaceCollaboratorEdge {
  """The item at the end of the edge"""
  node: NamespaceCollaborator

  """A cursor for use in pagination"""
  cursor: String!
}

type PackageTransferRequestConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [PackageTransferRequestEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `PackageTransferRequest` and its cursor."""
type PackageTransferRequestEdge {
  """The item at the end of the edge"""
  node: PackageTransferRequest

  """A cursor for use in pagination"""
  cursor: String!
}

type DNSDomainConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DNSDomainEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DNSDomain` and its cursor."""
type DNSDomainEdge {
  """The item at the end of the edge"""
  node: DNSDomain

  """A cursor for use in pagination"""
  cursor: String!
}

type DNSDomain implements Node {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  name: String!

  """This zone will be accessible at /dns/{slug}/."""
  slug: String!
  zoneFile: String!

  """The ID of the object"""
  id: ID!
  records: [DNSRecord]
  owner: Owner!
}

union DNSRecord = ARecord | AAAARecord | CNAMERecord | TXTRecord | MXRecord | NSRecord | CAARecord | DNAMERecord | PTRRecord | SOARecord | SRVRecord | SSHFPRecord

type ARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  address: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

interface DNSRecordInterface {
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
}

type AAAARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  address: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type CNAMERecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """This domain name will alias to this canonical name."""
  cName: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type TXTRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  data: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type MXRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  preference: Int!
  exchange: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type NSRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  nsdname: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type CAARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  flags: Int!
  tag: DnsmanagerCertificationAuthorityAuthorizationRecordTagChoices!
  value: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

enum DnsmanagerCertificationAuthorityAuthorizationRecordTagChoices {
  """issue"""
  ISSUE

  """issue wildcard"""
  ISSUEWILD

  """Incident object description exchange format"""
  IODEF
}

type DNAMERecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """
  This domain name will alias to the entire subtree of that delegation domain.
  """
  dName: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type PTRRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  ptrdname: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type SOARecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """Primary master name server for this zone."""
  mname: String!

  """Email address of the administrator responsible for this zone."""
  rname: String!

  """
  A slave name server will initiate a zone transfer if this serial is incremented.
  """
  serial: BigInt!

  """
  Number of seconds after which secondary name servers should query the master to detect zone changes.
  """
  refresh: BigInt!

  """
  Number of seconds after which secondary name servers should retry to request the serial number from the master if the master does not respond.
  """
  retry: BigInt!

  """
  Number of seconds after which secondary name servers should stop answering request for this zone if the master does not respond.
  """
  expire: BigInt!

  """Time to live for purposes of negative caching."""
  minimum: BigInt!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type SRVRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime

  """The symbolic name of the desired service."""
  service: String!

  """
  The transport protocol of the desired service, usually either TCP or UDP.
  """
  protocol: String!

  """The priority of the target host, lower value means more preferred."""
  priority: Int!

  """
  A relative weight for records with the same priority, higher value means higher chance of getting picked.
  """
  weight: Int!
  port: Int!

  """
  The canonical hostname of the machine providing the service, ending in a dot.
  """
  target: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

type SSHFPRecord implements Node & DNSRecordInterface {
  createdAt: DateTime!
  updatedAt: DateTime!
  deletedAt: DateTime
  algorithm: DnsmanagerSshFingerprintRecordAlgorithmChoices!
  type: DnsmanagerSshFingerprintRecordTypeChoices!
  fingerprint: String!

  """The ID of the object"""
  id: ID!
  name: String!
  ttl: Int!
  dnsClass: String
  text: String!
  domain: DNSDomain!
}

enum DnsmanagerSshFingerprintRecordAlgorithmChoices {
  """RSA"""
  A_1

  """DSA"""
  A_2

  """ECDSA"""
  A_3

  """Ed25519"""
  A_4
}

enum DnsmanagerSshFingerprintRecordTypeChoices {
  """SHA-1"""
  A_1

  """SHA-256"""
  A_2
}

"""Usage summary for a specific owner."""
type OwnerUsageSummary {
  since: DateTime!
  cpuTime: Usage!
  noRequests: Usage!
  ingress: Usage!
  egress: Usage!
  appCount: Usage!
  buildMinutes: Usage!
}

"""Individual usage metrics for a specific app."""
type Usage {
  used: Int!
  max: Int
  charge: MoneyType!
  usedPercent: Float!
  unit: String
  nearingLimits: Boolean!
}

type MoneyType {
  amount: String
  currency: String
}

type APITokenConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [APITokenEdge]!
}

"""A Relay edge containing a `APIToken` and its cursor."""
type APITokenEdge {
  """The item at the end of the edge"""
  node: APIToken

  """A cursor for use in pagination"""
  cursor: String!
}

type APIToken implements Node {
  user: User!
  identifier: String
  createdAt: DateTime!
  revokedAt: DateTime
  lastUsedAt: DateTime
  nonceSet(offset: Int, before: String, after: String, first: Int, last: Int): NonceConnection!

  """The ID of the object"""
  id: ID!
}

type NonceConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [NonceEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `Nonce` and its cursor."""
type NonceEdge {
  """The item at the end of the edge"""
  node: Nonce

  """A cursor for use in pagination"""
  cursor: String!
}

type Nonce implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  callbackUrl: String!
  createdAt: DateTime!
  isValidated: Boolean!
  secret: String!
  token: String!
  expired: Boolean!
  authUrl: String!
}

type UserNotificationConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [UserNotificationEdge]!
  hasPendingNotifications: Boolean!
  pendingNotificationsCount: Int!
}

"""A Relay edge containing a `UserNotification` and its cursor."""
type UserNotificationEdge {
  """The item at the end of the edge"""
  node: UserNotification

  """A cursor for use in pagination"""
  cursor: String!
}

type UserNotification implements Node {
  """The ID of the object"""
  id: ID!
  icon: String
  body: EventBody!
  seenState: UserNotificationSeenState!
  kind: UserNotificationKind
  createdAt: DateTime!
}

enum UserNotificationSeenState {
  UNSEEN
  SEEN
  SEEN_AND_READ
}

union UserNotificationKind = UserNotificationKindPublishedPackageVersion | UserNotificationKindIncomingPackageTransfer | UserNotificationKindIncomingPackageInvite | UserNotificationKindIncomingNamespaceInvite | UserNotificationKindValidateEmail

type UserNotificationKindPublishedPackageVersion {
  packageVersion: PackageVersion!
}

type UserNotificationKindIncomingNamespaceInvite {
  namespaceInvite: NamespaceCollaboratorInvite!
}

type UserNotificationKindValidateEmail {
  user: User!
}

"""

    Enum of ways a user can login. One user can have many login methods
    associated with their account.
    
"""
enum LoginMethod {
  GOOGLE
  GITHUB
  PASSWORD
}

type SocialAuth implements Node {
  """The ID of the object"""
  id: ID!
  user: User!
  provider: String!
  uid: String!
  extraData: JSONString!
  created: DateTime!
  modified: DateTime!
  username: String!
}

type GithubRepository {
  url: String!
  name: String!
  namespace: String!
}

type Webhook implements Node {
  url: String!
  active: Boolean!

  """The ID of the object"""
  id: ID!
}

type Signature {
  id: ID!
  publicKey: PublicKey!
  data: String!
  createdAt: DateTime!
}

type StripeCustomer {
  id: ID!
}

type Billing {
  stripeCustomer: StripeCustomer!
  payments: [PaymentIntent]!
  subscriptions: [WasmerSubscription]!
  paymentMethods: [PaymentMethod]!
}

type PaymentIntent implements Node {
  """The datetime this object was created in stripe."""
  created: DateTime

  """Three-letter ISO currency code"""
  currency: String!

  """
  Status of this PaymentIntent, one of requires_payment_method, requires_confirmation, requires_action, processing, requires_capture, canceled, or succeeded. You can read more about PaymentIntent statuses here.
  """
  status: DjstripePaymentIntentStatusChoices!

  """The ID of the object"""
  id: ID!
  amount: String!
}

enum DjstripePaymentIntentStatusChoices {
  """
  Cancellation invalidates the intent for future confirmation and cannot be undone.
  """
  CANCELED

  """Required actions have been handled."""
  PROCESSING

  """Payment Method require additional action, such as 3D secure."""
  REQUIRES_ACTION

  """Capture the funds on the cards which have been put on holds."""
  REQUIRES_CAPTURE

  """Intent is ready to be confirmed."""
  REQUIRES_CONFIRMATION

  """Intent created and requires a Payment Method to be attached."""
  REQUIRES_PAYMENT_METHOD

  """The funds are in your account."""
  SUCCEEDED
}

type WasmerSubscription implements Node {
  """The datetime this object was created in stripe."""
  created: DateTime

  """A description of this object."""
  description: String

  """
  A date in the future at which the subscription will automatically get canceled.
  """
  cancelAt: DateTime

  """
  If the subscription has been canceled with the ``at_period_end`` flag set to true, ``cancel_at_period_end`` on the subscription will be true. You can use this attribute to determine whether a subscription that has a status of active is scheduled to be canceled at the end of the current period.
  """
  cancelAtPeriodEnd: Boolean!

  """
  If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with ``cancel_at_period_end``, canceled_at will still reflect the date of the initial cancellation request, not the end of the subscription period when the subscription is automatically moved to a canceled state.
  """
  canceledAt: DateTime

  """
  End of the current period for which the subscription has been invoiced. At the end of this period, a new invoice will be created.
  """
  currentPeriodEnd: DateTime!

  """
  Start of the current period for which the subscription has been invoiced.
  """
  currentPeriodStart: DateTime!

  """
  Number of days a customer has to pay invoices generated by this subscription. This value will be `null` for subscriptions where `billing=charge_automatically`.
  """
  daysUntilDue: Int

  """
  If the subscription has ended (either because it was canceled or because the customer was switched to a subscription to a new plan), the date the subscription ended.
  """
  endedAt: DateTime

  """
  Date when the subscription was first created. The date might differ from the created date due to backdating.
  """
  startDate: DateTime

  """The status of this subscription."""
  status: DjstripeSubscriptionStatusChoices!

  """If the subscription has a trial, the end of that trial."""
  trialEnd: DateTime

  """If the subscription has a trial, the beginning of that trial."""
  trialStart: DateTime

  """The ID of the object"""
  id: ID!
}

enum DjstripeSubscriptionStatusChoices {
  """Active"""
  ACTIVE

  """Canceled"""
  CANCELED

  """Incomplete"""
  INCOMPLETE

  """Incomplete Expired"""
  INCOMPLETE_EXPIRED

  """Past due"""
  PAST_DUE

  """Trialing"""
  TRIALING

  """Unpaid"""
  UNPAID
}

union PaymentMethod = CardPaymentMethod

type CardPaymentMethod implements Node {
  """The ID of the object"""
  id: ID!
  brand: CardBrand!
  country: String!
  expMonth: Int!
  expYear: Int!
  funding: CardFunding!
  last4: String!
  isDefault: Boolean!
}

"""
Card brand.

Can be amex, diners, discover, jcb, mastercard, unionpay, visa, or unknown.
"""
enum CardBrand {
  AMEX
  DINERS
  DISCOVER
  JCB
  MASTERCARD
  UNIONPAY
  VISA
  UNKNOWN
}

"""
Card funding type.

Can be credit, debit, prepaid, or unknown.
"""
enum CardFunding {
  CREDIT
  DEBIT
  PREPAID
  UNKNOWN
}

type Payment {
  id: ID
  amount: String
  paidOn: DateTime
}

"""Log entry for deploy app."""
type Log {
  """Timestamp in nanoseconds"""
  timestamp: Float!

  """ISO 8601 string in UTC"""
  datetime: DateTime!

  """Log message"""
  message: String!

  """Log stream"""
  stream: LogStream

  """ID of instance from which the log was generated"""
  instanceId: String!
}

"""This is for backwards compatibility with the old PackageInstance type."""
interface PackageInstance {
  piritaManifest: JSONString
  piritaOffsets: JSONString
  piritaVolumes: JSONString
  isArchived: Boolean!
  clientName: String
  publishedBy: User!
  createdAt: DateTime!
  updatedAt: DateTime!
  package: Package!
  webc: WebcImage
  webcV3: WebcImage
  tag: String!
}

type UserNotificationKindIncomingPackageTransfer {
  packageTransferRequest: PackageTransferRequest!
}

type UserNotificationKindIncomingPackageInvite {
  packageInvite: PackageCollaboratorInvite!
}

input DeploymentV1 {
  name: String!
  workload: WorkloadV1!
}

input WorkloadV1 {
  capability: CapabilityMapV1
  name: String = null
  runner: WorkloadRunnerV1!
}

input AppV1Spec {
  aliases: [String] = []
  workload: WorkloadV2!
}

input WorkloadV2 {
  source: String!
}

input CapabilityCpuV1 {
  maximumThreads: Int
  maximumUsage: Int
}

input FileSystemPermissionsV1 {
  delete: Boolean
  read: Boolean
  write: Boolean
}

input FileSystemVolumeMountV1 {
  path: String!
  permissions: [FileSystemPermissionsV1]
}

input FileSystemVolumeSourceLocalV1 {
  maximumSize: String!
}

input FileSystemVolumeSourceV1 {
  local: FileSystemVolumeSourceLocalV1!
}

input FileSystemVolumeConfigV1 {
  mounts: [FileSystemVolumeMountV1]!
  name: String!
  source: FileSystemVolumeSourceV1!
}

input CapabilityFileSystemV1 {
  volumes: [FileSystemVolumeConfigV1]!
}

input CapabilityPersistentMemoryV1 {
  volumes: [String]
}

input CapabilityMemorySwapV1 {
  maximumSize: String
  memoryId: String
}

input CapabilityNetworkV1 {
  egress: NetworkEgressV1
}

input NetworkEgressV1 {
  enabled: Boolean
}

input CapabilityNetworkDnsV1 {
  enabled: Boolean
  servers: [String]
  allowedHosts: NetworkDnsAllowedHostsV1
}

input NetworkDnsAllowedHostsV1 {
  allowAllHosts: Boolean
  hosts: [String]
  regexPatterns: [String]
  wildcardPatterns: [String]
}

input CapabilityNetworkGatewayV1 {
  domains: [String]
  enforceHttps: Boolean
}

input CapabilityMapV1 {
  memorySwap: CapabilityCpuV1
}

input WebcSourceV1 {
  name: String!
  namespace: String!
  repository: String! = "https://registry.wasmer.wtf"
  tag: String
  authToken: String
}

input WorkloadRunnerV1 {
  webProxy: RunnerWebProxyV1
  wcgi: RunnerWCGIV1
}

"""Run a webassembly file."""
input RunnerWCGIV1 {
  source: WorkloadRunnerWasmSourceV1!
  dialect: String
}

input RunnerWebProxyV1 {
  source: WorkloadRunnerWasmSourceV1!
}

input WorkloadRunnerWasmSourceV1 {
  webc: WebcSourceV1!
}

type Query {
  latestTOS: TermsOfService!
  getAppRegions(supportsVolumes: Boolean, supportsDatabases: Boolean, offset: Int, before: String, after: String, first: Int, last: Int): AppRegionConnection!
  getDeployAppVersion(name: String!, owner: String, version: String): DeployAppVersion
  getAllDomains(namespace: String, offset: Int, before: String, after: String, first: Int, last: Int): DNSDomainConnection!
  getAllDNSRecords(sortBy: DNSRecordsSortBy, updatedAfter: DateTime, before: String, after: String, first: Int, last: Int): DNSRecordConnection!
  getDomain(name: String!): DNSDomain
  getDeployApp(
    name: String!

    """Owner of the app. Defaults to logged in user."""
    owner: String
  ): DeployApp
  getAppByGlobalAlias(alias: String!): DeployApp
  getDeployApps(sortBy: DeployAppsSortBy, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppConnection!
  getAppVersions(sortBy: DeployAppVersionsSortBy, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): DeployAppVersionConnection!
  getTemplateFrameworks(offset: Int, before: String, after: String, first: Int, last: Int): TemplateFrameworkConnection
  getTemplateLanguages(offset: Int, before: String, after: String, first: Int, last: Int): TemplateLanguageConnection
  getAppTemplates(categorySlug: String, frameworkSlug: String, languageSlug: String, sortBy: AppTemplatesSortBy, highlighted: Boolean, offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateConnection
  getAppSecrets(appId: ID!, names: [String], offset: Int, before: String, after: String, first: Int, last: Int): SecretConnection
  getAppSecret(appId: ID!, secretName: String!): Secret
  getAppSecretLog(appId: ID!, offset: Int, before: String, after: String, first: Int, last: Int): SecretLogConnection
  getSecretValue(id: ID!): String
  getAppTemplate(slug: String!): AppTemplate
  getAppTemplateCategories(offset: Int, before: String, after: String, first: Int, last: Int): AppTemplateCategoryConnection
  getBuildKinds(offset: Int, before: String, after: String, first: Int, last: Int): BuildKindConnection!

  """Specify if the database name is valid or not."""
  canDeployDbWithName(
    """Name of the database"""
    name: String!
  ): Boolean!
  wordpressDeploymentDefaults: WordpressDeploymentDefaults!
  viewer: User
  getUser(username: String!): User
  getPasswordResetToken(token: String!): GetPasswordResetToken
  getAuthNonce(name: String!): Nonce

  """Can the logged in user create app templates?"""
  canDeployAppToGithub: Boolean!

  """Check if a repo exists in the logged in user's github account."""
  checkRepoExists(
    """The namespace of the repo to check."""
    namespace: String!

    """The name of the repo to check."""
    name: String!
  ): Boolean!

  """Generate a unique repo name in the logged in user's github account."""
  newRepoName(
    """The github namespace of the repo to create the repo in."""
    namespace: String!

    """The template to use."""
    templateSlug: String!
  ): String!
  packages(offset: Int, before: String, after: String, first: Int, last: Int): PackageConnection
  recentPackageVersions(curated: Boolean, offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  allPackageVersions(sortBy: PackageVersionSortBy, createdAfter: DateTime, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): PackageVersionConnection!
  allPackageReleases(sortBy: PackageVersionSortBy, createdAfter: DateTime, updatedAfter: DateTime, offset: Int, before: String, after: String, first: Int, last: Int): PackageWebcConnection!
  getWebcImage(hash: String!): WebcImage
  getNamespace(name: String!): Namespace
  getPackage(name: String!): Package
  getPackages(names: [String!]!): [Package]!
  getPackageVersion(name: String!, version: String = "latest"): PackageVersion
  getPackageVersions(names: [String!]!): [PackageVersion]
  getPackageVersionByHash(name: String!, hash: String!): PackageVersion
  getInterface(name: String!): Interface
  getInterfaces(names: [String!]!): [Interface]!
  getInterfaceVersion(name: String!, version: String = "latest"): InterfaceVersion
  getContract(name: String!): Interface @deprecated(reason: "Please use getInterface instead")
  getContracts(names: [String!]!): [Interface]! @deprecated(reason: "Please use getInterfaces instead")
  getContractVersion(name: String!, version: String): InterfaceVersion @deprecated(reason: "Please use getInterfaceVersion instead")
  getCommand(name: String!): Command
  getCommands(names: [String!]!): [Command]
  getCollections(before: String, after: String, first: Int, last: Int): CollectionConnection
  getSignedUrlForPackageUpload(name: String, version: String = "latest", filename: String, expiresAfterSeconds: Int = 60): SignedUrl
  getSignedUrl(filename: String, expiresAfterSeconds: Int = 60): SignedUrl
  getPackageHash(name: String, hash: String!): PackageWebc
  getPackageRelease(hash: String): PackageWebc
  getPackageInstanceByVersionOrHash(name: String!, version: String, hash: String): PackageInstance
  categories(offset: Int, before: String, after: String, first: Int, last: Int): CategoryConnection!
  viewerCan(action: OwnerAction!, ownerName: String!): Boolean!
  blogposts(tags: [String!], before: String, after: String, first: Int, last: Int): BlogPostConnection!
  getBlogpost(slug: String, featured: Boolean): BlogPost
  allBlogpostTags(offset: Int, before: String, after: String, first: Int, last: Int): BlogPostTagConnection
  search(query: String!, packages: PackagesFilter, namespaces: NamespacesFilter, users: UsersFilter, apps: AppFilter, blogposts: BlogPostsFilter, appTemplates: AppTemplateFilter, before: String, after: String, first: Int, last: Int): SearchConnection!
  searchAutocomplete(kind: [SearchKind!], query: String!, before: String, after: String, first: Int, last: Int): SearchConnection!
  getGlobalObject(slug: String!): GlobalObject
  node(
    """The ID of the object"""
    id: ID!
  ): Node
  nodes(ids: [ID!]!): [Node]
  info: RegistryInfo
}

type TermsOfService implements Node {
  """The ID of the object"""
  id: ID!
  content: String!
  createdAt: DateTime!
  viewerHasAccepted: Boolean!
}

type AppRegionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppRegionEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppRegion` and its cursor."""
type AppRegionEdge {
  """The item at the end of the edge"""
  node: AppRegion

  """A cursor for use in pagination"""
  cursor: String!
}

type AppRegion implements Node {
  name: String!
  country: String!
  city: String!
  supportsVolumes: Boolean!
  supportsDbs: Boolean!

  """The ID of the object"""
  id: ID!
}

type DNSRecordConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [DNSRecordEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `DNSRecord` and its cursor."""
type DNSRecordEdge {
  """The item at the end of the edge"""
  node: DNSRecord

  """A cursor for use in pagination"""
  cursor: String!
}

enum DNSRecordsSortBy {
  NEWEST
  OLDEST
}

type TemplateFrameworkConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TemplateFrameworkEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `TemplateFramework` and its cursor."""
type TemplateFrameworkEdge {
  """The item at the end of the edge"""
  node: TemplateFramework

  """A cursor for use in pagination"""
  cursor: String!
}

type TemplateLanguageConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [TemplateLanguageEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `TemplateLanguage` and its cursor."""
type TemplateLanguageEdge {
  """The item at the end of the edge"""
  node: TemplateLanguage

  """A cursor for use in pagination"""
  cursor: String!
}

enum AppTemplatesSortBy {
  NEWEST
  OLDEST
  POPULAR
}

type SecretLogConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SecretLogEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `SecretLog` and its cursor."""
type SecretLogEdge {
  """The item at the end of the edge"""
  node: SecretLog

  """A cursor for use in pagination"""
  cursor: String!
}

type SecretLog implements Node {
  createdAt: DateTime!
  action: DeploySecretLogActionChoices!

  """The ID of the object"""
  id: ID!
  secretName: String!
}

enum DeploySecretLogActionChoices {
  """Access"""
  ACCESS

  """Modification"""
  MODIFICATION

  """Create"""
  CREATE

  """DELETE"""
  DELETE
}

type AppTemplateCategoryConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [AppTemplateCategoryEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `AppTemplateCategory` and its cursor."""
type AppTemplateCategoryEdge {
  """The item at the end of the edge"""
  node: AppTemplateCategory

  """A cursor for use in pagination"""
  cursor: String!
}

type BuildKindConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BuildKindEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `BuildKind` and its cursor."""
type BuildKindEdge {
  """The item at the end of the edge"""
  node: BuildKind

  """A cursor for use in pagination"""
  cursor: String!
}

type WordpressDeploymentDefaults {
  siteTitle: String!
  appName: String!
  adminUsername: String!
  adminPassword: String!
  adminEmail: String!
}

type GetPasswordResetToken {
  valid: Boolean!
  user: User
}

enum PackageVersionSortBy {
  NEWEST
  OLDEST
}

type CollectionConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [CollectionEdge]!
}

"""A Relay edge containing a `Collection` and its cursor."""
type CollectionEdge {
  """The item at the end of the edge"""
  node: Collection

  """A cursor for use in pagination"""
  cursor: String!
}

type SignedUrl {
  url: String!
}

type BlogPostConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BlogPostEdge]!
}

"""A Relay edge containing a `BlogPost` and its cursor."""
type BlogPostEdge {
  """The item at the end of the edge"""
  node: BlogPost

  """A cursor for use in pagination"""
  cursor: String!
}

type BlogPost implements Node {
  """The ID of the object"""
  id: ID!
  live: Boolean!

  """The page title as you'd like it to be seen by the public"""
  title: String!

  """
  The name of the page as it will appear in URLs e.g http://domain.com/blog/[my-slug]/
  """
  slug: String!
  owner: User
  body: String!
  publishDate: DateTime
  theme: BlogBlogPostThemeChoices!
  url: String!
  coverImageUrl: String
  opengraphImageUrl: String
  tagline: String!
  relatedArticles: [BlogPost!]
  updatedAt: DateTime!
  tags: [BlogPostTag!]
  editUrl: String
}

enum BlogBlogPostThemeChoices {
  """Green"""
  GREEN

  """Purple"""
  PURPLE

  """Orange"""
  ORANGE

  """Blue"""
  BLUE
}

type BlogPostTag implements Node {
  """The ID of the object"""
  id: ID!
  name: String!
  slug: String!
}

type BlogPostTagConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [BlogPostTagEdge]!

  """Total number of items in the connection."""
  totalCount: Int
}

"""A Relay edge containing a `BlogPostTag` and its cursor."""
type BlogPostTagEdge {
  """The item at the end of the edge"""
  node: BlogPostTag

  """A cursor for use in pagination"""
  cursor: String!
}

type SearchConnection {
  """Pagination data for this connection."""
  pageInfo: PageInfo!

  """Contains the nodes in this connection."""
  edges: [SearchEdge]!
  totalCount: Int
}

"""A Relay edge containing a `Search` and its cursor."""
type SearchEdge {
  """The item at the end of the edge"""
  node: SearchResult

  """A cursor for use in pagination"""
  cursor: String!
}

union SearchResult = PackageVersion | User | Namespace | DeployApp | BlogPost | AppTemplate

input PackagesFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = DESC

  """Filter packages by being curated."""
  curated: Boolean

  """Filter packages by publish date."""
  publishDate: SearchPublishDate

  """Filter packages by having bindings."""
  hasBindings: Boolean = false

  """Filter packages by being standalone."""
  isStandalone: Boolean = false

  """Filter packages by having commands."""
  hasCommands: Boolean = false

  """Filter packages by interface."""
  withInterfaces: [String]

  """Filter packages by deployable status."""
  deployable: Boolean

  """Filter packages by license."""
  license: String

  """Filter packages created after this date."""
  createdAfter: DateTime

  """Filter packages created before this date."""
  createdBefore: DateTime

  """Filter packages with version published after this date."""
  lastPublishedAfter: DateTime

  """Filter packages with version published before this date."""
  lastPublishedBefore: DateTime

  """Filter packages by size."""
  size: CountFilter

  """Filter packages by download count."""
  downloads: CountFilter

  """Filter packages by like count."""
  likes: CountFilter

  """Filter packages by owner."""
  owner: String

  """Filter packages by published by."""
  publishedBy: String

  """Order packages by field."""
  orderBy: PackageOrderBy = PUBLISHED_DATE
}

enum SearchOrderSort {
  ASC
  DESC
}

enum SearchPublishDate {
  LAST_DAY
  LAST_WEEK
  LAST_MONTH
  LAST_YEAR
}

input CountFilter {
  count: Int = 0
  comparison: CountComparison = GREATER_THAN_OR_EQUAL
}

enum CountComparison {
  EQUAL
  GREATER_THAN
  LESS_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN_OR_EQUAL
}

enum PackageOrderBy {
  ALPHABETICALLY
  SIZE
  TOTAL_DOWNLOADS
  PUBLISHED_DATE
  CREATED_DATE
  TOTAL_LIKES
}

input NamespacesFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = DESC

  """Filter namespaces by package count."""
  packageCount: CountFilter

  """Filter namespaces created after this date."""
  createdAfter: DateTime

  """Filter namespaces created before this date."""
  createdBefore: DateTime

  """Filter namespaces by user count."""
  userCount: CountFilter

  """Filter namespaces by collaborator."""
  collaborator: String

  """Order namespaces by field."""
  orderBy: NamespaceOrderBy = CREATED_DATE
}

enum NamespaceOrderBy {
  PACKAGE_COUNT
  COLLABORATOR_COUNT
  APP_COUNT
  CREATED_DATE
}

input UsersFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = DESC

  """Filter users by package count."""
  packageCount: CountFilter

  """Filter users by namespace count."""
  namespaceCount: CountFilter

  """Filter users joined after this date."""
  joinedAfter: DateTime

  """Filter users joined before this date."""
  joinedBefore: DateTime

  """Order users by field."""
  orderBy: UserOrderBy = CREATED_DATE
}

enum UserOrderBy {
  PACKAGE_COUNT
  APP_COUNT
  CREATED_DATE
}

input AppFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = DESC

  """Filter apps by deployed by."""
  deployedBy: String

  """Filter apps last deployed after this date."""
  lastDeployedAfter: DateTime

  """Filter apps last deployed before this date."""
  lastDeployedBefore: DateTime

  """Filter apps by owner."""
  owner: String

  """Order apps by field."""
  orderBy: AppOrderBy = CREATED_DATE

  """Filter apps by client name."""
  clientName: String
}

enum AppOrderBy {
  PUBLISHED_DATE
  CREATED_DATE
}

input BlogPostsFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = DESC

  """Filter blog posts by tag."""
  tags: [String]
}

input AppTemplateFilter {
  count: Int = 1000
  sortBy: SearchOrderSort = DESC

  """Order app templates by field."""
  orderBy: AppTemplateOrderBy = HIGHLIGHTED

  """Filter by app template framework"""
  framework: String

  """Filter by app template language"""
  language: String

  """Filter by one or more of the use-cases for the app template"""
  useCases: [String]
}

enum AppTemplateOrderBy {
  CREATED_DATE
  HIGHLIGHTED
}

enum SearchKind {
  PACKAGE
  NAMESPACE
  USER
}

union GlobalObject = User | Namespace

type RegistryInfo {
  """Base URL for this registry"""
  baseUrl: String!

  """Base URL for the default frontend"""
  defaultFrontend: String!

  """URL to the graphql endpoint"""
  graphqlUrl: String!

  """URL for app domains"""
  appDomain: String!

  """URL to the graphql endpoint"""
  createBlogpostUrl: String

  """Public metadata about packages"""
  packages: PackageInfo!

  """Public metadata about the graphql schema"""
  schema: SchemaInfo!
}

type PackageInfo {
  """Number of package versions published this month"""
  versionsPublishedThisMonth: Int!

  """Number of new packages published this month"""
  newPackagesThisMonth: Int!

  """Number of package downloads this month"""
  packageDownloadsThisMonth: Int!
}

type SchemaInfo {
  """Download link for graphql schema"""
  downloadUrl: String!

  """SHA256 hash of the schema data"""
  SHA256Hash: String!

  """Timestamp when the schema was last updated"""
  lastUpdated: DateTime!
}

type Mutation {
  """Viewer accepts the latest ToS."""
  acceptTOS(input: AcceptTOSInput!): AcceptTOSPayload

  """Delete domain with given ID"""
  deleteAppDomain(input: DeleteAppDomainInput!): DeleteAppDomainPayload

  """Detach autobuild from app."""
  verifyAppDomain(input: VerifyAppDomainInput!): VerifyAppDomainPayload

  """Create or update an app domain on an app with given ID"""
  upsertAppDomain(input: UpsertAppDomainInput!): UpsertAppDomainPayload
  publishDeployApp(input: PublishDeployAppInput!): PublishDeployAppPayload
  deleteApp(input: DeleteAppInput!): DeleteAppPayload

  """Add current user to the waitlist."""
  joinWaitlist(input: JoinWaitlistInput!): JoinWaitlistPayload

  """Add stripe payment to the user"""
  addPayment(input: AddPaymentInput!): AddPaymentPayload

  """
  Mutation to change the active version of a DeployApp to another DeployAppVersion.
  """
  markAppVersionAsActive(input: MarkAppVersionAsActiveInput!): MarkAppVersionAsActivePayload

  """Set a payment method as default for the user."""
  makePaymentDefault(input: SetDefaultPaymentMethodInput!): SetDefaultPaymentMethodPayload

  """
  Try to detach a payment method from customer.
  Fails if trying to detach a default method,
  or if it's the only payment method.
  """
  detachPaymentMethod(input: DetachPaymentMethodInput!): DetachPaymentMethodPayload
  generateDeployConfigToken(input: GenerateDeployConfigTokenInput!): GenerateDeployConfigTokenPayload
  renameApp(input: RenameAppInput!): RenameAppPayload
  renameAppAlias(input: RenameAppAliasInput!): RenameAppAliasPayload

  """Purges all cache for this app version"""
  purgeCacheForAppVersion(input: PurgeCacheForAppVersionInput!): PurgeCacheForAppVersionPayload
  requestAppTransfer(input: RequestAppTransferInput!): RequestAppTransferPayload
  acceptAppTransferRequest(input: AcceptAppTransferRequestInput!): AcceptAppTransferRequestPayload
  removeAppTransferRequest(input: RemoveAppTransferRequestInput!): RemoveAppTransferRequestPayload
  createRepoForAppTemplate(input: CreateRepoForAppTemplateInput!): CreateRepoForAppTemplatePayload
  registerDomain(input: RegisterDomainInput!): RegisterDomainPayload
  upsertDNSRecord(input: UpsertDNSRecordInput!): UpsertDNSRecordPayload
  deleteDNSRecord(input: DeleteDNSRecordInput!): DeleteDNSRecordPayload
  upsertDomainFromZoneFile(input: UpsertDomainFromZoneFileInput!): UpsertDomainFromZoneFilePayload
  deleteDomain(input: DeleteDomainInput!): DeleteDomainPayload

  """Create or update an app secret on an app with given ID"""
  upsertAppSecret(input: UpsertAppSecretInput!): UpsertAppSecretPayload

  """Create or update app secrets on an app with given ID"""
  upsertAppSecrets(input: UpsertAppSecretsInput!): UpsertAppSecretsPayload

  """Delete secret with given ID"""
  deleteAppSecret(input: DeleteAppSecretInput!): DeleteAppSecretPayload

  """Redeploy the active version of an app."""
  redeployActiveVersion(input: RedeployActiveVersionInput!): RedeployActiveVersionPayload

  """Toggle HTTP redirect for the active version of app"""
  toggleForceHttps(input: ToggleForceHTTPSInput!): ToggleForceHTTPSPayload

  """Redeploy the active version of an app."""
  rotateS3SecretsForApp(input: RotateS3SecretsForAppInput!): RotateS3SecretsForAppPayload

  """Delete a database for an app."""
  rotateCredentialsForAppDb(input: RotateCredentialsForAppDBInput!): RotateCredentialsForAppDBPayload

  """Create a new database for an app."""
  createAppDb(input: CreateAppDBInput!): CreateAppDBPayload

  """Delete a database for an app."""
  deleteAppDb(input: DeleteAppDBInput!): DeleteAppDBPayload

  """Get the autobuild config for a given repo"""
  autobuildConfigForRepo(input: AutobuildConfigForRepoInput!): AutobuildConfigForRepoPayload

  """Get the autobuild config for a given zip upload URL"""
  autobuildConfigForZipUpload(input: AutobuildConfigForZipUploadInput!): AutobuildConfigForZipUploadPayload

  """Add a new github app installation"""
  installGithubApp(input: InstallGithubAppInput!): InstallGithubAppPayload

  """Detach autobuild from app."""
  detachAppFromAutobuild(input: DetachAppFromAutobuildInput!): DetachAppFromAutobuildPayload

  """Update autobuild config for an app."""
  updateAutobuildConfigForApp(input: UpdateAutobuildConfigForAppInput!): UpdateAutobuildConfigForAppPayload

  """Deploy a wordpress site."""
  deployWordpress(input: DeployWordpressInput!): DeployWordpressPayload @deprecated(reason: "Use `publishAppFromRepoAutobuild` subscription instead.")

  """Enable app that was previously disabled."""
  enableApp(input: EnableAppInput!): EnableAppPayload

  """Disable app with a reason."""
  disableApp(input: DisableAppInput!): DisableAppPayload

  """Ban app with a reason."""
  banApp(input: BanAppInput!): BanAppPayload

  """Un-ban app with a reason."""
  unbanApp(input: UnbanAppInput!): UnbanAppPayload

  """Claim a perishable app as their own."""
  claimPerishableApp(input: ClaimPerishableAppInput!): ClaimPerishableAppPayload
  deployViaAutobuild(input: DeployViaAutobuildInput!): DeployViaAutobuildPayload
  tokenAuth(input: ObtainJSONWebTokenInput!): ObtainJSONWebTokenPayload
  generateDeployToken(input: GenerateDeployTokenInput!): GenerateDeployTokenPayload
  verifyAccessToken(token: String): Verify
  refreshAccessToken(refreshToken: String): Refresh
  revokeAccessToken(refreshToken: String): Revoke
  registerUser(input: RegisterUserInput!): RegisterUserPayload
  socialAuth(input: SocialAuthJWTInput!): SocialAuthJWTPayload
  validateUserEmail(input: ValidateUserEmailInput!): ValidateUserEmailPayload
  requestPasswordReset(input: RequestPasswordResetInput!): RequestPasswordResetPayload
  requestValidationEmail(input: RequestValidationEmailInput!): RequestValidationEmailPayload
  changeUserPassword(input: ChangeUserPasswordInput!): ChangeUserPasswordPayload
  changeUserUsername(input: ChangeUserUsernameInput!): ChangeUserUsernamePayload
  changeUserEmail(input: ChangeUserEmailInput!): ChangeUserEmailPayload
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayload
  validateUserPassword(input: ValidateUserPasswordInput!): ValidateUserPasswordPayload
  generateApiToken(input: GenerateAPITokenInput!): GenerateAPITokenPayload

  """Request To revoke an API token; these start with 'wap_'."""
  revokeApiToken(input: RevokeAPITokenInput!): RevokeAPITokenPayload
  checkUserExists(input: CheckUserExistsInput!): CheckUserExistsPayload
  readNotification(input: ReadNotificationInput!): ReadNotificationPayload
  seePendingNotifications(input: SeePendingNotificationsInput!): SeePendingNotificationsPayload
  newNonce(input: NewNonceInput!): NewNoncePayload
  validateNonce(input: ValidateNonceInput!): ValidateNoncePayload
  invalidateNonce(input: InvalidateNonceInput!): InvalidateNoncePayload
  mfa2totpGetToken(input: MFATOTPGetTokenInput!): MFATOTPTokenType
  mfa2totpVerify(input: MFATOTPVerifyInput!): MFATOTPVerifyPayload
  mfa2totpAuth(input: MFATOTPAuthInput!): MFAAuthResponse
  mfa2RecoveryGetToken(input: MFAGenerateRecoveryTokenInput!): MFARecoveryCodes
  mfa2RecoveryAuth(input: MFARecoveryAuthInput!): MFAAuthResponse
  mfa2EmailAuth(input: MFAEmailAuthInput!): MFAAuthResponse
  mfa2EmailGetToken(input: MFAGenerateEmailOTPInput!): MFAEmailGenerationResponse
  generateCheckoutUrl(input: GenerateCheckoutUrlInput!): GenerateCheckoutUrlPayload

  """Add webhook to user"""
  addWebhook(input: AddWebhookInput!): AddWebhookPayload

  """Add webhook to user"""
  removeWebhook(input: RemoveWebhookInput!): RemoveWebhookPayload
  publishPublicKey(input: PublishPublicKeyInput!): PublishPublicKeyPayload
  publishPackage(input: PublishPackageInput!): PublishPackagePayload
  pushPackageRelease(input: PushPackageReleaseInput!): PushPackageReleasePayload
  tagPackageRelease(input: TagPackageReleaseInput!): TagPackageReleasePayload
  updatePackage(input: UpdatePackageInput!): UpdatePackagePayload
  likePackage(input: LikePackageInput!): LikePackagePayload
  unlikePackage(input: UnlikePackageInput!): UnlikePackagePayload
  watchPackage(input: WatchPackageInput!): WatchPackagePayload
  unwatchPackage(input: UnwatchPackageInput!): UnwatchPackagePayload
  archivePackage(input: ArchivePackageInput!): ArchivePackagePayload
  renamePackage(input: RenamePackageInput!): RenamePackagePayload
  changePackageVersionArchivedStatus(input: ChangePackageVersionArchivedStatusInput!): ChangePackageVersionArchivedStatusPayload
  createNamespace(input: CreateNamespaceInput!): CreateNamespacePayload
  updateNamespace(input: UpdateNamespaceInput!): UpdateNamespacePayload
  deleteNamespace(input: DeleteNamespaceInput!): DeleteNamespacePayload
  inviteNamespaceCollaborator(input: InviteNamespaceCollaboratorInput!): InviteNamespaceCollaboratorPayload
  acceptNamespaceCollaboratorInvite(input: AcceptNamespaceCollaboratorInviteInput!): AcceptNamespaceCollaboratorInvitePayload
  removeNamespaceCollaboratorInvite(input: RemoveNamespaceCollaboratorInviteInput!): RemoveNamespaceCollaboratorInvitePayload
  removeNamespaceCollaborator(input: RemoveNamespaceCollaboratorInput!): RemoveNamespaceCollaboratorPayload
  updateNamespaceCollaboratorRole(input: UpdateNamespaceCollaboratorRoleInput!): UpdateNamespaceCollaboratorRolePayload
  updateNamespaceCollaboratorInviteRole(input: UpdateNamespaceCollaboratorInviteRoleInput!): UpdateNamespaceCollaboratorInviteRolePayload
  invitePackageCollaborator(input: InvitePackageCollaboratorInput!): InvitePackageCollaboratorPayload
  acceptPackageCollaboratorInvite(input: AcceptPackageCollaboratorInviteInput!): AcceptPackageCollaboratorInvitePayload
  removePackageCollaboratorInvite(input: RemovePackageCollaboratorInviteInput!): RemovePackageCollaboratorInvitePayload
  updatePackageCollaboratorRole(input: UpdatePackageCollaboratorRoleInput!): UpdatePackageCollaboratorRolePayload
  updatePackageCollaboratorInviteRole(input: UpdatePackageCollaboratorInviteRoleInput!): UpdatePackageCollaboratorInviteRolePayload
  removePackageCollaborator(input: RemovePackageCollaboratorInput!): RemovePackageCollaboratorPayload
  requestPackageTransfer(input: RequestPackageTransferInput!): RequestPackageTransferPayload
  acceptPackageTransferRequest(input: AcceptPackageTransferRequestInput!): AcceptPackageTransferRequestPayload
  removePackageTransferRequest(input: RemovePackageTransferRequestInput!): RemovePackageTransferRequestPayload
  generateBindingsForAllPackages(input: GenerateBindingsForAllPackagesInput!): GenerateBindingsForAllPackagesPayload
  makePackagePublic(input: MakePackagePublicInput!): MakePackagePublicPayload
  generateUploadUrl(input: GenerateUploadUrlInput!): GenerateUploadUrlPayload
}

"""Viewer accepts the latest ToS."""
type AcceptTOSPayload {
  TOS: TermsOfService!
  clientMutationId: String
}

input AcceptTOSInput {
  clientMutationId: String
}

"""Delete domain with given ID"""
type DeleteAppDomainPayload {
  success: Boolean!

  """ID of the deleted domain."""
  id: ID!
  clientMutationId: String
}

input DeleteAppDomainInput {
  """ID of the domain to delete."""
  id: ID!
  clientMutationId: String
}

"""Detach autobuild from app."""
type VerifyAppDomainPayload {
  verified: Boolean!
  clientMutationId: String
}

input VerifyAppDomainInput {
  """The ID of the domain to verify"""
  domainId: ID!

  """Specify how to verify the domain"""
  kind: VerificationKind = QUICK
  clientMutationId: String
}

enum VerificationKind {
  QUICK
  DEEP
}

"""Create or update an app domain on an app with given ID"""
type UpsertAppDomainPayload {
  """List of domains generated by the mutation"""
  domains: [AppAlias]
  success: Boolean!
  clientMutationId: String
}

input UpsertAppDomainInput {
  """ID of the app onto which to add secrets."""
  appId: ID!

  """ID of the domain to upsert."""
  id: ID

  """Name of the secret."""
  name: String!

  """Redirection rules for this domain"""
  redirection: AppDomainRedirectRules = null

  """Wait for the domain to become available before returning."""
  wait: Boolean = true
  clientMutationId: String
}

input AppDomainRedirectRules {
  """Domain to redirect to."""
  to: String!

  """Type of redirection; sets the http code appropriately."""
  httpCode: HTTPRedirectType!
}

type PublishDeployAppPayload {
  deployAppVersion: DeployAppVersion!
  clientMutationId: String
}

input PublishDeployAppInput {
  """The configuration of the app."""
  config: Configuration!

  """The name of the app."""
  name: ID

  """The owner of the app."""
  owner: ID

  """The description of the app."""
  description: String

  """If true, the new version will be set as the default version."""
  makeDefault: Boolean = true

  """
  If true, Publishing will fail if the source package does not have a valid webc.
  """
  strict: Boolean = false

  """
  If true, the mutation will wait for all deployment jobs to finish before returning.
  """
  waitForJobs: Boolean = false

  """If true, the mutation will trigger a screenshot generation job."""
  generateScreenshot: Boolean = true

  """
  Wait for smaller of n seconds or till the published app version is live.
  """
  waitTillLive: Int = null
  clientMutationId: String
}

input Configuration {
  deployment: AppConfigV1
  yamlConfig: String
}

input AppConfigV1 {
  kind: String = "wasmer.io/App.v0"
  appId: ID
  name: String!
  description: String
  package: String!
}

type DeleteAppPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteAppInput {
  """App ID to delete."""
  id: ID!
  clientMutationId: String
}

"""Add current user to the waitlist."""
type JoinWaitlistPayload {
  waitlistMember: WaitlistMember!
  clientMutationId: String
}

input JoinWaitlistInput {
  name: String!
  clientMutationId: String
}

"""Add stripe payment to the user"""
type AddPaymentPayload {
  customerSecret: String!
  clientMutationId: String
}

input AddPaymentInput {
  clientMutationId: String
}

"""
Mutation to change the active version of a DeployApp to another DeployAppVersion.
"""
type MarkAppVersionAsActivePayload {
  app: DeployApp!
  clientMutationId: String
}

input MarkAppVersionAsActiveInput {
  """The ID of the DeployAppVersion to set as the new active version."""
  appVersion: ID!
  clientMutationId: String
}

"""Set a payment method as default for the user."""
type SetDefaultPaymentMethodPayload {
  success: Boolean!
  billing: Billing!
  clientMutationId: String
}

input SetDefaultPaymentMethodInput {
  paymentMethod: ID!
  clientMutationId: String
}

"""
Try to detach a payment method from customer.
Fails if trying to detach a default method,
or if it's the only payment method.
"""
type DetachPaymentMethodPayload {
  success: Boolean!
  billing: Billing!
  clientMutationId: String
}

input DetachPaymentMethodInput {
  paymentMethod: ID!
  clientMutationId: String
}

type GenerateDeployConfigTokenPayload {
  token: String!
  config: String!
  clientMutationId: String
}

input GenerateDeployConfigTokenInput {
  config: String!
  clientMutationId: String
}

type RenameAppPayload {
  success: Boolean!
  app: DeployApp!
  clientMutationId: String
}

input RenameAppInput {
  """App ID to delete."""
  id: ID!

  """New name for the app."""
  name: String!
  clientMutationId: String
}

type RenameAppAliasPayload {
  success: Boolean!
  alias: AppAlias!
  clientMutationId: String
}

input RenameAppAliasInput {
  """App alias ID to delete."""
  id: ID!

  """New name for the alias."""
  name: String!
  clientMutationId: String
}

"""Purges all cache for this app version"""
type PurgeCacheForAppVersionPayload {
  appVersion: DeployAppVersion!
  success: Boolean!
  clientMutationId: String
}

input PurgeCacheForAppVersionInput {
  """ID of the app version to purge cache for."""
  id: ID!
  clientMutationId: String
}

type RequestAppTransferPayload {
  appTransferRequest: AppTransferRequest
  wasInstantlyTransferred: Boolean!
  clientMutationId: String
}

type AppTransferRequest implements Node {
  """The ID of the object"""
  id: ID!
  requestedBy: User!
  previousOwnerObjectId: Int!
  newOwnerObjectId: Int!
  app: DeployApp!
  approvedBy: User
  declinedBy: User
  createdAt: DateTime!
  expiresAt: DateTime!
  closedAt: DateTime
  previousOwner: Owner!
  newOwner: Owner!
}

input RequestAppTransferInput {
  appId: ID!
  newOwnerId: ID!
  clientMutationId: String
}

type AcceptAppTransferRequestPayload {
  app: DeployApp!
  appTransferRequest: AppTransferRequest!
  clientMutationId: String
}

input AcceptAppTransferRequestInput {
  appTransferRequestId: ID!
  clientMutationId: String
}

type RemoveAppTransferRequestPayload {
  app: DeployApp!
  clientMutationId: String
}

input RemoveAppTransferRequestInput {
  appTransferRequestId: ID!
  clientMutationId: String
}

type CreateRepoForAppTemplatePayload {
  success: Boolean!
  repoId: ID!
  clientMutationId: String
}

input CreateRepoForAppTemplateInput {
  templateId: ID!
  name: String!
  namespace: String!
  private: Boolean = false
  domains: [String] = null
  clientMutationId: String
}

type RegisterDomainPayload {
  success: Boolean!
  domain: DNSDomain
  clientMutationId: String
}

input RegisterDomainInput {
  name: String!
  namespace: String
  importRecords: Boolean = true
  clientMutationId: String
}

type UpsertDNSRecordPayload {
  success: Boolean!
  record: DNSRecord!
  clientMutationId: String
}

input UpsertDNSRecordInput {
  kind: RecordKind!
  domainId: String!
  name: String!
  value: String!
  ttl: Int
  recordId: String
  mx: DNSMXExtraInput
  clientMutationId: String
}

enum RecordKind {
  A
  AAAA
  CNAME
  MX
  NS
  TXT
  DNAME
  PTR
  SOA
  SRV
  CAA
  SSHFP
}

input DNSMXExtraInput {
  preference: Int!
}

type DeleteDNSRecordPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteDNSRecordInput {
  recordId: ID!
  clientMutationId: String
}

type UpsertDomainFromZoneFilePayload {
  success: Boolean!
  domain: DNSDomain!
  clientMutationId: String
}

input UpsertDomainFromZoneFileInput {
  zoneFile: String!
  deleteMissingRecords: Boolean
  clientMutationId: String
}

type DeleteDomainPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteDomainInput {
  domainId: ID!
  clientMutationId: String
}

"""Create or update an app secret on an app with given ID"""
type UpsertAppSecretPayload {
  secret: Secret!
  success: Boolean!
  clientMutationId: String
}

input UpsertAppSecretInput {
  """ID of the app onto which to add secrets."""
  appId: ID!

  """Name of the secret."""
  name: String!

  """Value of the secret."""
  value: String!
  clientMutationId: String
}

"""Create or update app secrets on an app with given ID"""
type UpsertAppSecretsPayload {
  success: Boolean!
  secrets: [Secret]!
  clientMutationId: String
}

input UpsertAppSecretsInput {
  """ID of the app onto which to add secrets."""
  appId: ID!
  secrets: [SecretInput]
  clientMutationId: String
}

input SecretInput {
  """Name of the secret."""
  name: String!

  """Value of the secret."""
  value: String!
}

"""Delete secret with given ID"""
type DeleteAppSecretPayload {
  success: Boolean!

  """ID of the deleted secret."""
  id: ID!
  clientMutationId: String
}

input DeleteAppSecretInput {
  """ID of the secret to delete."""
  id: ID!
  clientMutationId: String
}

"""Redeploy the active version of an app."""
type RedeployActiveVersionPayload {
  app: DeployApp!
  clientMutationId: String
}

input RedeployActiveVersionInput {
  """ID of the app to redeploy."""
  id: ID!
  clientMutationId: String
}

"""Toggle HTTP redirect for the active version of app"""
type ToggleForceHTTPSPayload {
  app: DeployApp!
  clientMutationId: String
}

input ToggleForceHTTPSInput {
  """App ID"""
  id: ID!
  clientMutationId: String
}

"""Redeploy the active version of an app."""
type RotateS3SecretsForAppPayload {
  app: DeployApp!
  clientMutationId: String
}

input RotateS3SecretsForAppInput {
  """ID of the app."""
  id: ID!
  clientMutationId: String
}

"""Delete a database for an app."""
type RotateCredentialsForAppDBPayload {
  database: AppDatabase!
  password: String!
  clientMutationId: String
}

input RotateCredentialsForAppDBInput {
  """App Database ID"""
  id: ID!
  clientMutationId: String
}

"""Create a new database for an app."""
type CreateAppDBPayload {
  database: AppDatabase!
  password: String!
  clientMutationId: String
}

input CreateAppDBInput {
  """App ID"""
  id: ID!

  """Database name"""
  name: String
  clientMutationId: String
}

"""Delete a database for an app."""
type DeleteAppDBPayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteAppDBInput {
  """App Database ID"""
  id: ID!
  clientMutationId: String
}

"""Get the autobuild config for a given repo"""
type AutobuildConfigForRepoPayload {
  """The build configuration"""
  buildConfig: BuildConfig

  """List of apps deployed with this repo."""
  deployedApps: [DeployApp]
  clientMutationId: String
}

"""The Build Configuration for a given repo"""
type BuildConfig {
  buildCmd: String!
  installCmd: String!
  setupDb: Boolean!
  presetName: String!
  appName: String!
  canDeployWithoutRepo: Boolean!
  completionTimeInSeconds: Int!
  branch: String
}

input AutobuildConfigForRepoInput {
  """The repo URL"""
  repoUrl: String!
  clientMutationId: String
}

"""Get the autobuild config for a given zip upload URL"""
type AutobuildConfigForZipUploadPayload {
  """The build configuration"""
  buildConfig: BuildConfig

  """List of apps deployed with this repo."""
  deployedApps: [DeployApp]
  clientMutationId: String
}

input AutobuildConfigForZipUploadInput {
  """The Zip upload URL"""
  uploadUrl: String!
  clientMutationId: String
}

"""Add a new github app installation"""
type InstallGithubAppPayload {
  success: Boolean!
  user: User!
  clientMutationId: String
}

input InstallGithubAppInput {
  """Github app Installation ID"""
  installationId: ID!
  clientMutationId: String
}

"""Detach autobuild from app."""
type DetachAppFromAutobuildPayload {
  app: DeployApp!
  clientMutationId: String
}

input DetachAppFromAutobuildInput {
  """The ID of the App"""
  appId: ID!
  clientMutationId: String
}

"""Update autobuild config for an app."""
type UpdateAutobuildConfigForAppPayload {
  app: DeployApp!
  clientMutationId: String
}

input UpdateAutobuildConfigForAppInput {
  """The ID of the App"""
  appId: ID!

  """Build command for the app"""
  buildCmd: String

  """Install command for the app"""
  installCmd: String
  clientMutationId: String
}

"""Deploy a wordpress site."""
type DeployWordpressPayload {
  appVersion: DeployAppVersion!
  clientMutationId: String
}

input DeployWordpressInput {
  """Wordpress site name."""
  siteName: String!

  """Name of app to create."""
  appName: String!

  """Owner of this app."""
  appOwner: String!

  """Region for this app."""
  region: String!

  """Username of admin for the wordpress site."""
  adminUsername: String!

  """Admin password for the wordpress site."""
  adminPassword: String!

  """Email of admin of the wordpress site."""
  adminEmail: String!

  """Email of admin of the wordpress site."""
  language: String

  """If set, the app is managed by wasmer."""
  managed: Boolean
  clientMutationId: String
}

"""Enable app that was previously disabled."""
type EnableAppPayload {
  app: DeployApp!
  clientMutationId: String
}

input EnableAppInput {
  """ID of app to disable"""
  appId: ID!
  clientMutationId: String
}

"""Disable app with a reason."""
type DisableAppPayload {
  app: DeployApp!
  clientMutationId: String
}

input DisableAppInput {
  """ID of app to disable"""
  appId: ID!

  """Disable with this reason"""
  reason: String!
  clientMutationId: String
}

"""Ban app with a reason."""
type BanAppPayload {
  app: DeployApp!
  clientMutationId: String
}

input BanAppInput {
  """ID of app to disable"""
  appId: ID!

  """Disable with this reason"""
  reason: String!

  """Blackhole the app (no network access)"""
  blackholed: Boolean = false
  clientMutationId: String
}

"""Un-ban app with a reason."""
type UnbanAppPayload {
  app: DeployApp!
  clientMutationId: String
}

input UnbanAppInput {
  """ID of app to disable"""
  appId: ID!
  clientMutationId: String
}

"""Claim a perishable app as their own."""
type ClaimPerishableAppPayload {
  app: DeployApp!
  clientMutationId: String
}

input ClaimPerishableAppInput {
  """ID of app to disable"""
  appId: ID!
  clientMutationId: String
}

type DeployViaAutobuildPayload {
  success: Boolean!
  buildId: UUID!
  clientMutationId: String
}

input DeployViaAutobuildInput {
  repoUrl: String
  uploadUrl: String
  appName: String!
  owner: String
  buildCmd: String
  installCmd: String
  enableDatabase: Boolean
  secrets: [SecretInput]
  extraData: AutobuildDeploymentExtraData
  params: AutobuildDeploymentExtraData

  """If set, the app is managed by wasmer."""
  managed: Boolean = false
  kind: String

  """If set, the screenshot is waited for."""
  waitForScreenshotGeneration: Boolean = false

  """Region to deploy the app"""
  region: String

  """
  Branch to deploy from. If no branch is specified, the default branch is used.
  """
  branch: String

  """If set, allows deploying a new version of an existing app."""
  allowExistingApp: Boolean = false

  """Additional jobs to run in the deployment."""
  jobs: [JobDefinitionInput]

  """Domains for this app"""
  domains: [String]
  clientMutationId: String
}

input AutobuildDeploymentExtraData {
  wordpress: WordpressDeploymentExtraData = null
}

input WordpressDeploymentExtraData {
  siteName: String!
  adminUsername: String!
  adminPassword: String!
  adminEmail: String!
  language: String = "en_US"
}

input JobDefinitionInput {
  name: String
  package: String

  """Command to run the job"""
  command: String!
  cliArgs: [String]
  env: [String]

  """Humanfriendly timeout definition. e.g. 10m, 1h"""
  timeout: String = "10m"
}

type ObtainJSONWebTokenPayload {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  username: CaseInsensitiveString!
  clientMutationId: String
  token: String!
  refreshToken: String!
}

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""
The `CaseInsensitiveString` scalar type represents textual data, represented as UTF-8
character sequences. The String type is most often used by GraphQL to
represent free-form human-readable text.
"""
scalar CaseInsensitiveString

input ObtainJSONWebTokenInput {
  clientMutationId: String
  username: String!
  password: String!
}

type GenerateDeployTokenPayload {
  token: String!
  deployConfigVersion: DeployAppVersion!
  clientMutationId: String
}

input GenerateDeployTokenInput {
  deployConfigVersionId: String!
  clientMutationId: String
}

type Verify {
  payload: GenericScalar!
}

type Refresh {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  refreshToken: String!
}

type Revoke {
  revoked: Int!
}

type RegisterUserPayload {
  token: String
  clientMutationId: String
}

input RegisterUserInput {
  fullName: String
  email: String!
  username: CaseInsensitiveString!
  password: String!
  acceptedTos: Boolean
  intent: String
  clientMutationId: String
}

type SocialAuthJWTPayload {
  social: SocialAuth
  token: String
  clientMutationId: String
}

input SocialAuthJWTInput {
  provider: String!
  accessToken: String!
  register: Boolean = false
  registerIntent: String
  clientMutationId: String
}

type ValidateUserEmailPayload {
  user: User
  clientMutationId: String
}

input ValidateUserEmailInput {
  """The user id"""
  userId: ID
  challenge: String!
  clientMutationId: String
}

type RequestPasswordResetPayload {
  email: String!
  errors: [ErrorType]
  clientMutationId: String
}

type ErrorType {
  field: String!
  messages: [String!]!
}

input RequestPasswordResetInput {
  email: String!
  clientMutationId: String
}

type RequestValidationEmailPayload {
  user: User
  success: Boolean!
  clientMutationId: String
}

input RequestValidationEmailInput {
  """The user id"""
  userId: ID
  clientMutationId: String
}

type ChangeUserPasswordPayload {
  token: String
  clientMutationId: String
}

input ChangeUserPasswordInput {
  """
  The token associated to change the password. If not existing it will use the request user by default
  """
  token: String
  oldPassword: String
  password: String!
  clientMutationId: String
}

type ChangeUserUsernamePayload {
  user: User
  token: String
  clientMutationId: String
}

input ChangeUserUsernameInput {
  """The new user username"""
  username: CaseInsensitiveString!
  clientMutationId: String
}

type ChangeUserEmailPayload {
  user: User!
  clientMutationId: String
}

input ChangeUserEmailInput {
  newEmail: String!
  clientMutationId: String
}

type UpdateUserInfoPayload {
  user: User
  clientMutationId: String
}

input UpdateUserInfoInput {
  """The user id"""
  userId: ID

  """The user full name"""
  fullName: String

  """The user bio"""
  bio: String

  """The user avatar"""
  avatar: String

  """
  The user Twitter (it can be the url, or the handle with or without the @)
  """
  twitter: String

  """
  The user Github (it can be the url, or the handle with or without the @)
  """
  github: String

  """The user website (it must be a valid url)"""
  websiteUrl: String

  """The user location"""
  location: String
  clientMutationId: String
}

type ValidateUserPasswordPayload {
  success: Boolean
  clientMutationId: String
}

input ValidateUserPasswordInput {
  password: String!
  clientMutationId: String
}

type GenerateAPITokenPayload {
  token: APIToken
  tokenRaw: String
  user: User
  clientMutationId: String
}

input GenerateAPITokenInput {
  identifier: String
  clientMutationId: String
}

"""Request To revoke an API token; these start with 'wap_'."""
type RevokeAPITokenPayload {
  token: APIToken
  success: Boolean
  clientMutationId: String
}

input RevokeAPITokenInput {
  """The API token ID"""
  tokenId: String

  """The raw API token"""
  token: String
  clientMutationId: String
}

type CheckUserExistsPayload {
  exists: Boolean!

  """The user is only returned if the user input was the username"""
  user: User
  clientMutationId: String
}

input CheckUserExistsInput {
  """The user"""
  user: String!
  clientMutationId: String
}

type ReadNotificationPayload {
  notification: UserNotification
  clientMutationId: String
}

input ReadNotificationInput {
  notificationId: ID!
  clientMutationId: String
}

type SeePendingNotificationsPayload {
  success: Boolean
  clientMutationId: String
}

input SeePendingNotificationsInput {
  clientMutationId: String
}

type NewNoncePayload {
  nonce: Nonce!
  clientMutationId: String
}

input NewNonceInput {
  name: String!
  callbackUrl: String!
  clientMutationId: String
}

type ValidateNoncePayload {
  nonce: Nonce!
  clientMutationId: String
}

input ValidateNonceInput {
  id: ID!
  secret: String!
  clientMutationId: String
}

type InvalidateNoncePayload {
  nonce: Nonce!
  clientMutationId: String
}

input InvalidateNonceInput {
  id: ID!
  secret: String!
  clientMutationId: String
}

type MFATOTPTokenType {
  qr: String
  secretKey: String
}

input MFATOTPGetTokenInput {
  clientMutationId: String
}

type MFATOTPVerifyPayload {
  status: MFATOTPVerifyStatus
  clientMutationId: String
}

enum MFATOTPVerifyStatus {
  SUCCESS
  RECOVERY
}

input MFATOTPVerifyInput {
  answer: String!
  secretKey: String!
  clientMutationId: String
}

"""Response object for MFAAuth mutation."""
type MFAAuthResponse {
  success: Boolean!
  token: String
  refreshToken: String
  username: String
  refreshTokenExpiresIn: Int
}

input MFATOTPAuthInput {
  username: String!
  otp: String!
  clientMutationId: String
}

type MFARecoveryCodes {
  codes: [String]!
}

input MFAGenerateRecoveryTokenInput {
  clientMutationId: String
}

input MFARecoveryAuthInput {
  username: String!
  otp: String!
  clientMutationId: String
}

input MFAEmailAuthInput {
  username: String!
  otp: String!
  clientMutationId: String
}

type MFAEmailGenerationResponse {
  success: Boolean!
}

input MFAGenerateEmailOTPInput {
  clientMutationId: String
}

type GenerateCheckoutUrlPayload {
  checkout: StripeCheckout!
  clientMutationId: String
}

type StripeCheckout {
  url: String!
  expiresAt: DateTime!
}

input GenerateCheckoutUrlInput {
  """URL to redirect to on success."""
  successUrl: String!

  """URL to redirect to on cancellation."""
  cancelUrl: String!

  """ID of price (product) to charge the user."""
  priceId: ID!

  """Locale of the customer."""
  locale: String!

  """ID of owner to create subscription on. Defaults to current user."""
  forOwnerId: ID
  clientMutationId: String
}

"""Add webhook to user"""
type AddWebhookPayload {
  webhook: Webhook!
  clientMutationId: String
}

input AddWebhookInput {
  url: String!
  clientMutationId: String
}

"""Add webhook to user"""
type RemoveWebhookPayload {
  success: Boolean!
  clientMutationId: String
}

input RemoveWebhookInput {
  id: ID!
  clientMutationId: String
}

type PublishPublicKeyPayload {
  success: Boolean!
  publicKey: PublicKey!
  clientMutationId: String
}

input PublishPublicKeyInput {
  keyId: String!
  key: String!
  verifyingSignatureId: String
  clientMutationId: String
}

type PublishPackagePayload {
  success: Boolean!
  packageVersion: PackageVersion
  packageWebc: PackageWebc
  clientMutationId: String
}

input PublishPackageInput {
  manifest: String!
  name: String
  namespace: String
  version: String
  description: String
  license: String
  licenseFile: String
  readme: String
  repository: String
  homepage: String
  file: String
  signedUrl: String
  signature: InputSignature

  """The package icon"""
  icon: String

  """Whether the package is private"""
  private: Boolean = false

  """The upload format of the package"""
  uploadFormat: UploadFormat = targz

  """Whether to wait for webc generation to finish"""
  wait: Boolean = false
  clientMutationId: String
}

input InputSignature {
  publicKeyKeyId: String!
  data: String!
}

enum UploadFormat {
  targz
  webcv2
  webcv3
}

type PushPackageReleasePayload {
  success: Boolean!
  packageWebc: PackageWebc
  clientMutationId: String
}

input PushPackageReleaseInput {
  namespace: String!
  signedUrl: String!
  name: String

  """Whether the package is private"""
  private: Boolean = false
  clientMutationId: String
}

type TagPackageReleasePayload {
  success: Boolean!
  packageVersion: PackageVersion
  clientMutationId: String
}

input TagPackageReleaseInput {
  packageReleaseId: ID!
  version: String!
  name: String
  manifest: String
  namespace: String
  description: String
  license: String
  licenseFile: String
  readme: String
  repository: String
  homepage: String
  signature: InputSignature

  """The package icon"""
  icon: String
  private: Boolean = false
  clientMutationId: String
}

type UpdatePackagePayload {
  package: Package!
  clientMutationId: String
}

input UpdatePackageInput {
  packageId: ID!

  """The package icon"""
  icon: String
  clientMutationId: String
}

type LikePackagePayload {
  package: Package!
  clientMutationId: String
}

input LikePackageInput {
  packageId: ID!
  clientMutationId: String
}

type UnlikePackagePayload {
  package: Package!
  clientMutationId: String
}

input UnlikePackageInput {
  packageId: ID!
  clientMutationId: String
}

type WatchPackagePayload {
  package: Package!
  clientMutationId: String
}

input WatchPackageInput {
  packageId: ID!
  clientMutationId: String
}

type UnwatchPackagePayload {
  package: Package!
  clientMutationId: String
}

input UnwatchPackageInput {
  packageId: ID!
  clientMutationId: String
}

type ArchivePackagePayload {
  package: Package!
  clientMutationId: String
}

input ArchivePackageInput {
  packageId: ID!
  clientMutationId: String
}

type RenamePackagePayload {
  package: Package!
  clientMutationId: String
}

input RenamePackageInput {
  packageId: ID!
  newName: String!
  clientMutationId: String
}

type ChangePackageVersionArchivedStatusPayload {
  packageVersion: PackageVersion!
  clientMutationId: String
}

input ChangePackageVersionArchivedStatusInput {
  packageVersionId: ID!
  isArchived: Boolean
  clientMutationId: String
}

type CreateNamespacePayload {
  namespace: Namespace!
  user: User!
  clientMutationId: String
}

input CreateNamespaceInput {
  name: String!

  """The namespace display name"""
  displayName: String

  """The namespace description"""
  description: String

  """The namespace avatar"""
  avatar: String
  clientMutationId: String
}

type UpdateNamespacePayload {
  namespace: Namespace!
  clientMutationId: String
}

input UpdateNamespaceInput {
  namespaceId: ID!

  """The namespace slug name"""
  name: String

  """The namespace display name"""
  displayName: String

  """The namespace description"""
  description: String

  """The namespace avatar"""
  avatar: String

  """
  The user Twitter (it can be the url, or the handle with or without the @)
  """
  twitter: String

  """
  The user Github (it can be the url, or the handle with or without the @)
  """
  github: String

  """The user website (it must be a valid url)"""
  websiteUrl: String
  clientMutationId: String
}

type DeleteNamespacePayload {
  success: Boolean!
  clientMutationId: String
}

input DeleteNamespaceInput {
  namespaceId: ID!
  clientMutationId: String
}

type InviteNamespaceCollaboratorPayload {
  invite: NamespaceCollaboratorInvite!
  namespace: Namespace!
  clientMutationId: String
}

input InviteNamespaceCollaboratorInput {
  namespaceId: ID!
  role: GrapheneRole!
  username: String
  email: String
  clientMutationId: String
}

type AcceptNamespaceCollaboratorInvitePayload {
  namespaceCollaboratorInvite: NamespaceCollaboratorInvite!
  clientMutationId: String
}

input AcceptNamespaceCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemoveNamespaceCollaboratorInvitePayload {
  namespace: Namespace!
  clientMutationId: String
}

input RemoveNamespaceCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemoveNamespaceCollaboratorPayload {
  namespace: Namespace!
  clientMutationId: String
}

input RemoveNamespaceCollaboratorInput {
  namespaceCollaboratorId: ID!
  clientMutationId: String
}

type UpdateNamespaceCollaboratorRolePayload {
  collaborator: NamespaceCollaborator!
  clientMutationId: String
}

input UpdateNamespaceCollaboratorRoleInput {
  namespaceCollaboratorId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type UpdateNamespaceCollaboratorInviteRolePayload {
  collaboratorInvite: NamespaceCollaboratorInvite!
  clientMutationId: String
}

input UpdateNamespaceCollaboratorInviteRoleInput {
  namespaceCollaboratorInviteId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type InvitePackageCollaboratorPayload {
  invite: PackageCollaboratorInvite!
  package: Package!
  clientMutationId: String
}

input InvitePackageCollaboratorInput {
  packageName: String!
  role: GrapheneRole!
  username: String
  email: String
  clientMutationId: String
}

type AcceptPackageCollaboratorInvitePayload {
  packageCollaboratorInvite: PackageCollaboratorInvite!
  clientMutationId: String
}

input AcceptPackageCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type RemovePackageCollaboratorInvitePayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageCollaboratorInviteInput {
  inviteId: ID!
  clientMutationId: String
}

type UpdatePackageCollaboratorRolePayload {
  collaborator: PackageCollaborator!
  clientMutationId: String
}

input UpdatePackageCollaboratorRoleInput {
  packageCollaboratorId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type UpdatePackageCollaboratorInviteRolePayload {
  collaboratorInvite: PackageCollaboratorInvite!
  clientMutationId: String
}

input UpdatePackageCollaboratorInviteRoleInput {
  packageCollaboratorInviteId: ID!
  role: GrapheneRole!
  clientMutationId: String
}

type RemovePackageCollaboratorPayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageCollaboratorInput {
  packageCollaboratorId: ID!
  clientMutationId: String
}

type RequestPackageTransferPayload {
  package: Package!
  wasInstantlyTransferred: Boolean!
  packageTransferRequest: PackageTransferRequest
  clientMutationId: String
}

input RequestPackageTransferInput {
  packageId: ID!
  newOwnerId: ID!
  clientMutationId: String
}

type AcceptPackageTransferRequestPayload {
  package: Package!
  packageTransferRequest: PackageTransferRequest!
  clientMutationId: String
}

input AcceptPackageTransferRequestInput {
  packageTransferRequestId: ID!
  clientMutationId: String
}

type RemovePackageTransferRequestPayload {
  package: Package!
  clientMutationId: String
}

input RemovePackageTransferRequestInput {
  packageTransferRequestId: ID!
  clientMutationId: String
}

type GenerateBindingsForAllPackagesPayload {
  message: String!
  clientMutationId: String
}

input GenerateBindingsForAllPackagesInput {
  bindingsGeneratorId: ID
  bindingsGeneratorCommand: String
  clientMutationId: String
}

type MakePackagePublicPayload {
  package: Package!
  clientMutationId: String
}

input MakePackagePublicInput {
  """The ID of the package to make public"""
  id: ID!
  clientMutationId: String
}

type GenerateUploadUrlPayload {
  signedUrl: SignedUrl!
  clientMutationId: String
}

input GenerateUploadUrlInput {
  name: String
  version: String = "latest"
  filename: String
  expiresAfterSeconds: Int = 60
  clientMutationId: String
}

type Subscription {
  autobuildDeployment(buildId: UUID!): AutobuildLog
  generateScreenshot(
    """App version ID"""
    appVersionId: ID!

    """Force generation"""
    forceGeneration: Boolean = false
  ): DeployAppVersion!
  streamLogs(
    """
    Specify the app to show logs for. Alternatively, you can also just specify the app version if you want. If both app and app-version are specified, then the app-version must be associated with specified app.
    """
    appId: ID

    """Filter logs for app to a certain app version."""
    appVersionId: ID

    """
    Get logs starting from this timestamp. Takes ISO timestamp in UTC timezone.
    """
    startingFromISO: DateTime

    """
    Fetch logs until this timestamp. Takes ISO timestamp in UTC timezone. If specified, the subscription will at this time.
    """
    untilISO: DateTime

    """Filter logs by stream"""
    streams: [LogStream]

    """Filter logs by instance ids"""
    instanceIds: [String]

    """Filter logs by request ID"""
    requestId: String

    """Search logs for this term"""
    searchTerm: String
  ): Log!
  waitOnRepoCreation(repoId: ID!): Boolean!
  appIsPublishedFromRepo(repoId: ID!): DeployAppVersion!
  runEdgeJob(command: String!, appVersionId: ID!, envVars: [SecretInput], source: String, cliArgs: [String]): Boolean
  fetchBuildLogs(buildId: String!): String
  timeout: Int
  packageVersionCreated(publishedBy: ID, ownerId: ID): PackageVersion!

  """Subscribe to package version ready"""
  packageVersionReady(packageVersionId: ID!): PackageVersionReadyResponse!
  userNotificationCreated(userId: ID!): UserNotificationCreated!
}

"""Log entry for Deploying app from github repo"""
type AutobuildLog {
  """Kind of log message."""
  kind: AutoBuildDeployAppLogKind!

  """Log message"""
  message: String
  appVersion: DeployAppVersion

  """Timestamp in nanoseconds"""
  timestamp: String!

  """ISO 8601 string in UTC"""
  datetime: DateTime!

  """Log stream"""
  stream: LogStream
}

enum AutoBuildDeployAppLogKind {
  LOG
  PREPARING_TO_DEPLOY_STATUS
  FETCHING_PLAN_STATUS
  BUILD_STATUS
  DEPLOY_STATUS
  COMPLETE
  FAILED
}

type PackageVersionReadyResponse {
  state: PackageVersionState!
  packageVersion: PackageVersion!
  success: Boolean!
}

enum PackageVersionState {
  WEBC_GENERATED
  BINDINGS_GENERATED
  NATIVE_EXES_GENERATED
}

type UserNotificationCreated {
  notification: UserNotification
  notificationDeletedId: ID
}
