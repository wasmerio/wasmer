<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Structure` struct in crate `synstructure`."><meta name="keywords" content="rust, rustlang, rust-lang, Structure"><title>synstructure::Structure - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../synstructure/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Struct Structure</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.add_bounds">add_bounds</a><a href="#method.add_impl_generic">add_impl_generic</a><a href="#method.add_trait_bounds">add_trait_bounds</a><a href="#method.add_where_predicate">add_where_predicate</a><a href="#method.ast">ast</a><a href="#method.bind_with">bind_with</a><a href="#method.binding_name">binding_name</a><a href="#method.bound_impl">bound_impl</a><a href="#method.each">each</a><a href="#method.each_variant">each_variant</a><a href="#method.filter">filter</a><a href="#method.filter_variants">filter_variants</a><a href="#method.fold">fold</a><a href="#method.gen_impl">gen_impl</a><a href="#method.new">new</a><a href="#method.omitted_variants">omitted_variants</a><a href="#method.referenced_ty_params">referenced_ty_params</a><a href="#method.remove_variant">remove_variant</a><a href="#method.try_new">try_new</a><a href="#method.unbound_impl">unbound_impl</a><a href="#method.unsafe_bound_impl">unsafe_bound_impl</a><a href="#method.unsafe_unbound_impl">unsafe_unbound_impl</a><a href="#method.variants">variants</a><a href="#method.variants_mut">variants_mut</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-Eq">Eq</a><a href="#impl-Hash">Hash</a><a href="#impl-PartialEq%3CStructure%3C%27a%3E%3E">PartialEq&lt;Structure&lt;&#39;a&gt;&gt;</a><a href="#impl-StructuralEq">StructuralEq</a><a href="#impl-StructuralPartialEq">StructuralPartialEq</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class='location'><a href='index.html'>synstructure</a></p><script>window.sidebarCurrent = {name: 'Structure', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/synstructure/lib.rs.html#935-942' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='index.html'>synstructure</a>::<wbr><a class="struct" href=''>Structure</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct Structure&lt;'a&gt; { /* fields omitted */ }</pre></div><div class='docblock'><p>A wrapper around a <code>syn::DeriveInput</code> which provides utilities for creating
custom derive trait implementations.</p>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#944-2229' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.new' class="method"><code id='new.v'>pub fn <a href='#method.new' class='fnname'>new</a>(ast: &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a>) -&gt; Self</code><a class='srclink' href='../src/synstructure/lib.rs.html#952-954' title='goto source code'>[src]</a></h4><div class='docblock'><p>Create a new <code>Structure</code> with the variants and fields from the passed-in
<code>DeriveInput</code>.</p>
<h1 id="panics" class="section-header"><a href="#panics">Panics</a></h1>
<p>This method will panic if the provided AST node represents an untagged
union.</p>
</div><h4 id='method.try_new' class="method"><code id='try_new.v'>pub fn <a href='#method.try_new' class='fnname'>try_new</a>(ast: &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a>) -&gt; <a class="type" href="../syn/error/type.Result.html" title="type syn::error::Result">Result</a>&lt;Self&gt;</code><a class='srclink' href='../src/synstructure/lib.rs.html#961-1015' title='goto source code'>[src]</a></h4><div class='docblock'><p>Create a new <code>Structure</code> with the variants and fields from the passed-in
<code>DeriveInput</code>.</p>
<p>Unlike <code>Structure::new</code>, this method does not panic if the provided AST
node represents an untagged union.</p>
</div><h4 id='method.variants' class="method"><code id='variants.v'>pub fn <a href='#method.variants' class='fnname'>variants</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[</a><a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1018-1020' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a slice of the variants in this Structure.</p>
</div><h4 id='method.variants_mut' class="method"><code id='variants_mut.v'>pub fn <a href='#method.variants_mut' class='fnname'>variants_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;mut [</a><a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>&lt;'a&gt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1023-1025' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a mut slice of the variants in this Structure.</p>
</div><h4 id='method.ast' class="method"><code id='ast.v'>pub fn <a href='#method.ast' class='fnname'>ast</a>(&amp;self) -&gt; &amp;'a <a class="struct" href="../syn/derive/struct.DeriveInput.html" title="struct syn::derive::DeriveInput">DeriveInput</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1029-1031' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a reference to the underlying <code>syn</code> AST node which this
<code>Structure</code> was created from.</p>
</div><h4 id='method.omitted_variants' class="method"><code id='omitted_variants.v'>pub fn <a href='#method.omitted_variants' class='fnname'>omitted_variants</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1034-1036' title='goto source code'>[src]</a></h4><div class='docblock'><p>True if any variants were omitted due to a <code>filter_variants</code> call.</p>
</div><h4 id='method.each' class="method"><code id='each.v'>pub fn <a href='#method.each' class='fnname'>each</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></code><a class='srclink' href='../src/synstructure/lib.rs.html#1069-1082' title='goto source code'>[src]</a></h4><div class='docblock'><p>Runs the passed-in function once for each bound field, passing in a <code>BindingInfo</code>.
and generating <code>match</code> arms which evaluate the returned tokens.</p>
<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_1</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.fold' class="method"><code id='fold.v'>pub fn <a href='#method.fold' class='fnname'>fold</a>&lt;F, I, R&gt;(&amp;self, init: I, f: F) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>, &amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></code><a class='srclink' href='../src/synstructure/lib.rs.html#1117-1131' title='goto source code'>[src]</a></h4><div class='docblock'><p>Runs the passed-in function once for each bound field, passing in the
result of the previous call, and a <code>BindingInfo</code>. generating <code>match</code>
arms which evaluate to the resulting tokens.</p>
<p>This method will ignore variants or fields which are ignored through the
<code>filter</code> and <code>filter_variant</code> methods.</p>
<p>If a variant has been ignored, it will return the <code>init</code> value.</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">fold</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="number">0</span>), <span class="op">|</span><span class="ident">acc</span>, <span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(#<span class="ident">acc</span> <span class="op">+</span> #<span class="ident">bi</span>)).<span class="ident">to_string</span>(),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="number">0</span> <span class="op">+</span> <span class="ident">__binding_0</span> <span class="op">+</span> <span class="ident">__binding_1</span>
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="number">0</span> <span class="op">+</span> <span class="ident">__binding_0</span>
        }
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.each_variant' class="method"><code id='each_variant.v'>pub fn <a href='#method.each_variant' class='fnname'>each_variant</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>) -&gt; R,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>,&nbsp;</span></code><a class='srclink' href='../src/synstructure/lib.rs.html#1167-1182' title='goto source code'>[src]</a></h4><div class='docblock'><p>Runs the passed-in function once for each variant, passing in a
<code>VariantInfo</code>. and generating <code>match</code> arms which evaluate the returned
tokens.</p>
<p>This method will ignore variants and not bind fields which are ignored
through the <code>filter</code> and <code>filter_variant</code> methods.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each_variant</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span>;
        <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="macro">stringify</span><span class="macro">!</span>(#<span class="ident">name</span>)))
    }).<span class="ident">to_string</span>(),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="ident">__binding_1</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="macro">println</span><span class="macro">!</span>(<span class="macro">stringify</span><span class="macro">!</span>(<span class="ident">B</span>))
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            <span class="macro">println</span><span class="macro">!</span>(<span class="macro">stringify</span><span class="macro">!</span>(<span class="ident">C</span>))
        }
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.filter' class="method"><code id='filter.v'>pub fn <a href='#method.filter' class='fnname'>filter</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../src/synstructure/lib.rs.html#1221-1229' title='goto source code'>[src]</a></h4><div class='docblock'><p>Filter the bindings created by this <code>Structure</code> object. This has 2 effects:</p>
<ul>
<li>
<p>The bindings will no longer appear in match arms generated by methods
on this <code>Structure</code> or its subobjects.</p>
</li>
<li>
<p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
non-filtered fields.</p>
</li>
</ul>
<h1 id="example-3" class="section-header"><a href="#example-3">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>{ <span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i32</span> },
        <span class="ident">C</span>{ <span class="ident">a</span>: <span class="ident">u32</span> },
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> {
    <span class="ident">bi</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">=</span><span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">quote</span>::<span class="macro">format_ident</span><span class="macro">!</span>(<span class="string">&quot;a&quot;</span>))
});

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">__binding_0</span>, .. } <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">__binding_0</span>, } <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.add_where_predicate' class="method"><code id='add_where_predicate.v'>pub fn <a href='#method.add_where_predicate' class='fnname'>add_where_predicate</a>(&amp;mut self, pred: <a class="enum" href="../syn/generics/enum.WherePredicate.html" title="enum syn::generics::WherePredicate">WherePredicate</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self</code><a class='srclink' href='../src/synstructure/lib.rs.html#1270-1273' title='goto source code'>[src]</a></h4><div class='docblock'><p>Specify additional where predicate bounds which should be generated by
impl-generating functions such as <code>gen_impl</code>, <code>bound_impl</code>, and
<code>unsafe_bound_impl</code>.</p>
<h1 id="example-4" class="section-header"><a href="#example-4">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="comment">// Add an additional where predicate.</span>
<span class="ident">s</span>.<span class="ident">add_where_predicate</span>(<span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span>(<span class="ident">T</span>: <span class="ident">std</span>::<span class="ident">fmt</span>::<span class="ident">Display</span>));

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">bound_impl</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="ident">krate</span>::<span class="ident">Trait</span>), <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">std</span>::<span class="ident">fmt</span>::<span class="ident">Display</span>,
                      <span class="ident">T</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>,
                      <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.add_bounds' class="method"><code id='add_bounds.v'>pub fn <a href='#method.add_bounds' class='fnname'>add_bounds</a>(&amp;mut self, mode: <a class="enum" href="../synstructure/enum.AddBounds.html" title="enum synstructure::AddBounds">AddBounds</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self</code><a class='srclink' href='../src/synstructure/lib.rs.html#1314-1317' title='goto source code'>[src]</a></h4><div class='docblock'><p>Specify which bounds should be generated by impl-generating functions
such as <code>gen_impl</code>, <code>bound_impl</code>, and <code>unsafe_bound_impl</code>.</p>
<p>The default behaviour is to generate both field and generic bounds from
type parameters.</p>
<h1 id="example-5" class="section-header"><a href="#example-5">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="comment">// Limit bounds to only generics.</span>
<span class="ident">s</span>.<span class="ident">add_bounds</span>(<span class="ident">AddBounds</span>::<span class="ident">Generics</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">bound_impl</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="ident">krate</span>::<span class="ident">Trait</span>), <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.filter_variants' class="method"><code id='filter_variants.v'>pub fn <a href='#method.filter_variants' class='fnname'>filter_variants</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.VariantInfo.html" title="struct synstructure::VariantInfo">VariantInfo</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,&nbsp;</span></code><a class='srclink' href='../src/synstructure/lib.rs.html#1353-1363' title='goto source code'>[src]</a></h4><div class='docblock'><p>Filter the variants matched by this <code>Structure</code> object. This has 2 effects:</p>
<ul>
<li>
<p>Match arms destructuring these variants will no longer be generated by
methods on this <code>Structure</code></p>
</li>
<li>
<p>Impl blocks created with the <code>bound_impl</code> or <code>unsafe_bound_impl</code>
method only consider type parameters referenced in the types of
fields in non-fitered variants.</p>
</li>
</ul>
<h1 id="example-6" class="section-header"><a href="#example-6">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="ident">__binding_0</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
        <span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> {}
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.remove_variant' class="method"><code id='remove_variant.v'>pub fn <a href='#method.remove_variant' class='fnname'>remove_variant</a>(&amp;mut self, idx: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self</code><a class='srclink' href='../src/synstructure/lib.rs.html#1370-1374' title='goto source code'>[src]</a></h4><div class='docblock'><p>Remove the variant at the given index.</p>
<h1 id="panics-1" class="section-header"><a href="#panics-1">Panics</a></h1>
<p>Panics if the index is out of range.</p>
</div><h4 id='method.bind_with' class="method"><code id='bind_with.v'>pub fn <a href='#method.bind_with' class='fnname'>bind_with</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../synstructure/struct.BindingInfo.html" title="struct synstructure::BindingInfo">BindingInfo</a>) -&gt; <a class="enum" href="../synstructure/enum.BindStyle.html" title="enum synstructure::BindStyle">BindStyle</a>,&nbsp;</span></code><a class='srclink' href='../src/synstructure/lib.rs.html#1406-1414' title='goto source code'>[src]</a></h4><div class='docblock'><p>Updates the <code>BindStyle</code> for each of the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>
<h1 id="example-7" class="section-header"><a href="#example-7">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>(<span class="ident">i32</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="ident">u32</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">bind_with</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="ident">BindStyle</span>::<span class="ident">RefMut</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>(<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_0</span>, <span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_1</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_1</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>(<span class="kw-2">ref</span> <span class="kw-2">mut</span> <span class="ident">__binding_0</span>,) <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">__binding_0</span>) }
        }
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.binding_name' class="method"><code id='binding_name.v'>pub fn <a href='#method.binding_name' class='fnname'>binding_name</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;<a class="struct" href="../syn/data/struct.Field.html" title="struct syn::data::Field">Field</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>,&nbsp;</span></code><a class='srclink' href='../src/synstructure/lib.rs.html#1452-1460' title='goto source code'>[src]</a></h4><div class='docblock'><p>Updates the binding name for each fo the passed-in fields by calling the
passed-in function for each <code>BindingInfo</code>.</p>
<p>The function will be called with the <code>BindingInfo</code> and its index in the
enclosing variant.</p>
<p>The default name is <code>__binding_{}</code> where <code>{}</code> is replaced with an
increasing number.</p>
<h1 id="example-8" class="section-header"><a href="#example-8">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span> {
        <span class="ident">B</span>{ <span class="ident">a</span>: <span class="ident">i32</span>, <span class="ident">b</span>: <span class="ident">i32</span> },
        <span class="ident">C</span>{ <span class="ident">a</span>: <span class="ident">u32</span> },
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">binding_name</span>(<span class="op">|</span><span class="ident">bi</span>, <span class="ident">i</span><span class="op">|</span> <span class="ident">bi</span>.<span class="ident">ident</span>.<span class="ident">clone</span>().<span class="ident">unwrap</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">each</span>(<span class="op">|</span><span class="ident">bi</span><span class="op">|</span> <span class="macro">quote</span><span class="macro">!</span>(<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, #<span class="ident">bi</span>))).<span class="ident">to_string</span>(),

    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="ident">A</span>::<span class="ident">B</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">a</span>, <span class="ident">b</span>: <span class="kw-2">ref</span> <span class="ident">b</span>, } <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">a</span>) }
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">b</span>) }
        }
        <span class="ident">A</span>::<span class="ident">C</span>{ <span class="ident">a</span>: <span class="kw-2">ref</span> <span class="ident">a</span>, } <span class="op">=</span><span class="op">&gt;</span> {
            { <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">a</span>) }
        }
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.referenced_ty_params' class="method"><code id='referenced_ty_params.v'>pub fn <a href='#method.referenced_ty_params' class='fnname'>referenced_ty_params</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;&amp;'a <a class="struct" href="../proc_macro2/struct.Ident.html" title="struct proc_macro2::Ident">Ident</a>&gt;</code><a class='srclink' href='../src/synstructure/lib.rs.html#1489-1497' title='goto source code'>[src]</a></h4><div class='docblock'><p>Returns a list of the type parameters which are refrenced in the types
of non-filtered fields / variants.</p>
<h1 id="caveat" class="section-header"><a href="#caveat">Caveat</a></h1>
<p>If the struct contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h1 id="example-9" class="section-header"><a href="#example-9">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>, <span class="ident">i32</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;C&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">referenced_ty_params</span>(),
    <span class="kw-2">&amp;</span>[<span class="kw-2">&amp;</span><span class="ident">quote</span>::<span class="macro">format_ident</span><span class="macro">!</span>(<span class="string">&quot;T&quot;</span>)]
);</pre></div>
</div><h4 id='method.add_impl_generic' class="method"><code id='add_impl_generic.v'>pub fn <a href='#method.add_impl_generic' class='fnname'>add_impl_generic</a>(&amp;mut self, param: <a class="enum" href="../syn/generics/enum.GenericParam.html" title="enum syn::generics::GenericParam">GenericParam</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>Self</code><a class='srclink' href='../src/synstructure/lib.rs.html#1537-1540' title='goto source code'>[src]</a></h4><div class='docblock'><p>Adds an <code>impl&lt;&gt;</code> generic parameter.
This can be used when the trait to be derived needs some extra generic parameters.</p>
<h1 id="example-10" class="section-header"><a href="#example-10">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);
<span class="kw">let</span> <span class="ident">generic</span>: <span class="ident">syn</span>::<span class="ident">GenericParam</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span>(<span class="ident">X</span>: <span class="ident">krate</span>::<span class="ident">AnotherTrait</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">add_impl_generic</span>(<span class="ident">generic</span>)
        .<span class="ident">bound_impl</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>),
        <span class="macro">quote</span><span class="macro">!</span>{
                <span class="kw">fn</span> <span class="ident">a</span>() {}
        }
    ).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_X_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span>, <span class="ident">X</span>: <span class="ident">krate</span>::<span class="ident">AnotherTrait</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="ident">T</span> : <span class="ident">krate</span> :: <span class="ident">Trait</span> <span class="op">&lt;</span> <span class="ident">X</span> <span class="op">&gt;</span>,
                      <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>,
                      <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.add_trait_bounds' class="method"><code id='add_trait_bounds.v'>pub fn <a href='#method.add_trait_bounds' class='fnname'>add_trait_bounds</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;bound: &amp;<a class="struct" href="../syn/generics/struct.TraitBound.html" title="struct syn::generics::TraitBound">TraitBound</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;where_clause: &amp;mut <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../syn/generics/struct.WhereClause.html" title="struct syn::generics::WhereClause">WhereClause</a>&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;mode: <a class="enum" href="../synstructure/enum.AddBounds.html" title="enum synstructure::AddBounds">AddBounds</a><br>)</code><a class='srclink' href='../src/synstructure/lib.rs.html#1550-1615' title='goto source code'>[src]</a></h4><div class='docblock'><p>Add trait bounds for a trait with the given path for each type parmaeter
referenced in the types of non-filtered fields.</p>
<h1 id="caveat-1" class="section-header"><a href="#caveat-1">Caveat</a></h1>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
</div><h4 id='method.bound_impl' class="method"><code id='bound_impl.v'>pub fn <a href='#method.bound_impl' class='fnname'>bound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1678-1685' title='goto source code'>[src]</a></h4><div class='docblock'><blockquote>
<p>NOTE: This methods' features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the trait <code>path</code>.</p>
<p>This method also adds where clauses to the impl requiring that all
referenced type parmaeters implement the trait <code>path</code>.</p>
<h1 id="hygiene-and-paths" class="section-header"><a href="#hygiene-and-paths">Hygiene and Paths</a></h1>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don't want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h1 id="caveat-2" class="section-header"><a href="#caveat-2">Caveat</a></h1>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h1 id="panics-2" class="section-header"><a href="#panics-2">Panics</a></h1>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h1 id="example-11" class="section-header"><a href="#example-11">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">bound_impl</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="ident">krate</span>::<span class="ident">Trait</span>), <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.unsafe_bound_impl' class="method"><code id='unsafe_bound_impl.v'>pub fn <a href='#method.unsafe_bound_impl' class='fnname'>unsafe_bound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1748-1755' title='goto source code'>[src]</a></h4><div class='docblock'><blockquote>
<p>NOTE: This methods' features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the unsafe trait <code>path</code>.</p>
<p>This method also adds where clauses to the impl requiring that all
referenced type parmaeters implement the trait <code>path</code>.</p>
<h1 id="hygiene-and-paths-1" class="section-header"><a href="#hygiene-and-paths-1">Hygiene and Paths</a></h1>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don't want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h1 id="caveat-3" class="section-header"><a href="#caveat-3">Caveat</a></h1>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h1 id="panics-3" class="section-header"><a href="#panics-3">Panics</a></h1>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h1 id="example-12" class="section-header"><a href="#example-12">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">unsafe_bound_impl</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="ident">krate</span>::<span class="ident">Trait</span>), <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
                <span class="kw">where</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>,
                      <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.unbound_impl' class="method"><code id='unbound_impl.v'>pub fn <a href='#method.unbound_impl' class='fnname'>unbound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1808-1815' title='goto source code'>[src]</a></h4><div class='docblock'><blockquote>
<p>NOTE: This methods' features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the trait <code>path</code>.</p>
<p>This method will not add any where clauses to the impl.</p>
<h1 id="hygiene-and-paths-2" class="section-header"><a href="#hygiene-and-paths-2">Hygiene and Paths</a></h1>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don't want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h1 id="panics-4" class="section-header"><a href="#panics-4">Panics</a></h1>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h1 id="example-13" class="section-header"><a href="#example-13">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">unbound_impl</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="ident">krate</span>::<span class="ident">Trait</span>), <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.unsafe_unbound_impl' class="method"><code id='unsafe_unbound_impl.v'>pub fn <a href='#method.unsafe_unbound_impl' class='fnname'>unsafe_unbound_impl</a>&lt;P:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>, B:&nbsp;<a class="trait" href="../quote/to_tokens/trait.ToTokens.html" title="trait quote::to_tokens::ToTokens">ToTokens</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;path: P, <br>&nbsp;&nbsp;&nbsp;&nbsp;body: B<br>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#1869-1876' title='goto source code'>[src]</a></h4><div class='stability'><div class='stab deprecated'>Deprecated</div></div><div class='docblock'><blockquote>
<p>NOTE: This methods' features are superceded by <code>Structure::gen_impl</code>.</p>
</blockquote>
<p>Creates an <code>impl</code> block with the required generic type fields filled in
to implement the unsafe trait <code>path</code>.</p>
<p>This method will not add any where clauses to the impl.</p>
<h1 id="hygiene-and-paths-3" class="section-header"><a href="#hygiene-and-paths-3">Hygiene and Paths</a></h1>
<p>This method wraps the impl block inside of a <code>const</code> (see the example
below). In this scope, the first segment of the passed-in path is
<code>extern crate</code>-ed in. If you don't want to generate that <code>extern crate</code>
item, use a global path.</p>
<p>This means that if you are implementing <code>my_crate::Trait</code>, you simply
write <code>s.bound_impl(quote!(my_crate::Trait), quote!(...))</code>, and for the
entirety of the definition, you can refer to your crate as <code>my_crate</code>.</p>
<h1 id="panics-5" class="section-header"><a href="#panics-5">Panics</a></h1>
<p>Panics if the path string parameter is not a valid <code>TraitBound</code>.</p>
<h1 id="example-14" class="section-header"><a href="#example-14">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">unsafe_unbound_impl</span>(<span class="macro">quote</span><span class="macro">!</span>(<span class="ident">krate</span>::<span class="ident">Trait</span>), <span class="macro">quote</span><span class="macro">!</span>{
        <span class="kw">fn</span> <span class="ident">a</span>() {}
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">unsafe</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
</div><h4 id='method.gen_impl' class="method"><code id='gen_impl.v'>pub fn <a href='#method.gen_impl' class='fnname'>gen_impl</a>(&amp;self, cfg: <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a>) -&gt; <a class="struct" href="../proc_macro2/struct.TokenStream.html" title="struct proc_macro2::TokenStream">TokenStream</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#2129-2135' title='goto source code'>[src]</a></h4><div class='docblock'><p>Generate an impl block for the given struct. This impl block will
automatically use hygiene tricks to avoid polluting the caller's
namespace, and will automatically add trait bounds for generic type
parameters.</p>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h1>
<p>This function accepts its arguments as a <code>TokenStream</code>. The recommended way
to call this function is passing the result of invoking the <code>quote!</code>
macro to it.</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote</span><span class="macro">!</span> {
    <span class="comment">// You can write any items which you want to import into scope here.</span>
    <span class="comment">// For example, you may want to include an `extern crate` for the</span>
    <span class="comment">// crate which implements your trait. These items will only be</span>
    <span class="comment">// visible to the code you generate, and won&#39;t be exposed to the</span>
    <span class="comment">// consuming crate</span>
    <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;

    <span class="comment">// You can also add `use` statements here to bring types or traits</span>
    <span class="comment">// into scope.</span>
    <span class="comment">//</span>
    <span class="comment">// WARNING: Try not to use common names here, because the stable</span>
    <span class="comment">// version of syn does not support hygiene and you could accidentally</span>
    <span class="comment">// shadow types from the caller crate.</span>
    <span class="kw">use</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">as</span> <span class="ident">MyTrait</span>;

    <span class="comment">// The actual impl block is a `gen impl` or `gen unsafe impl` block.</span>
    <span class="comment">// You can use `@Self` to refer to the structure&#39;s type.</span>
    <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">MyTrait</span> <span class="kw">for</span> @<span class="self">Self</span> {
        <span class="kw">fn</span> <span class="ident">f</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { ... }
    }
})</pre></div>
<p>The most common usage of this trait involves loading the crate the
target trait comes from with <code>extern crate</code>, and then invoking a <code>gen impl</code> block.</p>
<h1 id="hygiene" class="section-header"><a href="#hygiene">Hygiene</a></h1>
<p>This method tries to handle hygiene intelligenly for both stable and
unstable proc-macro implementations, however there are visible
differences.</p>
<p>The output of every <code>gen_impl</code> function is wrapped in a dummy <code>const</code>
value, to ensure that it is given its own scope, and any values brought
into scope are not leaked to the calling crate. For example, the above
invocation may generate an output like the following:</p>

<div class='information'><div class='tooltip ignore'>ⓘ<span class='tooltiptext'>This example is not tested</span></div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore">
<span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_Struct</span>: () <span class="op">=</span> {
    <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
    <span class="kw">use</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">as</span> <span class="ident">MyTrait</span>;
    <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">MyTrait</span> <span class="kw">for</span> <span class="ident">Struct</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">where</span> <span class="ident">T</span>: <span class="ident">MyTrait</span> {
        <span class="kw">fn</span> <span class="ident">f</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) { ... }
    }
};</pre></div>
<h3 id="using-the-std-crate" class="section-header"><a href="#using-the-std-crate">Using the <code>std</code> crate</a></h3>
<p>If you are using <code>quote!()</code> to implement your trait, with the
<code>proc-macro2/nightly</code> feature, <code>std</code> isn't considered to be in scope for
your macro. This means that if you use types from <code>std</code> in your
procedural macro, you'll want to explicitly load it with an <code>extern crate std;</code>.</p>
<h3 id="absolute-paths" class="section-header"><a href="#absolute-paths">Absolute paths</a></h3>
<p>You should generally avoid using absolute paths in your generated code,
as they will resolve very differently when using the stable and nightly
versions of <code>proc-macro2</code>. Instead, load the crates you need to use
explictly with <code>extern crate</code> and</p>
<h1 id="trait-bounds" class="section-header"><a href="#trait-bounds">Trait Bounds</a></h1>
<p>This method will automatically add trait bounds for any type parameters
which are referenced within the types of non-ignored fields.</p>
<p>Additional type parameters may be added with the generics syntax after
the <code>impl</code> keyword.</p>
<h3 id="type-macro-caveat" class="section-header"><a href="#type-macro-caveat">Type Macro Caveat</a></h3>
<p>If the method contains any macros in type position, all parameters will
be considered bound. This is because we cannot determine which type
parameters are bound by type macros.</p>
<h1 id="errors" class="section-header"><a href="#errors">Errors</a></h1>
<p>This function will generate a <code>compile_error!</code> if additional type
parameters added by <code>impl&lt;..&gt;</code> conflict with generic type parameters on
the original struct.</p>
<h1 id="panics-6" class="section-header"><a href="#panics-6">Panics</a></h1>
<p>This function will panic if the input <code>TokenStream</code> is not well-formed.</p>
<h1 id="example-usage" class="section-header"><a href="#example-usage">Example Usage</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">let</span> <span class="ident">di</span>: <span class="ident">syn</span>::<span class="ident">DeriveInput</span> <span class="op">=</span> <span class="ident">syn</span>::<span class="macro">parse_quote</span><span class="macro">!</span> {
    <span class="kw">enum</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> {
        <span class="ident">B</span>(<span class="ident">T</span>),
        <span class="ident">C</span>(<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>),
    }
};
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">Structure</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">di</span>);

<span class="ident">s</span>.<span class="ident">filter_variants</span>(<span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">ast</span>().<span class="ident">ident</span> <span class="op">!</span><span class="op">=</span> <span class="string">&quot;B&quot;</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote</span><span class="macro">!</span> {
        <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
        <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> @<span class="self">Self</span> {
            <span class="kw">fn</span> <span class="ident">a</span>() {}
        }
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>,
                <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);

<span class="comment">// NOTE: You can also add extra generics after the impl</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote</span><span class="macro">!</span> {
        <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
        <span class="ident">gen</span> <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">X</span>: <span class="ident">krate</span>::<span class="ident">OtherTrait</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span> <span class="kw">for</span> @<span class="self">Self</span>
        <span class="kw">where</span>
            <span class="ident">X</span>: <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span>,
        {
            <span class="kw">fn</span> <span class="ident">a</span>() {}
        }
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_X_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">X</span>: <span class="ident">krate</span>::<span class="ident">OtherTrait</span>, <span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="ident">X</span>: <span class="ident">Send</span> <span class="op">+</span> <span class="ident">Sync</span>,
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>,
                <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span><span class="op">&lt;</span><span class="ident">X</span><span class="op">&gt;</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);

<span class="comment">// NOTE: you can generate multiple traits with a single call</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(
    <span class="ident">s</span>.<span class="ident">gen_impl</span>(<span class="macro">quote</span><span class="macro">!</span> {
        <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;

        <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> @<span class="self">Self</span> {
            <span class="kw">fn</span> <span class="ident">a</span>() {}
        }

        <span class="ident">gen</span> <span class="kw">impl</span> <span class="ident">krate</span>::<span class="ident">OtherTrait</span> <span class="kw">for</span> @<span class="self">Self</span> {
            <span class="kw">fn</span> <span class="ident">b</span>() {}
        }
    }).<span class="ident">to_string</span>(),
    <span class="macro">quote</span><span class="macro">!</span>{
        <span class="attribute">#[<span class="ident">allow</span>(<span class="ident">non_upper_case_globals</span>)]</span>
        <span class="kw">const</span> <span class="ident">_DERIVE_krate_Trait_FOR_A</span>: () <span class="op">=</span> {
            <span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">krate</span>;
            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">Trait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>,
                <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">Trait</span>
            {
                <span class="kw">fn</span> <span class="ident">a</span>() {}
            }

            <span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span> <span class="ident">krate</span>::<span class="ident">OtherTrait</span> <span class="kw">for</span> <span class="ident">A</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">U</span><span class="op">&gt;</span>
            <span class="kw">where</span>
                <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">U</span><span class="op">&gt;</span>: <span class="ident">krate</span>::<span class="ident">OtherTrait</span>,
                <span class="ident">U</span>: <span class="ident">krate</span>::<span class="ident">OtherTrait</span>
            {
                <span class="kw">fn</span> <span class="ident">b</span>() {}
            }
        };
    }.<span class="ident">to_string</span>()
);</pre></div>
<p>Use <code>add_bounds</code> to change which bounds are generated.</p>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Clone' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code id='clone.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method hidden"><code id='clone_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Eq' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-Eq' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-PartialEq%3CStructure%3C%27a%3E%3E' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;&gt; for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-PartialEq%3CStructure%3C%27a%3E%3E' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.eq' class="method hidden"><code id='eq.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq' class='fnname'>eq</a>(&amp;self, other: &amp;<a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div><h4 id='method.ne' class="method hidden"><code id='ne.v'>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;<a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>This method tests for <code>!=</code>.</p>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Hash' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-Hash' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.hash' class="method hidden"><code id='hash.v'>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash' class='fnname'>hash</a>&lt;__H:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>__H)</code><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds this value into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div><h4 id='method.hash_slice' class="method hidden"><code id='hash_slice.v'>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">&amp;[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></code><span class='since' title='Stable since Rust version 1.3.0'>1.3.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#192-198' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Feeds a slice of this type into the given [<code>Hasher</code>]. <a href="https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></div><h3 id='impl-StructuralPartialEq' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralPartialEq.html" title="trait core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-StructuralPartialEq' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h3><div class='impl-items'></div><h3 id='impl-StructuralEq' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.StructuralEq.html" title="trait core::marker::StructuralEq">StructuralEq</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-StructuralEq' class='anchor'></a><a class='srclink' href='../src/synstructure/lib.rs.html#934' title='goto source code'>[src]</a></h3><div class='impl-items'></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-Unpin' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-UnwindSafe' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-RefUnwindSafe' class='impl'><code class='in-band'>impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../synstructure/struct.Structure.html" title="struct synstructure::Structure">Structure</a>&lt;'a&gt;</code><a href='#impl-RefUnwindSafe' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#544-549' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#546-548' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#553-555' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#554' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-ToOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned' class="type"><code id='Owned.t'>type <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned' class="method hidden"><code id='to_owned.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into' class="method hidden"><code id='clone_into.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#584-590' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#587-589' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#572-579' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert.rs.html#576-578' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-215' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-220' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#98-100' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#99' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "synstructure";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>