initSidebarItems({"struct":[["OwningHandle","`OwningHandle` is a complement to `OwningRef`. Where `OwningRef` allows consumers to pass around an owned object and a dependent reference, `OwningHandle` contains an owned object and a dependent object."],["OwningRef","An owning reference."],["OwningRefMut","An mutable owning reference."]],"trait":[["CloneStableAddress","An unsafe marker trait for types where clones deref to the same address. This has all the requirements of StableDeref, and additionally requires that after calling clone(), both the old and new value deref to the same address. For example, Rc and Arc implement CloneStableDeref, but Box and Vec do not."],["Erased","Helper trait for an erased concrete type an owner dereferences to. This is used in form of a trait object for keeping something around to (virtually) call the destructor."],["IntoErased","Helper trait for erasing the concrete type of what an owner derferences to, for example `Box<T> -> Box<Erased>`. This would be unneeded with higher kinded types support in the language."],["StableAddress","An unsafe marker trait for types that deref to a stable address, even when moved. For example, this is implemented by Box, Vec, Rc, Arc and String, among others. Even when a Box is moved, the underlying storage remains at a fixed location."],["ToHandle","Trait to implement the conversion of owner to handle for common types."],["ToHandleMut","Trait to implement the conversion of owner to mutable handle for common types."]],"type":[["ArcRef","Typedef of a owning reference that uses a `Arc` as the owner."],["BoxRef","Typedef of a owning reference that uses a `Box` as the owner."],["BoxRefMut","Typedef of a mutable owning reference that uses a `Box` as the owner."],["ErasedArcRef","Typedef of a owning reference that uses an erased `Arc` as the owner."],["ErasedBoxRef","Typedef of a owning reference that uses an erased `Box` as the owner."],["ErasedBoxRefMut","Typedef of a mutable owning reference that uses an erased `Box` as the owner."],["ErasedRcRef","Typedef of a owning reference that uses an erased `Rc` as the owner."],["MutexGuardRef","Typedef of a owning reference that uses a `MutexGuard` as the owner."],["MutexGuardRefMut","Typedef of a mutable owning reference that uses a `MutexGuard` as the owner."],["RcRef","Typedef of a owning reference that uses a `Rc` as the owner."],["RefMutRef","Typedef of a owning reference that uses a `RefMut` as the owner."],["RefMutRefMut","Typedef of a mutable owning reference that uses a `RefMut` as the owner."],["RefRef","Typedef of a owning reference that uses a `Ref` as the owner."],["RwLockReadGuardRef","Typedef of a owning reference that uses a `RwLockReadGuard` as the owner."],["RwLockWriteGuardRef","Typedef of a owning reference that uses a `RwLockWriteGuard` as the owner."],["RwLockWriteGuardRefMut","Typedef of a mutable owning reference that uses a `RwLockWriteGuard` as the owner."],["StringRef","Typedef of a owning reference that uses a `String` as the owner."],["StringRefMut","Typedef of a mutable owning reference that uses a `String` as the owner."],["VecRef","Typedef of a owning reference that uses a `Vec` as the owner."],["VecRefMut","Typedef of a mutable owning reference that uses a `Vec` as the owner."]]});