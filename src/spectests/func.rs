// Rust test file autogenerated with cargo build (build/spectests.rs).
// Please do NOT modify it by hand, as it will be reseted on next build.
// Test based on spectests/func.wast
#![allow(
    warnings,
    dead_code
)]
use wabt::wat2wasm;

use crate::runtime::types::Value;
use crate::webassembly::{compile, instantiate, ImportObject, Instance, ResultObject};

use super::_common::{spectest_importobject, NaNCheck};

// Line 3
fn create_module_1() -> ResultObject {
    let module_str = "(module
      (type (;0;) (func))
      (type (;1;) (func))
      (type (;2;) (func (result i32)))
      (type (;3;) (func (param i32)))
      (type (;4;) (func (param i32 f64 i32) (result i32)))
      (type (;5;) (func))
      (type (;6;) (func (param i32 f64 i64)))
      (type (;7;) (func (param i32 f64)))
      (type (;8;) (func (param i32 f32 i64 i32 f64)))
      (type (;9;) (func (param i32 f32 i64 i32) (result i32)))
      (type (;10;) (func (result i64)))
      (type (;11;) (func (result f32)))
      (type (;12;) (func (result f64)))
      (type (;13;) (func (param i32 i32) (result i32)))
      (type (;14;) (func (param i64 i64) (result i64)))
      (type (;15;) (func (param f32 f32) (result f32)))
      (type (;16;) (func (param f64 f64) (result f64)))
      (type (;17;) (func (param f32 i32 i64 i32 f64 i32) (result f64)))
      (type (;18;) (func (param i32) (result i32)))
      (func (;0;) (type 0))
      (func (;1;) (type 0))
      (func (;2;) (type 0))
      (func (;3;) (type 0))
      (func (;4;) (type 0))
      (func (;5;) (type 0))
      (func (;6;) (type 0))
      (func (;7;) (type 0)
        (local i32))
      (func (;8;) (type 0)
        (local i32))
      (func (;9;) (type 0)
        (local i32 f64 i64))
      (func (;10;) (type 0)
        (local i32 f64))
      (func (;11;) (type 0)
        (local i32 f32 i64 i32 f64))
      (func (;12;) (type 0))
      (func (;13;) (type 0))
      (func (;14;) (type 3) (param i32))
      (func (;15;) (type 3) (param i32))
      (func (;16;) (type 6) (param i32 f64 i64))
      (func (;17;) (type 7) (param i32 f64))
      (func (;18;) (type 8) (param i32 f32 i64 i32 f64))
      (func (;19;) (type 2) (result i32)
        unreachable)
      (func (;20;) (type 1))
      (func (;21;) (type 2) (result i32)
        i32.const 0)
      (func (;22;) (type 3) (param i32))
      (func (;23;) (type 4) (param i32 f64 i32) (result i32)
        i32.const 0)
      (func (;24;) (type 2) (result i32)
        i32.const 0)
      (func (;25;) (type 3) (param i32))
      (func (;26;) (type 4) (param i32 f64 i32) (result i32)
        i32.const 0)
      (func (;27;) (type 0))
      (func (;28;) (type 5))
      (func (;29;) (type 9) (param i32 f32 i64 i32) (result i32)
        (local f32 i32 i64 i32 f64 i32)
        unreachable
        unreachable)
      (func (;30;) (type 0)
        (local f32 i32 i64 i32 f64 i32)
        unreachable
        unreachable)
      (func (;31;) (type 2) (result i32)
        (local i32 i32)
        get_local 0)
      (func (;32;) (type 10) (result i64)
        (local i64 i64)
        get_local 0)
      (func (;33;) (type 11) (result f32)
        (local f32 f32)
        get_local 0)
      (func (;34;) (type 12) (result f64)
        (local f64 f64)
        get_local 0)
      (func (;35;) (type 2) (result i32)
        (local i32 i32)
        get_local 1)
      (func (;36;) (type 10) (result i64)
        (local i64 i64)
        get_local 1)
      (func (;37;) (type 11) (result f32)
        (local f32 f32)
        get_local 1)
      (func (;38;) (type 12) (result f64)
        (local f64 f64)
        get_local 1)
      (func (;39;) (type 12) (result f64)
        (local f32 i32 i64 i32 f64 i32)
        get_local 0
        f32.neg
        drop
        get_local 1
        i32.eqz
        drop
        get_local 2
        i64.eqz
        drop
        get_local 3
        i32.eqz
        drop
        get_local 4
        f64.neg
        drop
        get_local 5
        i32.eqz
        drop
        get_local 4)
      (func (;40;) (type 13) (param i32 i32) (result i32)
        get_local 0)
      (func (;41;) (type 14) (param i64 i64) (result i64)
        get_local 0)
      (func (;42;) (type 15) (param f32 f32) (result f32)
        get_local 0)
      (func (;43;) (type 16) (param f64 f64) (result f64)
        get_local 0)
      (func (;44;) (type 13) (param i32 i32) (result i32)
        get_local 1)
      (func (;45;) (type 14) (param i64 i64) (result i64)
        get_local 1)
      (func (;46;) (type 15) (param f32 f32) (result f32)
        get_local 1)
      (func (;47;) (type 16) (param f64 f64) (result f64)
        get_local 1)
      (func (;48;) (type 17) (param f32 i32 i64 i32 f64 i32) (result f64)
        get_local 0
        f32.neg
        drop
        get_local 1
        i32.eqz
        drop
        get_local 2
        i64.eqz
        drop
        get_local 3
        i32.eqz
        drop
        get_local 4
        f64.neg
        drop
        get_local 5
        i32.eqz
        drop
        get_local 4)
      (func (;49;) (type 0))
      (func (;50;) (type 0)
        call 0)
      (func (;51;) (type 2) (result i32)
        i32.const 77)
      (func (;52;) (type 10) (result i64)
        i64.const 7777)
      (func (;53;) (type 11) (result f32)
        f32.const 0x1.36ccccp+6 (;=77.7;))
      (func (;54;) (type 12) (result f64)
        f64.const 0x1.37147ae147ae1p+6 (;=77.77;))
      (func (;55;) (type 0)
        block  ;; label = @1
          call 0
          call 0
        end)
      (func (;56;) (type 2) (result i32)
        block (result i32)  ;; label = @1
          call 0
          i32.const 77
        end)
      (func (;57;) (type 0)
        return)
      (func (;58;) (type 2) (result i32)
        i32.const 78
        return)
      (func (;59;) (type 10) (result i64)
        i64.const 7878
        return)
      (func (;60;) (type 11) (result f32)
        f32.const 0x1.3accccp+6 (;=78.7;)
        return)
      (func (;61;) (type 12) (result f64)
        f64.const 0x1.3b1eb851eb852p+6 (;=78.78;)
        return)
      (func (;62;) (type 2) (result i32)
        block (result i32)  ;; label = @1
          call 0
          i32.const 77
        end
        return)
      (func (;63;) (type 0)
        br 0 (;@0;))
      (func (;64;) (type 2) (result i32)
        i32.const 79
        br 0 (;@0;))
      (func (;65;) (type 10) (result i64)
        i64.const 7979
        br 0 (;@0;))
      (func (;66;) (type 11) (result f32)
        f32.const 0x1.3f999ap+6 (;=79.9;)
        br 0 (;@0;))
      (func (;67;) (type 12) (result f64)
        f64.const 0x1.3f28f5c28f5c3p+6 (;=79.79;)
        br 0 (;@0;))
      (func (;68;) (type 2) (result i32)
        block (result i32)  ;; label = @1
          call 0
          i32.const 77
        end
        br 0 (;@0;))
      (func (;69;) (type 3) (param i32)
        get_local 0
        br_if 0 (;@0;))
      (func (;70;) (type 18) (param i32) (result i32)
        i32.const 50
        get_local 0
        br_if 0 (;@0;)
        drop
        i32.const 51)
      (func (;71;) (type 3) (param i32)
        get_local 0
        br_table 0 (;@0;) 0 (;@0;) 0 (;@0;))
      (func (;72;) (type 18) (param i32) (result i32)
        i32.const 50
        get_local 0
        br_table 0 (;@0;) 0 (;@0;)
        i32.const 51)
      (func (;73;) (type 3) (param i32)
        block  ;; label = @1
          get_local 0
          br_table 0 (;@1;) 1 (;@0;) 0 (;@1;)
        end)
      (func (;74;) (type 18) (param i32) (result i32)
        block (result i32)  ;; label = @1
          i32.const 50
          get_local 0
          br_table 0 (;@1;) 1 (;@0;) 0 (;@1;)
          i32.const 51
        end
        i32.const 2
        i32.add)
      (func (;75;) (type 2) (result i32)
        (local i32)
        get_local 0)
      (func (;76;) (type 10) (result i64)
        (local i64)
        get_local 0)
      (func (;77;) (type 11) (result f32)
        (local f32)
        get_local 0)
      (func (;78;) (type 12) (result f64)
        (local f64)
        get_local 0)
      (export \"f\" (func 2))
      (export \"g\" (func 4))
      (export \"type-use-1\" (func 20))
      (export \"type-use-2\" (func 21))
      (export \"type-use-3\" (func 22))
      (export \"type-use-4\" (func 23))
      (export \"type-use-5\" (func 24))
      (export \"type-use-6\" (func 25))
      (export \"type-use-7\" (func 26))
      (export \"local-first-i32\" (func 31))
      (export \"local-first-i64\" (func 32))
      (export \"local-first-f32\" (func 33))
      (export \"local-first-f64\" (func 34))
      (export \"local-second-i32\" (func 35))
      (export \"local-second-i64\" (func 36))
      (export \"local-second-f32\" (func 37))
      (export \"local-second-f64\" (func 38))
      (export \"local-mixed\" (func 39))
      (export \"param-first-i32\" (func 40))
      (export \"param-first-i64\" (func 41))
      (export \"param-first-f32\" (func 42))
      (export \"param-first-f64\" (func 43))
      (export \"param-second-i32\" (func 44))
      (export \"param-second-i64\" (func 45))
      (export \"param-second-f32\" (func 46))
      (export \"param-second-f64\" (func 47))
      (export \"param-mixed\" (func 48))
      (export \"empty\" (func 49))
      (export \"value-void\" (func 50))
      (export \"value-i32\" (func 51))
      (export \"value-i64\" (func 52))
      (export \"value-f32\" (func 53))
      (export \"value-f64\" (func 54))
      (export \"value-block-void\" (func 55))
      (export \"value-block-i32\" (func 56))
      (export \"return-empty\" (func 57))
      (export \"return-i32\" (func 58))
      (export \"return-i64\" (func 59))
      (export \"return-f32\" (func 60))
      (export \"return-f64\" (func 61))
      (export \"return-block-i32\" (func 62))
      (export \"break-empty\" (func 63))
      (export \"break-i32\" (func 64))
      (export \"break-i64\" (func 65))
      (export \"break-f32\" (func 66))
      (export \"break-f64\" (func 67))
      (export \"break-block-i32\" (func 68))
      (export \"break-br_if-empty\" (func 69))
      (export \"break-br_if-num\" (func 70))
      (export \"break-br_table-empty\" (func 71))
      (export \"break-br_table-num\" (func 72))
      (export \"break-br_table-nested-empty\" (func 73))
      (export \"break-br_table-nested-num\" (func 74))
      (export \"init-local-i32\" (func 75))
      (export \"init-local-i64\" (func 76))
      (export \"init-local-f32\" (func 77))
      (export \"init-local-f64\" (func 78)))
    ";
    let wasm_binary = wat2wasm(module_str.as_bytes()).expect("WAST not valid or malformed");
    instantiate(&wasm_binary[..], &spectest_importobject(), None)
        .expect("WASM can't be instantiated")
}

fn start_module_1(result_object: &mut ResultObject) {
    // TODO Review is explicit start needed? Start now called in runtime::Instance::new()
    //result_object.instance.start();
}

// Line 171
fn c1_l171_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c1_l171_action_invoke");
    let result = result_object
        .instance
        .call("type-use-1", &[])
        .expect("Missing result in c1_l171_action_invoke");
    assert_eq!(result, None);
}

// Line 172
fn c2_l172_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c2_l172_action_invoke");
    let result = result_object
        .instance
        .call("type-use-2", &[])
        .expect("Missing result in c2_l172_action_invoke");
    assert_eq!(result, Some(Value::I32(0 as i32)));
}

// Line 173
fn c3_l173_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c3_l173_action_invoke");
    let result = result_object
        .instance
        .call("type-use-3", &[Value::I32(1 as i32)])
        .expect("Missing result in c3_l173_action_invoke");
    assert_eq!(result, None);
}

// Line 175
fn c4_l175_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c4_l175_action_invoke");
    let result = result_object
        .instance
        .call(
            "type-use-4",
            &[
                Value::I32(1 as i32),
                Value::F64((1.0f64).to_bits()),
                Value::I32(1 as i32),
            ],
        )
        .expect("Missing result in c4_l175_action_invoke");
    assert_eq!(result, Some(Value::I32(0 as i32)));
}

// Line 178
fn c5_l178_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c5_l178_action_invoke");
    let result = result_object
        .instance
        .call("type-use-5", &[])
        .expect("Missing result in c5_l178_action_invoke");
    assert_eq!(result, Some(Value::I32(0 as i32)));
}

// Line 179
fn c6_l179_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c6_l179_action_invoke");
    let result = result_object
        .instance
        .call("type-use-6", &[Value::I32(1 as i32)])
        .expect("Missing result in c6_l179_action_invoke");
    assert_eq!(result, None);
}

// Line 181
fn c7_l181_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c7_l181_action_invoke");
    let result = result_object
        .instance
        .call(
            "type-use-7",
            &[
                Value::I32(1 as i32),
                Value::F64((1.0f64).to_bits()),
                Value::I32(1 as i32),
            ],
        )
        .expect("Missing result in c7_l181_action_invoke");
    assert_eq!(result, Some(Value::I32(0 as i32)));
}

// Line 185
fn c8_l185_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c8_l185_action_invoke");
    let result = result_object
        .instance
        .call("local-first-i32", &[])
        .expect("Missing result in c8_l185_action_invoke");
    assert_eq!(result, Some(Value::I32(0 as i32)));
}

// Line 186
fn c9_l186_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c9_l186_action_invoke");
    let result = result_object
        .instance
        .call("local-first-i64", &[])
        .expect("Missing result in c9_l186_action_invoke");
    assert_eq!(result, Some(Value::I64(0 as i64)));
}

// Line 187
fn c10_l187_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c10_l187_action_invoke");
    let result = result_object
        .instance
        .call("local-first-f32", &[])
        .expect("Missing result in c10_l187_action_invoke");
    assert_eq!(result, Some(Value::F32((0.0f32).to_bits())));
}

// Line 188
fn c11_l188_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c11_l188_action_invoke");
    let result = result_object
        .instance
        .call("local-first-f64", &[])
        .expect("Missing result in c11_l188_action_invoke");
    assert_eq!(result, Some(Value::F64((0.0f64).to_bits())));
}

// Line 189
fn c12_l189_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c12_l189_action_invoke");
    let result = result_object
        .instance
        .call("local-second-i32", &[])
        .expect("Missing result in c12_l189_action_invoke");
    assert_eq!(result, Some(Value::I32(0 as i32)));
}

// Line 190
fn c13_l190_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c13_l190_action_invoke");
    let result = result_object
        .instance
        .call("local-second-i64", &[])
        .expect("Missing result in c13_l190_action_invoke");
    assert_eq!(result, Some(Value::I64(0 as i64)));
}

// Line 191
fn c14_l191_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c14_l191_action_invoke");
    let result = result_object
        .instance
        .call("local-second-f32", &[])
        .expect("Missing result in c14_l191_action_invoke");
    assert_eq!(result, Some(Value::F32((0.0f32).to_bits())));
}

// Line 192
fn c15_l192_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c15_l192_action_invoke");
    let result = result_object
        .instance
        .call("local-second-f64", &[])
        .expect("Missing result in c15_l192_action_invoke");
    assert_eq!(result, Some(Value::F64((0.0f64).to_bits())));
}

// Line 193
fn c16_l193_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c16_l193_action_invoke");
    let result = result_object
        .instance
        .call("local-mixed", &[])
        .expect("Missing result in c16_l193_action_invoke");
    assert_eq!(result, Some(Value::F64((0.0f64).to_bits())));
}

// Line 196
fn c17_l196_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c17_l196_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-first-i32",
            &[Value::I32(2 as i32), Value::I32(3 as i32)],
        )
        .expect("Missing result in c17_l196_action_invoke");
    assert_eq!(result, Some(Value::I32(2 as i32)));
}

// Line 199
fn c18_l199_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c18_l199_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-first-i64",
            &[Value::I64(2 as i64), Value::I64(3 as i64)],
        )
        .expect("Missing result in c18_l199_action_invoke");
    assert_eq!(result, Some(Value::I64(2 as i64)));
}

// Line 202
fn c19_l202_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c19_l202_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-first-f32",
            &[
                Value::F32((2.0f32).to_bits()),
                Value::F32((3.0f32).to_bits()),
            ],
        )
        .expect("Missing result in c19_l202_action_invoke");
    assert_eq!(result, Some(Value::F32((2.0f32).to_bits())));
}

// Line 205
fn c20_l205_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c20_l205_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-first-f64",
            &[
                Value::F64((2.0f64).to_bits()),
                Value::F64((3.0f64).to_bits()),
            ],
        )
        .expect("Missing result in c20_l205_action_invoke");
    assert_eq!(result, Some(Value::F64((2.0f64).to_bits())));
}

// Line 208
fn c21_l208_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c21_l208_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-second-i32",
            &[Value::I32(2 as i32), Value::I32(3 as i32)],
        )
        .expect("Missing result in c21_l208_action_invoke");
    assert_eq!(result, Some(Value::I32(3 as i32)));
}

// Line 211
fn c22_l211_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c22_l211_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-second-i64",
            &[Value::I64(2 as i64), Value::I64(3 as i64)],
        )
        .expect("Missing result in c22_l211_action_invoke");
    assert_eq!(result, Some(Value::I64(3 as i64)));
}

// Line 214
fn c23_l214_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c23_l214_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-second-f32",
            &[
                Value::F32((2.0f32).to_bits()),
                Value::F32((3.0f32).to_bits()),
            ],
        )
        .expect("Missing result in c23_l214_action_invoke");
    assert_eq!(result, Some(Value::F32((3.0f32).to_bits())));
}

// Line 217
fn c24_l217_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c24_l217_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-second-f64",
            &[
                Value::F64((2.0f64).to_bits()),
                Value::F64((3.0f64).to_bits()),
            ],
        )
        .expect("Missing result in c24_l217_action_invoke");
    assert_eq!(result, Some(Value::F64((3.0f64).to_bits())));
}

// Line 221
fn c25_l221_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c25_l221_action_invoke");
    let result = result_object
        .instance
        .call(
            "param-mixed",
            &[
                Value::F32((1.0f32).to_bits()),
                Value::I32(2 as i32),
                Value::I64(3 as i64),
                Value::I32(4 as i32),
                Value::F64((5.5f64).to_bits()),
                Value::I32(6 as i32),
            ],
        )
        .expect("Missing result in c25_l221_action_invoke");
    assert_eq!(result, Some(Value::F64((5.5f64).to_bits())));
}

// Line 228
fn c26_l228_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c26_l228_action_invoke");
    let result = result_object
        .instance
        .call("empty", &[])
        .expect("Missing result in c26_l228_action_invoke");
    assert_eq!(result, None);
}

// Line 229
fn c27_l229_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c27_l229_action_invoke");
    let result = result_object
        .instance
        .call("value-void", &[])
        .expect("Missing result in c27_l229_action_invoke");
    assert_eq!(result, None);
}

// Line 230
fn c28_l230_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c28_l230_action_invoke");
    let result = result_object
        .instance
        .call("value-i32", &[])
        .expect("Missing result in c28_l230_action_invoke");
    assert_eq!(result, Some(Value::I32(77 as i32)));
}

// Line 231
fn c29_l231_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c29_l231_action_invoke");
    let result = result_object
        .instance
        .call("value-i64", &[])
        .expect("Missing result in c29_l231_action_invoke");
    assert_eq!(result, Some(Value::I64(7777 as i64)));
}

// Line 232
fn c30_l232_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c30_l232_action_invoke");
    let result = result_object
        .instance
        .call("value-f32", &[])
        .expect("Missing result in c30_l232_action_invoke");
    assert_eq!(result, Some(Value::F32((77.7f32).to_bits())));
}

// Line 233
fn c31_l233_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c31_l233_action_invoke");
    let result = result_object
        .instance
        .call("value-f64", &[])
        .expect("Missing result in c31_l233_action_invoke");
    assert_eq!(result, Some(Value::F64((77.77f64).to_bits())));
}

// Line 234
fn c32_l234_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c32_l234_action_invoke");
    let result = result_object
        .instance
        .call("value-block-void", &[])
        .expect("Missing result in c32_l234_action_invoke");
    assert_eq!(result, None);
}

// Line 235
fn c33_l235_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c33_l235_action_invoke");
    let result = result_object
        .instance
        .call("value-block-i32", &[])
        .expect("Missing result in c33_l235_action_invoke");
    assert_eq!(result, Some(Value::I32(77 as i32)));
}

// Line 237
fn c34_l237_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c34_l237_action_invoke");
    let result = result_object
        .instance
        .call("return-empty", &[])
        .expect("Missing result in c34_l237_action_invoke");
    assert_eq!(result, None);
}

// Line 238
fn c35_l238_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c35_l238_action_invoke");
    let result = result_object
        .instance
        .call("return-i32", &[])
        .expect("Missing result in c35_l238_action_invoke");
    assert_eq!(result, Some(Value::I32(78 as i32)));
}

// Line 239
fn c36_l239_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c36_l239_action_invoke");
    let result = result_object
        .instance
        .call("return-i64", &[])
        .expect("Missing result in c36_l239_action_invoke");
    assert_eq!(result, Some(Value::I64(7878 as i64)));
}

// Line 240
fn c37_l240_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c37_l240_action_invoke");
    let result = result_object
        .instance
        .call("return-f32", &[])
        .expect("Missing result in c37_l240_action_invoke");
    assert_eq!(result, Some(Value::F32((78.7f32).to_bits())));
}

// Line 241
fn c38_l241_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c38_l241_action_invoke");
    let result = result_object
        .instance
        .call("return-f64", &[])
        .expect("Missing result in c38_l241_action_invoke");
    assert_eq!(result, Some(Value::F64((78.78f64).to_bits())));
}

// Line 242
fn c39_l242_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c39_l242_action_invoke");
    let result = result_object
        .instance
        .call("return-block-i32", &[])
        .expect("Missing result in c39_l242_action_invoke");
    assert_eq!(result, Some(Value::I32(77 as i32)));
}

// Line 244
fn c40_l244_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c40_l244_action_invoke");
    let result = result_object
        .instance
        .call("break-empty", &[])
        .expect("Missing result in c40_l244_action_invoke");
    assert_eq!(result, None);
}

// Line 245
fn c41_l245_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c41_l245_action_invoke");
    let result = result_object
        .instance
        .call("break-i32", &[])
        .expect("Missing result in c41_l245_action_invoke");
    assert_eq!(result, Some(Value::I32(79 as i32)));
}

// Line 246
fn c42_l246_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c42_l246_action_invoke");
    let result = result_object
        .instance
        .call("break-i64", &[])
        .expect("Missing result in c42_l246_action_invoke");
    assert_eq!(result, Some(Value::I64(7979 as i64)));
}

// Line 247
fn c43_l247_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c43_l247_action_invoke");
    let result = result_object
        .instance
        .call("break-f32", &[])
        .expect("Missing result in c43_l247_action_invoke");
    assert_eq!(result, Some(Value::F32((79.9f32).to_bits())));
}

// Line 248
fn c44_l248_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c44_l248_action_invoke");
    let result = result_object
        .instance
        .call("break-f64", &[])
        .expect("Missing result in c44_l248_action_invoke");
    assert_eq!(result, Some(Value::F64((79.79f64).to_bits())));
}

// Line 249
fn c45_l249_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c45_l249_action_invoke");
    let result = result_object
        .instance
        .call("break-block-i32", &[])
        .expect("Missing result in c45_l249_action_invoke");
    assert_eq!(result, Some(Value::I32(77 as i32)));
}

// Line 251
fn c46_l251_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c46_l251_action_invoke");
    let result = result_object
        .instance
        .call("break-br_if-empty", &[Value::I32(0 as i32)])
        .expect("Missing result in c46_l251_action_invoke");
    assert_eq!(result, None);
}

// Line 252
fn c47_l252_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c47_l252_action_invoke");
    let result = result_object
        .instance
        .call("break-br_if-empty", &[Value::I32(2 as i32)])
        .expect("Missing result in c47_l252_action_invoke");
    assert_eq!(result, None);
}

// Line 253
fn c48_l253_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c48_l253_action_invoke");
    let result = result_object
        .instance
        .call("break-br_if-num", &[Value::I32(0 as i32)])
        .expect("Missing result in c48_l253_action_invoke");
    assert_eq!(result, Some(Value::I32(51 as i32)));
}

// Line 254
fn c49_l254_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c49_l254_action_invoke");
    let result = result_object
        .instance
        .call("break-br_if-num", &[Value::I32(1 as i32)])
        .expect("Missing result in c49_l254_action_invoke");
    assert_eq!(result, Some(Value::I32(50 as i32)));
}

// Line 256
fn c50_l256_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c50_l256_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-empty", &[Value::I32(0 as i32)])
        .expect("Missing result in c50_l256_action_invoke");
    assert_eq!(result, None);
}

// Line 257
fn c51_l257_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c51_l257_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-empty", &[Value::I32(1 as i32)])
        .expect("Missing result in c51_l257_action_invoke");
    assert_eq!(result, None);
}

// Line 258
fn c52_l258_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c52_l258_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-empty", &[Value::I32(5 as i32)])
        .expect("Missing result in c52_l258_action_invoke");
    assert_eq!(result, None);
}

// Line 259
fn c53_l259_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c53_l259_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-empty", &[Value::I32(-1 as i32)])
        .expect("Missing result in c53_l259_action_invoke");
    assert_eq!(result, None);
}

// Line 260
fn c54_l260_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c54_l260_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-num", &[Value::I32(0 as i32)])
        .expect("Missing result in c54_l260_action_invoke");
    assert_eq!(result, Some(Value::I32(50 as i32)));
}

// Line 261
fn c55_l261_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c55_l261_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-num", &[Value::I32(1 as i32)])
        .expect("Missing result in c55_l261_action_invoke");
    assert_eq!(result, Some(Value::I32(50 as i32)));
}

// Line 262
fn c56_l262_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c56_l262_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-num", &[Value::I32(10 as i32)])
        .expect("Missing result in c56_l262_action_invoke");
    assert_eq!(result, Some(Value::I32(50 as i32)));
}

// Line 263
fn c57_l263_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c57_l263_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-num", &[Value::I32(-100 as i32)])
        .expect("Missing result in c57_l263_action_invoke");
    assert_eq!(result, Some(Value::I32(50 as i32)));
}

// Line 264
fn c58_l264_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c58_l264_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-empty", &[Value::I32(0 as i32)])
        .expect("Missing result in c58_l264_action_invoke");
    assert_eq!(result, None);
}

// Line 265
fn c59_l265_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c59_l265_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-empty", &[Value::I32(1 as i32)])
        .expect("Missing result in c59_l265_action_invoke");
    assert_eq!(result, None);
}

// Line 266
fn c60_l266_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c60_l266_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-empty", &[Value::I32(3 as i32)])
        .expect("Missing result in c60_l266_action_invoke");
    assert_eq!(result, None);
}

// Line 267
fn c61_l267_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c61_l267_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-empty", &[Value::I32(-2 as i32)])
        .expect("Missing result in c61_l267_action_invoke");
    assert_eq!(result, None);
}

// Line 269
fn c62_l269_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c62_l269_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-num", &[Value::I32(0 as i32)])
        .expect("Missing result in c62_l269_action_invoke");
    assert_eq!(result, Some(Value::I32(52 as i32)));
}

// Line 272
fn c63_l272_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c63_l272_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-num", &[Value::I32(1 as i32)])
        .expect("Missing result in c63_l272_action_invoke");
    assert_eq!(result, Some(Value::I32(50 as i32)));
}

// Line 275
fn c64_l275_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c64_l275_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-num", &[Value::I32(2 as i32)])
        .expect("Missing result in c64_l275_action_invoke");
    assert_eq!(result, Some(Value::I32(52 as i32)));
}

// Line 278
fn c65_l278_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c65_l278_action_invoke");
    let result = result_object
        .instance
        .call("break-br_table-nested-num", &[Value::I32(-3 as i32)])
        .expect("Missing result in c65_l278_action_invoke");
    assert_eq!(result, Some(Value::I32(52 as i32)));
}

// Line 281
fn c66_l281_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c66_l281_action_invoke");
    let result = result_object
        .instance
        .call("init-local-i32", &[])
        .expect("Missing result in c66_l281_action_invoke");
    assert_eq!(result, Some(Value::I32(0 as i32)));
}

// Line 282
fn c67_l282_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c67_l282_action_invoke");
    let result = result_object
        .instance
        .call("init-local-i64", &[])
        .expect("Missing result in c67_l282_action_invoke");
    assert_eq!(result, Some(Value::I64(0 as i64)));
}

// Line 283
fn c68_l283_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c68_l283_action_invoke");
    let result = result_object
        .instance
        .call("init-local-f32", &[])
        .expect("Missing result in c68_l283_action_invoke");
    assert_eq!(result, Some(Value::F32((0.0f32).to_bits())));
}

// Line 284
fn c69_l284_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c69_l284_action_invoke");
    let result = result_object
        .instance
        .call("init-local-f64", &[])
        .expect("Missing result in c69_l284_action_invoke");
    assert_eq!(result, Some(Value::F64((0.0f64).to_bits())));
}

// Line 289

#[test]
fn test_module_1() {
    let mut result_object = create_module_1();
    // We group the calls together
    start_module_1(&mut result_object);
    c1_l171_action_invoke(&mut result_object);
    c2_l172_action_invoke(&mut result_object);
    c3_l173_action_invoke(&mut result_object);
    c4_l175_action_invoke(&mut result_object);
    c5_l178_action_invoke(&mut result_object);
    c6_l179_action_invoke(&mut result_object);
    c7_l181_action_invoke(&mut result_object);
    c8_l185_action_invoke(&mut result_object);
    c9_l186_action_invoke(&mut result_object);
    c10_l187_action_invoke(&mut result_object);
    c11_l188_action_invoke(&mut result_object);
    c12_l189_action_invoke(&mut result_object);
    c13_l190_action_invoke(&mut result_object);
    c14_l191_action_invoke(&mut result_object);
    c15_l192_action_invoke(&mut result_object);
    c16_l193_action_invoke(&mut result_object);
    c17_l196_action_invoke(&mut result_object);
    c18_l199_action_invoke(&mut result_object);
    c19_l202_action_invoke(&mut result_object);
    c20_l205_action_invoke(&mut result_object);
    c21_l208_action_invoke(&mut result_object);
    c22_l211_action_invoke(&mut result_object);
    c23_l214_action_invoke(&mut result_object);
    c24_l217_action_invoke(&mut result_object);
    c25_l221_action_invoke(&mut result_object);
    c26_l228_action_invoke(&mut result_object);
    c27_l229_action_invoke(&mut result_object);
    c28_l230_action_invoke(&mut result_object);
    c29_l231_action_invoke(&mut result_object);
    c30_l232_action_invoke(&mut result_object);
    c31_l233_action_invoke(&mut result_object);
    c32_l234_action_invoke(&mut result_object);
    c33_l235_action_invoke(&mut result_object);
    c34_l237_action_invoke(&mut result_object);
    c35_l238_action_invoke(&mut result_object);
    c36_l239_action_invoke(&mut result_object);
    c37_l240_action_invoke(&mut result_object);
    c38_l241_action_invoke(&mut result_object);
    c39_l242_action_invoke(&mut result_object);
    c40_l244_action_invoke(&mut result_object);
    c41_l245_action_invoke(&mut result_object);
    c42_l246_action_invoke(&mut result_object);
    c43_l247_action_invoke(&mut result_object);
    c44_l248_action_invoke(&mut result_object);
    c45_l249_action_invoke(&mut result_object);
    c46_l251_action_invoke(&mut result_object);
    c47_l252_action_invoke(&mut result_object);
    c48_l253_action_invoke(&mut result_object);
    c49_l254_action_invoke(&mut result_object);
    c50_l256_action_invoke(&mut result_object);
    c51_l257_action_invoke(&mut result_object);
    c52_l258_action_invoke(&mut result_object);
    c53_l259_action_invoke(&mut result_object);
    c54_l260_action_invoke(&mut result_object);
    c55_l261_action_invoke(&mut result_object);
    c56_l262_action_invoke(&mut result_object);
    c57_l263_action_invoke(&mut result_object);
    c58_l264_action_invoke(&mut result_object);
    c59_l265_action_invoke(&mut result_object);
    c60_l266_action_invoke(&mut result_object);
    c61_l267_action_invoke(&mut result_object);
    c62_l269_action_invoke(&mut result_object);
    c63_l272_action_invoke(&mut result_object);
    c64_l275_action_invoke(&mut result_object);
    c65_l278_action_invoke(&mut result_object);
    c66_l281_action_invoke(&mut result_object);
    c67_l282_action_invoke(&mut result_object);
    c68_l283_action_invoke(&mut result_object);
    c69_l284_action_invoke(&mut result_object);
}
fn create_module_2() -> ResultObject {
    let module_str = "(module
      (type (;0;) (func (param i32)))
      (type (;1;) (func (result f64)))
      (type (;2;) (func))
      (func (;0;) (type 1) (result f64)
        f64.const 0x0p+0 (;=0;))
      (func (;1;) (type 0) (param i32))
      (func (;2;) (type 0) (param i32))
      (func (;3;) (type 1) (result f64)
        f64.const 0x0p+0 (;=0;))
      (func (;4;) (type 2)
        i32.const 0
        call 2
        call 3
        drop))
    ";
    let wasm_binary = wat2wasm(module_str.as_bytes()).expect("WAST not valid or malformed");
    instantiate(&wasm_binary[..], &spectest_importobject(), None)
        .expect("WASM can't be instantiated")
}

fn start_module_2(result_object: &mut ResultObject) {
    // TODO Review is explicit start needed? Start now called in runtime::Instance::new()
    //result_object.instance.start();
}

// Line 303
#[test]
fn c71_l303_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 9, 2, 96, 1, 127, 0, 96, 0, 1, 124, 3, 5, 4, 1, 0, 1, 2,
        10, 31, 4, 11, 0, 68, 0, 0, 0, 0, 0, 0, 0, 0, 11, 2, 0, 11, 11, 0, 68, 0, 0, 0, 0, 0, 0,
        240, 63, 11, 2, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 315

#[test]
fn test_module_2() {
    let mut result_object = create_module_2();
    // We group the calls together
    start_module_2(&mut result_object);
}
fn create_module_3() -> ResultObject {
    let module_str = "(module
      (type (;0;) (func))
      (type (;1;) (func))
      (type (;2;) (func (param i64 i64 f64 i64 f64 i64 f32 i32)))
      (type (;3;) (func (param f64 i64 f64 i64 f64 i64 f32 i32)))
      (func (;0;) (type 0))
      (func (;1;) (type 3) (param f64 i64 f64 i64 f64 i64 f32 i32))
      (func (;2;) (type 0))
      (func (;3;) (type 3) (param f64 i64 f64 i64 f64 i64 f32 i32))
      (func (;4;) (type 3) (param f64 i64 f64 i64 f64 i64 f32 i32))
      (func (;5;) (type 2) (param i64 i64 f64 i64 f64 i64 f32 i32))
      (func (;6;) (type 2) (param i64 i64 f64 i64 f64 i64 f32 i32))
      (func (;7;) (type 0)
        i32.const 1
        call_indirect (type 0)
        i32.const 4
        call_indirect (type 0))
      (func (;8;) (type 0)
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f32.const 0x0p+0 (;=0;)
        i32.const 0
        i32.const 0
        call_indirect (type 3)
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f32.const 0x0p+0 (;=0;)
        i32.const 0
        i32.const 2
        call_indirect (type 3)
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f32.const 0x0p+0 (;=0;)
        i32.const 0
        i32.const 3
        call_indirect (type 3))
      (func (;9;) (type 0)
        i32.const 1
        call_indirect (type 1))
      (func (;10;) (type 0)
        i64.const 0
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f32.const 0x0p+0 (;=0;)
        i32.const 0
        i32.const 5
        call_indirect (type 2)
        i64.const 0
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f64.const 0x0p+0 (;=0;)
        i64.const 0
        f32.const 0x0p+0 (;=0;)
        i32.const 0
        i32.const 6
        call_indirect (type 2))
      (table (;0;) 7 7 anyfunc)
      (export \"signature-explicit-reused\" (func 7))
      (export \"signature-implicit-reused\" (func 8))
      (export \"signature-explicit-duplicate\" (func 9))
      (export \"signature-implicit-duplicate\" (func 10))
      (elem (;0;) (i32.const 0) 4 2 1 4 0 5 6))
    ";
    let wasm_binary = wat2wasm(module_str.as_bytes()).expect("WAST not valid or malformed");
    instantiate(&wasm_binary[..], &spectest_importobject(), None)
        .expect("WASM can't be instantiated")
}

fn start_module_3(result_object: &mut ResultObject) {
    // TODO Review is explicit start needed? Start now called in runtime::Instance::new()
    //result_object.instance.start();
}

// Line 378
fn c73_l378_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c73_l378_action_invoke");
    let result = result_object
        .instance
        .call("signature-explicit-reused", &[])
        .expect("Missing result in c73_l378_action_invoke");
    assert_eq!(result, None);
}

// Line 379
fn c74_l379_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c74_l379_action_invoke");
    let result = result_object
        .instance
        .call("signature-implicit-reused", &[])
        .expect("Missing result in c74_l379_action_invoke");
    assert_eq!(result, None);
}

// Line 380
fn c75_l380_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c75_l380_action_invoke");
    let result = result_object
        .instance
        .call("signature-explicit-duplicate", &[])
        .expect("Missing result in c75_l380_action_invoke");
    assert_eq!(result, None);
}

// Line 381
fn c76_l381_action_invoke(result_object: &mut ResultObject) {
    println!("Executing function {}", "c76_l381_action_invoke");
    let result = result_object
        .instance
        .call("signature-implicit-duplicate", &[])
        .expect("Missing result in c76_l381_action_invoke");
    assert_eq!(result, None);
}

// Line 387
#[test]
fn c77_l387_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 41,
        32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50, 41, 32, 40, 112, 97, 114, 97, 109,
        32, 105, 51, 50, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 394
#[test]
fn c78_l394_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 112, 97, 114, 97, 109, 32, 105, 51, 50, 41, 32,
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 41, 32, 40, 114, 101, 115, 117, 108, 116,
        32, 105, 51, 50, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 401
#[test]
fn c79_l401_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 112, 97, 114, 97, 109, 32, 105, 51, 50, 41, 32,
        40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50, 41, 32, 40, 116, 121, 112, 101, 32, 36,
        115, 105, 103, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 408
#[test]
fn c80_l408_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 32, 40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 41, 32, 40, 112, 97, 114, 97, 109,
        32, 105, 51, 50, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 415
#[test]
fn c81_l415_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 32, 40, 112, 97, 114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 116, 121, 112, 101, 32, 36,
        115, 105, 103, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110, 115, 116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 422
#[test]
fn c82_l422_assert_malformed() {
    let wasm_binary = [
        40, 102, 117, 110, 99, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50, 41, 32, 40,
        112, 97, 114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110, 115,
        116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 429
#[test]
fn c83_l429_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 41, 41, 40, 102,
        117, 110, 99, 32, 40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 41, 32, 40, 114, 101, 115,
        117, 108, 116, 32, 105, 51, 50, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110, 115, 116, 32,
        48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 436
#[test]
fn c84_l436_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 41,
        32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50, 41, 32, 40, 105, 51, 50, 46, 99,
        111, 110, 115, 116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 443
#[test]
fn c85_l443_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50,
        41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 41,
        32, 40, 112, 97, 114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 105, 51, 50, 46, 99, 111, 110,
        115, 116, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 450
#[test]
fn c86_l450_assert_malformed() {
    let wasm_binary = [
        40, 116, 121, 112, 101, 32, 36, 115, 105, 103, 32, 40, 102, 117, 110, 99, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 32, 105, 51, 50, 41, 32, 40, 114, 101, 115, 117, 108, 116,
        32, 105, 51, 50, 41, 41, 41, 40, 102, 117, 110, 99, 32, 40, 116, 121, 112, 101, 32, 36,
        115, 105, 103, 41, 32, 40, 112, 97, 114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 114, 101,
        115, 117, 108, 116, 32, 105, 51, 50, 41, 32, 40, 117, 110, 114, 101, 97, 99, 104, 97, 98,
        108, 101, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 461
#[test]
fn c87_l461_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 126, 3, 2, 1, 0, 10, 8, 1, 6, 1, 1, 127,
        32, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 465
#[test]
fn c88_l465_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 1, 1, 125, 32, 0,
        69, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 469
#[test]
fn c89_l469_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 11, 1, 9, 2, 1, 124, 1,
        126, 32, 1, 154, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 477
#[test]
fn c90_l477_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 126, 3, 2, 1, 0, 10, 6, 1, 4, 0, 32,
        0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 481
#[test]
fn c91_l481_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 1, 125, 0, 3, 2, 1, 0, 10, 7, 1, 5, 0, 32, 0, 69,
        11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 485
#[test]
fn c92_l485_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 2, 124, 126, 0, 3, 2, 1, 0, 10, 7, 1, 5, 0, 32,
        1, 154, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 493
#[test]
fn c93_l493_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 0, 2, 127, 127, 3, 2, 1, 0, 10, 5, 1, 3, 0, 0,
        11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 497
#[test]
fn c94_l497_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 0, 2, 127, 127, 3, 2, 1, 0, 10, 5, 1, 3, 0, 0,
        11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 506
#[test]
fn c95_l506_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 4, 1, 2, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 510
#[test]
fn c96_l510_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 126, 3, 2, 1, 0, 10, 4, 1, 2, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 514
#[test]
fn c97_l514_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 125, 3, 2, 1, 0, 10, 4, 1, 2, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 518
#[test]
fn c98_l518_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 124, 3, 2, 1, 0, 10, 4, 1, 2, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 523
#[test]
fn c99_l523_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 5, 1, 3, 0, 1, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 529
#[test]
fn c100_l529_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 6, 1, 4, 0, 65, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 535
#[test]
fn c101_l535_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 9, 1, 7, 0, 67, 0, 0,
        0, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 542
#[test]
fn c102_l542_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 5, 1, 3, 0, 15, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 548
#[test]
fn c103_l548_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 6, 1, 4, 0, 1, 15, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 554
#[test]
fn c104_l554_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 7, 1, 5, 0, 66, 0, 15,
        11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 561
#[test]
fn c105_l561_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 7, 1, 5, 0, 15, 65, 1,
        11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 567
#[test]
fn c106_l567_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 8, 1, 6, 0, 1, 15, 65,
        1, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 573
#[test]
fn c107_l573_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 9, 1, 7, 0, 66, 1, 15,
        65, 1, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 579
#[test]
fn c108_l579_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 10, 1, 8, 0, 66, 1,
        15, 65, 1, 15, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 586
#[test]
fn c109_l586_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 6, 1, 4, 0, 12, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 592
#[test]
fn c110_l592_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 11, 1, 9, 0, 67, 0, 0,
        0, 0, 12, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 598
#[test]
fn c111_l598_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 8, 1, 6, 0, 12, 0, 65,
        1, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 604
#[test]
fn c112_l604_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 10, 1, 8, 0, 66, 1,
        12, 0, 65, 1, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 610
#[test]
fn c113_l610_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 12, 1, 10, 0, 66, 1,
        12, 0, 65, 1, 12, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 617
#[test]
fn c114_l617_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 13, 1, 11, 0, 2, 64,
        12, 1, 11, 65, 1, 12, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 623
#[test]
fn c115_l623_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 14, 1, 12, 0, 2, 64,
        1, 12, 1, 11, 65, 1, 12, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 629
#[test]
fn c116_l629_assert_invalid() {
    let wasm_binary = [
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 127, 3, 2, 1, 0, 10, 15, 1, 13, 0, 2, 64,
        66, 1, 12, 1, 11, 65, 1, 12, 0, 11,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is invalid"
    );
}

// Line 639
#[test]
fn c117_l639_assert_malformed() {
    let wasm_binary = [
        40, 102, 117, 110, 99, 32, 40, 110, 111, 112, 41, 32, 40, 108, 111, 99, 97, 108, 32, 105,
        51, 50, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 643
#[test]
fn c118_l643_assert_malformed() {
    let wasm_binary = [
        40, 102, 117, 110, 99, 32, 40, 110, 111, 112, 41, 32, 40, 112, 97, 114, 97, 109, 32, 105,
        51, 50, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 647
#[test]
fn c119_l647_assert_malformed() {
    let wasm_binary = [
        40, 102, 117, 110, 99, 32, 40, 110, 111, 112, 41, 32, 40, 114, 101, 115, 117, 108, 116, 32,
        105, 51, 50, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 651
#[test]
fn c120_l651_assert_malformed() {
    let wasm_binary = [
        40, 102, 117, 110, 99, 32, 40, 108, 111, 99, 97, 108, 32, 105, 51, 50, 41, 32, 40, 112, 97,
        114, 97, 109, 32, 105, 51, 50, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 655
#[test]
fn c121_l655_assert_malformed() {
    let wasm_binary = [
        40, 102, 117, 110, 99, 32, 40, 108, 111, 99, 97, 108, 32, 105, 51, 50, 41, 32, 40, 114,
        101, 115, 117, 108, 116, 32, 105, 51, 50, 41, 32, 40, 103, 101, 116, 95, 108, 111, 99, 97,
        108, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

// Line 659
#[test]
fn c122_l659_assert_malformed() {
    let wasm_binary = [
        40, 102, 117, 110, 99, 32, 40, 114, 101, 115, 117, 108, 116, 32, 105, 51, 50, 41, 32, 40,
        112, 97, 114, 97, 109, 32, 105, 51, 50, 41, 32, 40, 103, 101, 116, 95, 108, 111, 99, 97,
        108, 32, 48, 41, 41,
    ];
    let compilation = compile(&wasm_binary.to_vec());
    assert!(
        compilation.is_err(),
        "WASM should not compile as is malformed"
    );
}

#[test]
fn test_module_3() {
    let mut result_object = create_module_3();
    // We group the calls together
    start_module_3(&mut result_object);
    c73_l378_action_invoke(&mut result_object);
    c74_l379_action_invoke(&mut result_object);
    c75_l380_action_invoke(&mut result_object);
    c76_l381_action_invoke(&mut result_object);
}
