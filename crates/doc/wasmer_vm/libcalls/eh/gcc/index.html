<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of personality function and unwinding support for Wasmer."><title>wasmer_vm::libcalls::eh::gcc - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="wasmer_vm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../wasmer_vm/index.html">wasmer_<wbr>vm</a><span class="version">7.0.0-alpha.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module gcc</a></h2><h3><a href="#macros">Module Items</a></h3><ul class="block"><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#statics" title="Statics">Statics</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In wasmer_<wbr>vm::<wbr>libcalls::<wbr>eh</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">wasmer_vm</a>::<wbr><a href="../../index.html">libcalls</a>::<wbr><a href="../index.html">eh</a></div><h1>Module <span>gcc</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../src/wasmer_vm/libcalls/eh/gcc.rs.html#1-324">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of personality function and unwinding support for Wasmer.</p>
<p>On a native platform, when an exception is thrown, the type info of the
exception is known, and can be matched against the LSDA table within the
personality function (e.g. __gxx_personality_v0 for Itanium ABI).</p>
<p>However, in WASM, the exception â€œtypeâ€ can change between compilation
and instantiation because tags can be imported from other modules. Also,
a single module can be instantiated many times, but all instances share
the same code, differing only in their VMContext data. This means that,
to be able to match the thrown exception against the expected tag in
catch clauses, we need to go through the VMContext of the specific instance
to which the stack frame belongs; nothing else can tell us exactly which
instance weâ€™re currently looking at, including the IP which will be the
same for all instances of the same module.</p>
<p>To achieve this, we use a two-stage personality function. The first stage
is the normal personality function which is called by libunwind; this
function always catches the exception as long as itâ€™s a Wasmer exception,
without looking at the specific tags. Afterwards, control is transferred
to the moduleâ€™s landing pad, which can load its VMContext and pass it to
the second stage of the personality function. Afterwards, the second stage
can take the â€œlocal tag numberâ€ (the tag index as seen from the WASM
moduleâ€™s point of view) from the LSDA and translate it to the unique tag
within the Store, and match that against the thrown exceptionâ€™s tag.</p>
<p>The throw function also uses the VMContext of its own instance to get the
unique tag from the Store, and uses that as the final exception tag.</p>
<p>Itâ€™s important to note that we canâ€™t count on libunwind behaving properly
if we make calls from the second stage of the personality function; this is
why the first stage has to extract all the data necessary for the second
stage and place it in the exception object. The second stage will clear
out the data before returning, so further stack frames will not get stale
data by mistake.</p>
</div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.log.html" title="macro wasmer_vm::libcalls::eh::gcc::log">log</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.CurrentFrameInfo.html" title="struct wasmer_vm::libcalls::eh::gcc::CurrentFrameInfo">Current<wbr>Frame<wbr>Info</a></dt><dt><a class="struct" href="struct.UwExceptionWrapper.html" title="struct wasmer_vm::libcalls::eh::gcc::UwExceptionWrapper">UwException<wbr>Wrapper</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.CATCH_ALL_TAG_VALUE.html" title="constant wasmer_vm::libcalls::eh::gcc::CATCH_ALL_TAG_VALUE">CATCH_<wbr>ALL_<wbr>TAG_<wbr>VALUE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="constant" href="constant.NO_MATCH_FOUND_TAG_VALUE.html" title="constant wasmer_vm::libcalls::eh::gcc::NO_MATCH_FOUND_TAG_VALUE">NO_<wbr>MATCH_<wbr>FOUND_<wbr>TAG_<wbr>VALUE</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="constant" href="constant.UNWIND_DATA_REG.html" title="constant wasmer_vm::libcalls::eh::gcc::UNWIND_DATA_REG">UNWIND_<wbr>DATA_<wbr>REG</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt><dt><a class="constant" href="constant.WASMER_EXCEPTION_CLASS.html" title="constant wasmer_vm::libcalls::eh::gcc::WASMER_EXCEPTION_CLASS">WASMER_<wbr>EXCEPTION_<wbr>CLASS</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="statics" class="section-header">Statics<a href="#statics" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="static" href="static.CANARY.html" title="static wasmer_vm::libcalls::eh::gcc::CANARY">CANARY</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.deallocate_exception.html" title="fn wasmer_vm::libcalls::eh::gcc::deallocate_exception">deallocate_<wbr>exception</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> <sup title="unsafe function">âš </sup></dt><dt><a class="fn" href="fn.delete_exception.html" title="fn wasmer_vm::libcalls::eh::gcc::delete_exception">delete_<wbr>exception</a><sup title="unsafe function">âš </sup></dt><dt><a class="fn" href="fn.find_eh_action.html" title="fn wasmer_vm::libcalls::eh::gcc::find_eh_action">find_<wbr>eh_<wbr>action</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> <sup title="unsafe function">âš </sup></dt><dt><a class="fn" href="fn.read_exnref.html" title="fn wasmer_vm::libcalls::eh::gcc::read_exnref">read_<wbr>exnref</a><sup title="unsafe function">âš </sup></dt><dt><a class="fn" href="fn.throw.html" title="fn wasmer_vm::libcalls::eh::gcc::throw">throw</a><sup title="unsafe function">âš </sup></dt><dd>Safety</dd><dt><a class="fn" href="fn.wasmer_eh_personality.html" title="fn wasmer_vm::libcalls::eh::gcc::wasmer_eh_personality">wasmer_<wbr>eh_<wbr>personality</a><sup title="unsafe function">âš </sup></dt><dd>The implementation of Wasmerâ€™s personality function.</dd><dt><a class="fn" href="fn.wasmer_eh_personality2.html" title="fn wasmer_vm::libcalls::eh::gcc::wasmer_eh_personality2">wasmer_<wbr>eh_<wbr>personality2</a><sup title="unsafe function">âš </sup></dt><dd>The second stage of the personality function. See module level documentation
for an explanation of the exact procedure used during unwinding.</dd></dl></section></div></main></body></html>