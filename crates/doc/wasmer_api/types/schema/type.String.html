<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `String` type in crate `wasmer_api`."><title>String in wasmer_api::types::schema - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-fa3bb1812debf86c.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="wasmer_api" data-themes="" data-resource-suffix="" data-rustdoc-version="1.74.1 (a28077b28 2023-12-04)" data-channel="1.74.1" data-search-js="search-8be46b629f5f14a8.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-c5bd66d33317d69f.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../wasmer_api/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a></nav><nav class="sidebar"><a class="logo-container" href="../../../wasmer_api/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">String</a></h2><div class="sidebar-elems"><section><h3><a href="#aliased-type">Aliased type</a></h3><h3><a href="#fields">Fields</a></h3><ul class="block"><li><a href="#structfield.vec">vec</a></li></ul><h3><a href="#deref-methods-str">Methods from Deref&lt;Target=str&gt;</a></h3><ul class="block"><li><a href="#method.as_ascii">as_ascii</a></li><li><a href="#method.as_bytes">as_bytes</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.bytes">bytes</a></li><li><a href="#method.ceil_char_boundary">ceil_char_boundary</a></li><li><a href="#method.char_indices">char_indices</a></li><li><a href="#method.chars">chars</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.encode_utf16">encode_utf16</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.eq_ignore_ascii_case">eq_ignore_ascii_case</a></li><li><a href="#method.escape_debug">escape_debug</a></li><li><a href="#method.escape_default">escape_default</a></li><li><a href="#method.escape_unicode">escape_unicode</a></li><li><a href="#method.find">find</a></li><li><a href="#method.floor_char_boundary">floor_char_boundary</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.is_ascii">is_ascii</a></li><li><a href="#method.is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.len">len</a></li><li><a href="#method.lines">lines</a></li><li><a href="#method.lines_any">lines_any</a></li><li><a href="#method.match_indices">match_indices</a></li><li><a href="#method.matches">matches</a></li><li><a href="#method.parse">parse</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.rfind">rfind</a></li><li><a href="#method.rmatch_indices">rmatch_indices</a></li><li><a href="#method.rmatches">rmatches</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_once">rsplit_once</a></li><li><a href="#method.rsplit_terminator">rsplit_terminator</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.slice_unchecked">slice_unchecked</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_ascii_whitespace">split_ascii_whitespace</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_inclusive">split_inclusive</a></li><li><a href="#method.split_once">split_once</a></li><li><a href="#method.split_terminator">split_terminator</a></li><li><a href="#method.split_whitespace">split_whitespace</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix">strip_suffix</a></li><li><a href="#method.to_ascii_lowercase">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_uppercase">to_ascii_uppercase</a></li><li><a href="#method.to_lowercase">to_lowercase</a></li><li><a href="#method.to_uppercase">to_uppercase</a></li><li><a href="#method.trim">trim</a></li><li><a href="#method.trim_end">trim_end</a></li><li><a href="#method.trim_end_matches">trim_end_matches</a></li><li><a href="#method.trim_left">trim_left</a></li><li><a href="#method.trim_left_matches">trim_left_matches</a></li><li><a href="#method.trim_matches">trim_matches</a></li><li><a href="#method.trim_right">trim_right</a></li><li><a href="#method.trim_right_matches">trim_right_matches</a></li><li><a href="#method.trim_start">trim_start</a></li><li><a href="#method.trim_start_matches">trim_start_matches</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Deref-for-String">Deref</a></li><li><a href="#impl-Variable-for-String">Variable</a></li></ul></section><h2><a href="index.html">In wasmer_api::types::schema</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Type Alias <a href="../../index.html">wasmer_api</a>::<wbr><a href="../index.html">types</a>::<wbr><a href="index.html">schema</a>::<wbr><a class="type" href="#">String</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/wasmer_api/types.rs.html#2124">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub type String = <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>;</code></pre><h2 id="aliased-type" class="small-section-header">Aliased Type<a href="#aliased-type" class="anchor">Â§</a></h2><pre class="rust item-decl"><code>struct String {
    vec: <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>, <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;,
}</code></pre><h2 id="fields" class="fields small-section-header">Fields<a href="#fields" class="anchor">Â§</a></h2><span id="structfield.vec" class="structfield small-section-header"><a href="#structfield.vec" class="anchor field">Â§</a><code>vec: <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>, <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;</code></span><h2 id="deref-methods-str" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;</span><a href="#deref-methods-str" class="anchor">Â§</a></h2><div id="deref-methods-str-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#158">source</a></span><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>len = <span class="string">&quot;foo&quot;</span>.len();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, len);

<span class="macro">assert_eq!</span>(<span class="string">&quot;Æ’oo&quot;</span>.len(), <span class="number">4</span>); <span class="comment">// fancy f!
</span><span class="macro">assert_eq!</span>(<span class="string">&quot;Æ’oo&quot;</span>.chars().count(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#177">source</a></span><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;&quot;</span>;
<span class="macro">assert!</span>(s.is_empty());

<span class="kw">let </span>s = <span class="string">&quot;not empty&quot;</span>;
<span class="macro">assert!</span>(!s.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#207">source</a></span><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fn">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="macro">assert!</span>(s.is_char_boundary(<span class="number">0</span>));
<span class="comment">// start of `è€`
</span><span class="macro">assert!</span>(s.is_char_boundary(<span class="number">6</span>));
<span class="macro">assert!</span>(s.is_char_boundary(s.len()));

<span class="comment">// second byte of `Ã¶`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">2</span>));

<span class="comment">// third byte of `è€`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">8</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.floor_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#254">source</a><h4 class="code-header">pub fn <a href="#method.floor_char_boundary" class="fn">floor_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>This method can help you truncate a string so that itâ€™s still valid UTF-8, but doesnâ€™t
exceed a given number of bytes. Note that this is done purely at the character level
and can still visually split graphemes, even though the underlying characters arenâ€™t
split. For example, the emoji ğŸ§‘â€ğŸ”¬ (scientist) could be split so that the string only
includes ğŸ§‘ (person) instead.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">&quot;â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ&quot;</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.floor_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">&quot;â¤ï¸ğŸ§¡&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ceil_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#292">source</a><h4 class="code-header">pub fn <a href="#method.ceil_char_boundary" class="fn">ceil_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not below <code>index</code> where <code>is_char_boundary(x)</code> is <code>true</code>.</p>
<p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p>
<p>This method is the natural complement to <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method
for more details.</p>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">&quot;â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ&quot;</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.ceil_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">&quot;â¤ï¸ğŸ§¡ğŸ’›&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#318">source</a></span><h4 class="code-header">pub fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">â“˜</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="https://doc.rust-lang.org/1.74.1/core/str/converts/fn.from_utf8.html" title="fn core::str::converts::from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="string">&quot;bors&quot;</span>.as_bytes();
<span class="macro">assert_eq!</span>(<span class="string">b&quot;bors&quot;</span>, bytes);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#392">source</a></span><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.pointer.html">*const </a><a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="https://doc.rust-lang.org/1.74.1/std/primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Hello&quot;</span>;
<span class="kw">let </span>ptr = s.as_ptr();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#433">source</a></span><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/slice/index/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::index::SliceIndex::Output">Output</a>&gt;<span class="where fmt-newline">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = String::from(<span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;ğŸ—»&quot;</span>), v.get(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries
</span><span class="macro">assert!</span>(v.get(<span class="number">1</span>..).is_none());
<span class="macro">assert!</span>(v.get(..<span class="number">8</span>).is_none());

<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get(..<span class="number">42</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#497">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/slice/index/trait.SliceIndex.html#associatedtype.Output" title="type core::slice::index::SliceIndex::Output">Output</a><span class="where fmt-newline">where
    I: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/slice/index/trait.SliceIndex.html" title="trait core::slice::index::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;,</span></h4></section></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="string">&quot;ğŸ—»âˆˆğŸŒ&quot;</span>;
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸ—»&quot;</span>, v.get_unchecked(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;âˆˆ&quot;</span>, v.get_unchecked(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">&quot;ğŸŒ&quot;</span>, v.get_unchecked(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#583">source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fn">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html" title="primitive str"><code>str</code></a> and <a href="https://doc.rust-lang.org/1.74.1/core/ops/index/trait.Index.html" title="trait core::ops::index::Index"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>, s.slice_unchecked(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let </span>s = <span class="string">&quot;Hello, world!&quot;</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">&quot;world&quot;</span>, s.slice_unchecked(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#654">source</a></span><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; (&amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>)</h4></section></summary><div class="docblock"><p>Divide one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is
past the end of the last code point of the string slice.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;Per Martin-LÃ¶f&quot;</span>;

<span class="kw">let </span>(first, last) = s.split_at(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;Per&quot;</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">&quot; Martin-LÃ¶f&quot;</span>, last);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#762">source</a></span><h4 class="code-header">pub fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.Chars.html" title="struct core::str::iter::Chars">Chars</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p>
<p>Itâ€™s important to remember that <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rustâ€™s standard library, check crates.io instead.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let </span>count = word.chars().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>chars = word.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;g&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;o&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;d&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;b&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;e&#39;</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>y = <span class="string">&quot;yÌ†&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>chars = y.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;y&#39;</span>), chars.next()); <span class="comment">// not &#39;yÌ†&#39;
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;\u{0306}&#39;</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#819">source</a></span><h4 class="code-header">pub fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.CharIndices.html" title="struct core::str::iter::CharIndices">CharIndices</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both
these <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a> is
second.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">&quot;goodbye&quot;</span>;

<span class="kw">let </span>count = word.char_indices().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = word.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;g&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;o&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">&#39;o&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;d&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;b&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">&#39;y&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">&#39;e&#39;</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>yes = <span class="string">&quot;yÌ†es&quot;</span>;

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = yes.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">&#39;y&#39;</span>)), char_indices.next()); <span class="comment">// not (0, &#39;yÌ†&#39;)
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">&#39;\u{0306}&#39;</span>)), char_indices.next());

<span class="comment">// note the 3 here - the last character took up two bytes
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">&#39;e&#39;</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">&#39;s&#39;</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#842">source</a></span><h4 class="code-header">pub fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.Bytes.html" title="struct core::str::iter::Bytes">Bytes</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>An iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="string">&quot;bors&quot;</span>.bytes();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;b&#39;</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;o&#39;</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;r&#39;</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b&#39;s&#39;</span>), bytes.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, bytes.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#894">source</a></span><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fn">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.SplitWhitespace.html" title="struct core::str::iter::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot;A few words&quot;</span>.split_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot; Mary   had\ta\u{2009}little  \n\t lamb&quot;</span>.split_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>.split_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;   &quot;</span>.split_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#943">source</a></span><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fn">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.SplitAsciiWhitespace.html" title="struct core::str::iter::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>To split by Unicode <code>Whitespace</code> instead, use <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot;A few words&quot;</span>.split_ascii_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;A&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;few&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;words&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>All kinds of ASCII whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">&quot; Mary   had\ta little  \n\t lamb&quot;</span>.split_ascii_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;Mary&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;had&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;a&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;little&quot;</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;lamb&quot;</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;&quot;</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;   &quot;</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#996">source</a></span><h4 class="code-header">pub fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.Lines.html" title="struct core::str::iter::Lines">Lines</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>An iterator over the lines of a string, as string slices.</p>
<p>Lines are split at line endings that are either newlines (<code>\n</code>) or
sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p>
<p>Line terminators are not included in the lines returned by the iterator.</p>
<p>Note that any carriage return (<code>\r</code>) not immediately followed by a
line feed (<code>\n</code>) does not split a line. These carriage returns are
thereby included in the produced lines.</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;foo\r\nbar\n\nbaz\r&quot;</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), lines.next());
<span class="comment">// Trailing carriage return is included in the last line
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz\r&quot;</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
<p>The final line does not require any ending:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;foo\nbar\n\r\nbaz&quot;</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;&quot;</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">&quot;baz&quot;</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines_any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1005">source</a></span><h4 class="code-header">pub fn <a href="#method.lines_any" class="fn">lines_any</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.LinesAny.html" title="struct core::str::iter::LinesAny">LinesAny</a>&lt;'_&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.4.0: use lines() instead now</span></div></span></summary><div class="docblock"><p>An iterator over the lines of a string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1024">source</a></span><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fn">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.EncodeUtf16.html" title="struct core::str::iter::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded as UTF-16.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">&quot;ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„&quot;</span>;

<span class="kw">let </span>utf8_len = text.len();
<span class="kw">let </span>utf16_len = text.encode_utf16().count();

<span class="macro">assert!</span>(utf16_len &lt;= utf8_len);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1049">source</a></span><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(bananas.contains(<span class="string">&quot;nana&quot;</span>));
<span class="macro">assert!</span>(!bananas.contains(<span class="string">&quot;apples&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1073">source</a></span><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(bananas.starts_with(<span class="string">&quot;bana&quot;</span>));
<span class="macro">assert!</span>(!bananas.starts_with(<span class="string">&quot;nana&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1097-1099">source</a></span><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-20"><a href="#examples-20">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">&quot;bananas&quot;</span>;

<span class="macro">assert!</span>(bananas.ends_with(<span class="string">&quot;anas&quot;</span>));
<span class="macro">assert!</span>(!bananas.ends_with(<span class="string">&quot;nana&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1148">source</a></span><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-21"><a href="#examples-21">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(s.find(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">&#39;Ã©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="macro">assert_eq!</span>(s.find(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(s.find(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| (c &lt; <span class="string">&#39;o&#39;</span>) &amp;&amp; (c &gt; <span class="string">&#39;a&#39;</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(s.find(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1194-1196">source</a></span><h4 class="code-header">pub fn <a href="#method.rfind" class="fn">rfind</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns the byte index for the first character of the last match of the pattern in
this string slice.</p>
<p>Returns <a href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html#variant.None" title="variant core::option::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-22"><a href="#examples-22">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard Gepardi&quot;</span>;

<span class="macro">assert_eq!</span>(s.rfind(<span class="string">&#39;L&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">&#39;Ã©&#39;</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">&quot;pard&quot;</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;

<span class="macro">assert_eq!</span>(s.rfind(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(s.rfind(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;LÃ¶we è€è™ LÃ©opard&quot;</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];

<span class="macro">assert_eq!</span>(s.rfind(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1316">source</a></span><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.Split.html" title="struct core::str::iter::Split">Split</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior"><a href="#iterator-behavior">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-23"><a href="#examples-23">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb&quot;</span>.split(<span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;lamb&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;&quot;</span>.split(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.split(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lion::tiger::leopard&quot;</span>.split(<span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1def2ghi&quot;</span>.split(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXtigerXleopard&quot;</span>.split(char::is_uppercase).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;leopard&quot;</span>]);</code></pre></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;2020-11-03 23:59&quot;</span>.split(<span class="kw-2">&amp;</span>[<span class="string">&#39;-&#39;</span>, <span class="string">&#39; &#39;</span>, <span class="string">&#39;:&#39;</span>, <span class="string">&#39;@&#39;</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;2020&quot;</span>, <span class="string">&quot;11&quot;</span>, <span class="string">&quot;03&quot;</span>, <span class="string">&quot;23&quot;</span>, <span class="string">&quot;59&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.split(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">&quot;||||a||b|c&quot;</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">&#39;|&#39;</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">&quot;(///)&quot;</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">&#39;/&#39;</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;(&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;)&quot;</span>]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;010&quot;</span>.split(<span class="string">&quot;0&quot;</span>).collect();
<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;rust&quot;</span>.split(<span class="string">&quot;&quot;</span>).collect();
<span class="macro">assert_eq!</span>(f, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>, <span class="string">&quot;&quot;</span>]);</code></pre></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">&quot;    a  b c&quot;</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">&#39; &#39;</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre></div>
<p>It does <em>not</em> give you:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</code></pre></div>
<p>Use <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1356">source</a></span><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.SplitInclusive.html" title="struct core::str::iter::SplitInclusive">SplitInclusive</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by
characters matched by a pattern. Differs from the iterator produced by
<code>split</code> in that <code>split_inclusive</code> leaves the matched part as the
terminator of the substring.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-24"><a href="#examples-24">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.&quot;
    </span>.split_inclusive(<span class="string">&#39;\n&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.&quot;</span>]);</code></pre></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb\nlittle lamb\nlittle lamb.\n&quot;
    </span>.split_inclusive(<span class="string">&#39;\n&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary had a little lamb\n&quot;</span>, <span class="string">&quot;little lamb\n&quot;</span>, <span class="string">&quot;little lamb.\n&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1411-1413">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.RSplit.html" title="struct core::str::iter::RSplit">RSplit</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1"><a href="#iterator-behavior-1">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p>
<h5 id="examples-25"><a href="#examples-25">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb&quot;</span>.rsplit(<span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;Mary&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;&quot;</span>.rsplit(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.rsplit(<span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;lion&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lion::tiger::leopard&quot;</span>.rsplit(<span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lion&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.rsplit(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;abc&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1460">source</a></span><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fn">split_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.SplitTerminator.html" title="struct core::str::iter::SplitTerminator">SplitTerminator</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2"><a href="#iterator-behavior-2">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-26"><a href="#examples-26">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B.&quot;</span>.split_terminator(<span class="string">&#39;.&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A..B..&quot;</span>.split_terminator(<span class="string">&quot;.&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B:C.D&quot;</span>.split_terminator(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1506-1508">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fn">rsplit_terminator</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.RSplitTerminator.html" title="struct core::str::iter::RSplitTerminator">RSplitTerminator</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3"><a href="#iterator-behavior-3">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-27"><a href="#examples-27">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B.&quot;</span>.rsplit_terminator(<span class="string">&#39;.&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A..B..&quot;</span>.rsplit_terminator(<span class="string">&quot;.&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;A.B:C.D&quot;</span>.rsplit_terminator(<span class="kw-2">&amp;</span>[<span class="string">&#39;.&#39;</span>, <span class="string">&#39;:&#39;</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;D&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1561">source</a></span><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.SplitN.html" title="struct core::str::iter::SplitN">SplitN</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of the given string slice, separated by a
pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4"><a href="#iterator-behavior-4">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-28"><a href="#examples-28">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lambda&quot;</span>.splitn(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;had&quot;</span>, <span class="string">&quot;a little lambda&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.splitn(<span class="number">3</span>, <span class="string">&quot;X&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lion&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;tigerXleopard&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abcXdef&quot;</span>.splitn(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abcXdef&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;&quot;</span>.splitn(<span class="number">1</span>, <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.splitn(<span class="number">2</span>, |c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;defXghi&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1610-1612">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;'a, P&gt;(&amp;'a self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.RSplitN.html" title="struct core::str::iter::RSplitN">RSplitN</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning
at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5"><a href="#iterator-behavior-5">Iterator behavior</a></h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-29"><a href="#examples-29">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;Mary had a little lamb&quot;</span>.rsplitn(<span class="number">3</span>, <span class="string">&#39; &#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;lamb&quot;</span>, <span class="string">&quot;little&quot;</span>, <span class="string">&quot;Mary had a&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lionXXtigerXleopard&quot;</span>.rsplitn(<span class="number">3</span>, <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;tiger&quot;</span>, <span class="string">&quot;lionX&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;lion::tiger::leopard&quot;</span>.rsplitn(<span class="number">2</span>, <span class="string">&quot;::&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;leopard&quot;</span>, <span class="string">&quot;lion::tiger&quot;</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abc1defXghi&quot;</span>.rsplitn(<span class="number">2</span>, |c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;abc1def&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1630">source</a></span><h4 class="code-header">pub fn <a href="#method.split_once" class="fn">split_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>)&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-30"><a href="#examples-30">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.split_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo=bar&quot;</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1648-1650">source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fn">rsplit_once</a>&lt;'a, P&gt;(&amp;'a self, delimiter: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>, &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>)&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-31"><a href="#examples-31">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;cfg&quot;</span>.rsplit_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo&quot;</span>.rsplit_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg&quot;</span>, <span class="string">&quot;foo&quot;</span>)));
<span class="macro">assert_eq!</span>(<span class="string">&quot;cfg=foo=bar&quot;</span>.rsplit_once(<span class="string">&#39;=&#39;</span>), <span class="prelude-val">Some</span>((<span class="string">&quot;cfg=foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1688">source</a></span><h4 class="code-header">pub fn <a href="#method.matches" class="fn">matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.Matches.html" title="struct core::str::iter::Matches">Matches</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within the given string
slice.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6"><a href="#iterator-behavior-6">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-32"><a href="#examples-32">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.matches(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;1abc2abc3&quot;</span>.matches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1722-1724">source</a></span><h4 class="code-header">pub fn <a href="#method.rmatches" class="fn">rmatches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.RMatches.html" title="struct core::str::iter::RMatches">RMatches</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string slice,
yielded in reverse order.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7"><a href="#iterator-behavior-7">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-33"><a href="#examples-33">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.rmatches(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">&quot;1abc2abc3&quot;</span>.rmatches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">&quot;3&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;1&quot;</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1766">source</a></span><h4 class="code-header">pub fn <a href="#method.match_indices" class="fn">match_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.MatchIndices.html" title="struct core::str::iter::MatchIndices">MatchIndices</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8"><a href="#iterator-behavior-8">Iterator behavior</a></h5>
<p>The returned iterator will be a <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-34"><a href="#examples-34">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.match_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;1abcabc2&quot;</span>.match_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;ababa&quot;</span>.match_indices(<span class="string">&quot;aba&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the first `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1806-1808">source</a></span><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fn">rmatch_indices</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.RMatchIndices.html" title="struct core::str::iter::RMatchIndices">RMatchIndices</a>&lt;'a, P&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>An iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9"><a href="#iterator-behavior-9">Iterator behavior</a></h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="https://doc.rust-lang.org/1.74.1/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-35"><a href="#examples-35">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;abcXXXabcYYYabc&quot;</span>.rmatch_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">12</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">6</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">0</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;1abcabc2&quot;</span>.rmatch_indices(<span class="string">&quot;abc&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">4</span>, <span class="string">&quot;abc&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">&quot;ababa&quot;</span>.rmatch_indices(<span class="string">&quot;aba&quot;</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">2</span>, <span class="string">&quot;aba&quot;</span>)]); <span class="comment">// only the last `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1830">source</a></span><h4 class="code-header">pub fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="examples-36"><a href="#examples-36">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld&quot;</span>, s.trim());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1869">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality"><a href="#text-directionality">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-37"><a href="#examples-37">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t\n&quot;</span>, s.trim_start());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) == s.trim_start().chars().next());

<span class="kw">let </span>s = <span class="string">&quot;  ×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×¢&#39;</span>) == s.trim_start().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1908">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality-1"><a href="#text-directionality-1">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-38"><a href="#examples-38">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;\n Hello\tworld\t\n&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;\n Hello\tworld&quot;</span>, s.trim_end());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;  English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) == s.trim_end().chars().rev().next());

<span class="kw">let </span>s = <span class="string">&quot;  ×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×ª&#39;</span>) == s.trim_end().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1948">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left" class="fn">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2"><a href="#text-directionality-2">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-39"><a href="#examples-39">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Hello\tworld\t&quot;</span>, s.trim_left());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;  English&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;E&#39;</span>) == s.trim_left().chars().next());

<span class="kw">let </span>s = <span class="string">&quot;  ×¢×‘×¨×™×ª&quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×¢&#39;</span>) == s.trim_left().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#1988">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right" class="fn">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3"><a href="#text-directionality-3">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-40"><a href="#examples-40">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot; Hello\tworld\t&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot; Hello\tworld&quot;</span>, s.trim_right());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;English  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;h&#39;</span>) == s.trim_right().chars().rev().next());

<span class="kw">let </span>s = <span class="string">&quot;×¢×‘×¨×™×ª  &quot;</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">&#39;×ª&#39;</span>) == s.trim_right().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2021-2023">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fn">trim_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.DoubleEndedSearcher.html" title="trait core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-41"><a href="#examples-41">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_matches(char::is_numeric), <span class="string">&quot;foo1bar&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_matches(x), <span class="string">&quot;foo1bar&quot;</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1foo1barXX&quot;</span>.trim_matches(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>), <span class="string">&quot;foo1bar&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2068">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fn">trim_start_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4"><a href="#text-directionality-4">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-42"><a href="#examples-42">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_start_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_start_matches(char::is_numeric), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_start_matches(x), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2101">source</a></span><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;'a, P&gt;(&amp;'a self, prefix: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns substring after the prefix, wrapped
in <code>Some</code>.  Unlike <code>trim_start_matches</code>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-43"><a href="#examples-43">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.strip_prefix(<span class="string">&quot;foo:&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;foo:bar&quot;</span>.strip_prefix(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.strip_prefix(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2128-2131">source</a></span><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;'a, P&gt;(&amp;'a self, suffix: P) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>&gt;<span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <code>trim_end_matches</code>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-44"><a href="#examples-44">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.strip_suffix(<span class="string">&quot;:foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;bar&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;bar:foo&quot;</span>.strip_suffix(<span class="string">&quot;bar&quot;</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;foofoo&quot;</span>.strip_suffix(<span class="string">&quot;foo&quot;</span>), <span class="prelude-val">Some</span>(<span class="string">&quot;foo&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2172-2174">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fn">trim_end_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5"><a href="#text-directionality-5">Text directionality</a></h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-45"><a href="#examples-45">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_end_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_end_matches(char::is_numeric), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_end_matches(x), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.trim_end_matches(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2216">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fn">trim_left_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6"><a href="#text-directionality-6">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-46"><a href="#examples-46">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_left_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;foo1bar11&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_left_matches(char::is_numeric), <span class="string">&quot;foo1bar123&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_left_matches(x), <span class="string">&quot;foo1bar12&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2259-2261">source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fn">trim_right_matches</a>&lt;'a, P&gt;(&amp;'a self, pat: P) -&gt; &amp;'a <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,
    &lt;P as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type core::str::pattern::Pattern::Searcher">Searcher</a>: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.ReverseSearcher.html" title="trait core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="https://doc.rust-lang.org/1.74.1/core/str/pattern/index.html" title="mod core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7"><a href="#text-directionality-7">Text directionality</a></h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-47"><a href="#examples-47">Examples</a></h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;11foo1bar11&quot;</span>.trim_right_matches(<span class="string">&#39;1&#39;</span>), <span class="string">&quot;11foo1bar&quot;</span>);
<span class="macro">assert_eq!</span>(<span class="string">&quot;123foo1bar123&quot;</span>.trim_right_matches(char::is_numeric), <span class="string">&quot;123foo1bar&quot;</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">&#39;1&#39;</span>, <span class="string">&#39;2&#39;</span>];
<span class="macro">assert_eq!</span>(<span class="string">&quot;12foo1bar12&quot;</span>.trim_right_matches(x), <span class="string">&quot;12foo1bar&quot;</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;1fooX&quot;</span>.trim_right_matches(|c| c == <span class="string">&#39;1&#39; </span>|| c == <span class="string">&#39;X&#39;</span>), <span class="string">&quot;1foo&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2311">source</a></span><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.74.1/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>&gt;<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>,</span></h4></section></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times youâ€™ll see
the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
youâ€™re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="https://doc.rust-lang.org/1.74.1/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>Will return <a href="https://doc.rust-lang.org/1.74.1/core/str/traits/trait.FromStr.html#associatedtype.Err" title="associated type core::str::traits::FromStr::Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-48"><a href="#examples-48">Examples</a></h5>
<p>Basic usage</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four: u32 = <span class="string">&quot;4&quot;</span>.parse().unwrap();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, four);</code></pre></div>
<p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four = <span class="string">&quot;4&quot;</span>.parse::&lt;u32&gt;();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), four);</code></pre></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nope = <span class="string">&quot;j&quot;</span>.parse::&lt;u32&gt;();

<span class="macro">assert!</span>(nope.is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2330">source</a></span><h4 class="code-header">pub fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<h5 id="examples-49"><a href="#examples-49">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ascii = <span class="string">&quot;hello!\n&quot;</span>;
<span class="kw">let </span>non_ascii = <span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>;

<span class="macro">assert!</span>(ascii.is_ascii());
<span class="macro">assert!</span>(!non_ascii.is_ascii());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii" class="method"><a class="src rightside" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2342">source</a><h4 class="code-header">pub fn <a href="#method.as_ascii" class="fn">as_ascii</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.74.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;[<a class="enum" href="https://doc.rust-lang.org/1.74.1/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">AsciiChar</a>]&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class="docblock"><p>If this string slice <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice
of <a href="https://doc.rust-lang.org/1.74.1/core/ascii/ascii_char/enum.AsciiChar.html" title="enum core::ascii::ascii_char::AsciiChar">ASCII characters</a>, otherwise returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2362">source</a></span><h4 class="code-header">pub fn <a href="#method.eq_ignore_ascii_case" class="fn">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-50"><a href="#examples-50">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">&quot;Ferris&quot;</span>.eq_ignore_ascii_case(<span class="string">&quot;FERRIS&quot;</span>));
<span class="macro">assert!</span>(<span class="string">&quot;FerrÃ¶s&quot;</span>.eq_ignore_ascii_case(<span class="string">&quot;FERRÃ¶S&quot;</span>));
<span class="macro">assert!</span>(!<span class="string">&quot;FerrÃ¶s&quot;</span>.eq_ignore_ascii_case(<span class="string">&quot;FERRÃ–S&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2457">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fn">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.EscapeDebug.html" title="struct core::str::iter::EscapeDebug">EscapeDebug</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-51"><a href="#examples-51">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">&quot;â¤\n!&quot;</span>.escape_debug() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.escape_debug());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;â¤\\n!&quot;</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.escape_debug().to_string(), <span class="string">&quot;â¤\\n!&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2503">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_default" class="fn">escape_default</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.EscapeDefault.html" title="struct core::str::iter::EscapeDefault">EscapeDefault</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-52"><a href="#examples-52">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">&quot;â¤\n!&quot;</span>.escape_default() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.escape_default());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\n!&quot;</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.escape_default().to_string(), <span class="string">&quot;\\u{2764}\\n!&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/core/str/mod.rs.html#2541">source</a></span><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fn">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/core/str/iter/struct.EscapeUnicode.html" title="struct core::str::iter::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Return an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/1.74.1/std/primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-53"><a href="#examples-53">Examples</a></h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">&quot;â¤\n!&quot;</span>.escape_unicode() {
    <span class="macro">print!</span>(<span class="string">&quot;{c}&quot;</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="string">&quot;â¤\n!&quot;</span>.escape_unicode());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">&quot;\\u{{2764}}\\u{{a}}\\u{{21}}&quot;</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;â¤\n!&quot;</span>.escape_unicode().to_string(), <span class="string">&quot;\\u{2764}\\u{a}\\u{21}&quot;</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/str.rs.html#269">source</a></span><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>&lt;'a, P&gt;(&amp;'a self, from: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h5 id="examples-54"><a href="#examples-54">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;this is old&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;this is new&quot;</span>, s.replace(<span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;than an old&quot;</span>, s.replace(<span class="string">&quot;is&quot;</span>, <span class="string">&quot;an&quot;</span>));</code></pre></div>
<p>When the pattern doesnâ€™t match, it returns this string slice as <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq!</span>(s, s.replace(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/str.rs.html#309">source</a></span><h4 class="code-header">pub fn <a href="#method.replacen" class="fn">replacen</a>&lt;'a, P&gt;(&amp;'a self, pat: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a>, count: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a><span class="where fmt-newline">where
    P: <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/str/pattern/trait.Pattern.html" title="trait core::str::pattern::Pattern">Pattern</a>&lt;'a&gt;,</span></h4></section></summary><div class="docblock"><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h5 id="examples-55"><a href="#examples-55">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;foo foo 123 foo&quot;</span>;
<span class="macro">assert_eq!</span>(<span class="string">&quot;new new 123 foo&quot;</span>, s.replacen(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;new&quot;</span>, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;faa fao 123 foo&quot;</span>, s.replacen(<span class="string">&#39;o&#39;</span>, <span class="string">&quot;a&quot;</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="string">&quot;foo foo new23 foo&quot;</span>, s.replacen(char::is_numeric, <span class="string">&quot;new&quot;</span>, <span class="number">1</span>));</code></pre></div>
<p>When the pattern doesnâ€™t match, it returns this string slice as <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;this is old&quot;</span>;
<span class="macro">assert_eq!</span>(s, s.replacen(<span class="string">&quot;cookie monster&quot;</span>, <span class="string">&quot;little lamb&quot;</span>, <span class="number">10</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/str.rs.html#366">source</a></span><h4 class="code-header">pub fn <a href="#method.to_lowercase" class="fn">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the lowercase equivalent of this string slice, as a new <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</p>
<p>â€˜Lowercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-56"><a href="#examples-56">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;HELLO&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;hello&quot;</span>, s.to_lowercase());</code></pre></div>
<p>A tricky example, with sigma:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sigma = <span class="string">&quot;Î£&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;Ïƒ&quot;</span>, sigma.to_lowercase());

<span class="comment">// but at the end of a word, it&#39;s Ï‚, not Ïƒ:
</span><span class="kw">let </span>odysseus = <span class="string">&quot;á½ˆÎ”Î¥Î£Î£Î•ÎÎ£&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;á½€Î´Ï…ÏƒÏƒÎµÏÏ‚&quot;</span>, odysseus.to_lowercase());</code></pre></div>
<p>Languages without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">&quot;å†œå†æ–°å¹´&quot;</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/str.rs.html#457">source</a></span><h4 class="code-header">pub fn <a href="#method.to_uppercase" class="fn">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns the uppercase equivalent of this string slice, as a new <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a>.</p>
<p>â€˜Uppercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-57"><a href="#examples-57">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;hello&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;HELLO&quot;</span>, s.to_uppercase());</code></pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">&quot;å†œå†æ–°å¹´&quot;</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_uppercase());</code></pre></div>
<p>One character can become multiple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;tschÃ¼ÃŸ&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;TSCHÃœSS&quot;</span>, s.to_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/str.rs.html#527">source</a></span><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Creates a new <a href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-58"><a href="#examples-58">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">&quot;abc&quot;</span>.repeat(<span class="number">4</span>), String::from(<span class="string">&quot;abcabcabcabc&quot;</span>));</code></pre></div>
<p>A panic upon overflow:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">â“˜</a><pre class="rust rust-example-rendered"><code><span class="comment">// this will panic at runtime
</span><span class="kw">let </span>huge = <span class="string">&quot;0123456789abcdef&quot;</span>.repeat(usize::MAX);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/str.rs.html#557">source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.make_ascii_uppercase" title="method str::make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h5 id="examples-59"><a href="#examples-59">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;GRÃ¼ÃŸE, JÃ¼RGEN â¤&quot;</span>, s.to_ascii_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/str.rs.html#589">source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html#method.make_ascii_lowercase" title="method str::make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h5 id="examples-60"><a href="#examples-60">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">&quot;GrÃ¼ÃŸe, JÃ¼rgen â¤&quot;</span>;

<span class="macro">assert_eq!</span>(<span class="string">&quot;grÃ¼ÃŸe, jÃ¼rgen â¤&quot;</span>, s.to_ascii_lowercase());</code></pre></div>
</div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-String" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/1.74.1/src/alloc/string.rs.html#2380">source</a></span><a href="#impl-Deref-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.74.1/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">Â§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.74.1/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.74.1/src/alloc/string.rs.html#2384">source</a><a href="#method.deref" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.74.1/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.74.1/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Variable-for-String" class="impl"><a class="src rightside" href="../../../src/wasmer_api/types.rs.html#2124">source</a><a href="#impl-Variable-for-String" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="variable/trait.Variable.html" title="trait wasmer_api::types::schema::variable::Variable">Variable</a> for <a class="struct" href="https://doc.rust-lang.org/1.74.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h3></section></summary><div class="impl-items"><section id="associatedconstant.TYPE" class="associatedconstant trait-impl"><a class="src rightside" href="../../../src/wasmer_api/types.rs.html#2124">source</a><a href="#associatedconstant.TYPE" class="anchor">Â§</a><h4 class="code-header">const <a href="variable/trait.Variable.html#associatedconstant.TYPE" class="constant">TYPE</a>: VariableType = &lt;str as Variable&gt;::TYPE</h4></section></div></details></div><script type="text/json" id="notable-traits-data">{"&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><span class=\"where fmt-newline\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.74.1/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.74.1/std/primitive.u8.html\">u8</a>]</span>"}</script></section></div></main></body></html>