<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Manually manage memory through raw pointers."><title>wasmer_types::lib::std::ptr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="wasmer_types" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../wasmer_types/index.html">wasmer_types</a><span class="version">5.0.5-rc1</span></h2></div><h2 class="location"><a href="#">Module ptr</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In wasmer_types::lib::std</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../../index.html">wasmer_types</a>::<wbr><a href="../../index.html">lib</a>::<wbr><a href="../index.html">std</a>::<wbr><a class="mod" href="#">ptr</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.81.0/src/core/lib.rs.html#361">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Manually manage memory through raw pointers.</p>
<p><em><a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html" title="primitive pointer">See also the pointer primitive types</a>.</em></p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Many functions in this module take raw pointers as arguments and read from or write to them. For
this to be safe, these pointers must be <em>valid</em> for the given access. Whether a pointer is valid
depends on the operation it is used for (read or write), and the extent of the memory that is
accessed (i.e., how many bytes are read/written) – it makes no sense to ask “is this pointer
valid”; one has to ask “is this pointer valid for a given access”. Most functions use <code>*mut T</code>
and <code>*const T</code> to access only a single value, in which case the documentation omits the size and
implicitly assumes it to be <code>size_of::&lt;T&gt;()</code> bytes.</p>
<p>The precise rules for validity are not determined yet. The guarantees that are
provided at this point are very minimal:</p>
<ul>
<li>For operations of <a href="../../nomicon/exotic-sizes.html#zero-sized-types-zsts">size zero</a>, <em>every</em> pointer is valid, including the <a href="fn.null.html" title="fn wasmer_types::lib::std::ptr::null">null</a> pointer.
The following points are only concerned with non-zero-sized accesses.</li>
<li>A <a href="fn.null.html" title="fn wasmer_types::lib::std::ptr::null">null</a> pointer is <em>never</em> valid.</li>
<li>For a pointer to be valid, it is necessary, but not always sufficient, that the pointer
be <em>dereferenceable</em>: the memory range of the given size starting at the pointer must all be
within the bounds of a single allocated object. Note that in Rust,
every (stack-allocated) variable is considered a separate allocated object.</li>
<li>All accesses performed by functions in this module are <em>non-atomic</em> in the sense
of <a href="../sync/atomic/index.html" title="mod wasmer_types::lib::std::sync::atomic">atomic operations</a> used to synchronize between threads. This means it is
undefined behavior to perform two concurrent accesses to the same location from different
threads unless both accesses only read from memory. Notice that this explicitly
includes <a href="fn.read_volatile.html" title="fn wasmer_types::lib::std::ptr::read_volatile"><code>read_volatile</code></a> and <a href="fn.write_volatile.html" title="fn wasmer_types::lib::std::ptr::write_volatile"><code>write_volatile</code></a>: Volatile accesses cannot
be used for inter-thread synchronization.</li>
<li>The result of casting a reference to a pointer is valid for as long as the
underlying object is live and no reference (just raw pointers) is used to
access the same memory. That is, reference and pointer accesses cannot be
interleaved.</li>
</ul>
<p>These axioms, along with careful use of <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.offset" title="method pointer::offset"><code>offset</code></a> for pointer arithmetic,
are enough to correctly implement many useful things in unsafe code. Stronger guarantees
will be provided eventually, as the <a href="../../nomicon/aliasing.html">aliasing</a> rules are being determined. For more
information, see the <a href="../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer">book</a> as well as the section in the reference devoted
to <a href="../../reference/behavior-considered-undefined.html">undefined behavior</a>.</p>
<p>We say that a pointer is “dangling” if it is not valid for any non-zero-sized accesses. This
means out-of-bounds pointers, pointers to freed memory, null pointers, and pointers created with
<a href="struct.NonNull.html#method.dangling" title="associated function wasmer_types::lib::std::ptr::NonNull::dangling"><code>NonNull::dangling</code></a> are all dangling.</p>
<h3 id="alignment"><a class="doc-anchor" href="#alignment">§</a>Alignment</h3>
<p>Valid raw pointers as defined above are not necessarily properly aligned (where
“proper” alignment is defined by the pointee type, i.e., <code>*const T</code> must be
aligned to <code>mem::align_of::&lt;T&gt;()</code>). However, most functions require their
arguments to be properly aligned, and will explicitly state
this requirement in their documentation. Notable exceptions to this are
<a href="fn.read_unaligned.html" title="fn wasmer_types::lib::std::ptr::read_unaligned"><code>read_unaligned</code></a> and <a href="fn.write_unaligned.html" title="fn wasmer_types::lib::std::ptr::write_unaligned"><code>write_unaligned</code></a>.</p>
<p>When a function requires proper alignment, it does so even if the access
has size 0, i.e., even if memory is not actually touched. Consider using
<a href="struct.NonNull.html#method.dangling" title="associated function wasmer_types::lib::std::ptr::NonNull::dangling"><code>NonNull::dangling</code></a> in such cases.</p>
<h3 id="allocated-object"><a class="doc-anchor" href="#allocated-object">§</a>Allocated object</h3>
<p>An <em>allocated object</em> is a subset of program memory which is addressable
from Rust, and within which pointer arithmetic is possible. Examples of
allocated objects include heap allocations, stack-allocated variables,
statics, and consts. The safety preconditions of some Rust operations -
such as <code>offset</code> and field projections (<code>expr.field</code>) - are defined in
terms of the allocated objects on which they operate.</p>
<p>An allocated object has a base address, a size, and a set of memory
addresses. It is possible for an allocated object to have zero size, but
such an allocated object will still have a base address. The base address
of an allocated object is not necessarily unique. While it is currently the
case that an allocated object always has a set of memory addresses which is
fully contiguous (i.e., has no “holes”), there is no guarantee that this
will not change in the future.</p>
<p>For any allocated object with <code>base</code> address, <code>size</code>, and a set of
<code>addresses</code>, the following are guaranteed:</p>
<ul>
<li>For all addresses <code>a</code> in <code>addresses</code>, <code>a</code> is in the range <code>base .. (base + size)</code> (note that this requires <code>a &lt; base + size</code>, not <code>a &lt;= base + size</code>)</li>
<li><code>base</code> is not equal to <a href="fn.null.html" title="fn wasmer_types::lib::std::ptr::null"><code>null()</code></a> (i.e., the address with the numerical
value 0)</li>
<li><code>base + size &lt;= usize::MAX</code></li>
<li><code>size &lt;= isize::MAX</code></li>
</ul>
<p>As a consequence of these guarantees, given any address <code>a</code> within the set
of addresses of an allocated object:</p>
<ul>
<li>It is guaranteed that <code>a - base</code> does not overflow <code>isize</code></li>
<li>It is guaranteed that <code>a - base</code> is non-negative</li>
<li>It is guaranteed that, given <code>o = a - base</code> (i.e., the offset of <code>a</code> within
the allocated object), <code>base + o</code> will not wrap around the address space (in
other words, will not overflow <code>usize</code>)</li>
</ul>
<h2 id="strict-provenance"><a class="doc-anchor" href="#strict-provenance">§</a>Strict Provenance</h2>
<p><strong>The following text is non-normative, insufficiently formal, and is an extremely strict
interpretation of provenance. It’s ok if your code doesn’t strictly conform to it.</strong></p>
<p><a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a> is an experimental set of APIs that help tools that try
to validate the memory-safety of your program’s execution. Notably this includes <a href="https://github.com/rust-lang/miri">Miri</a>
and <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a>, which can detect when you access out of bounds memory or otherwise violate
Rust’s memory model.</p>
<p>Provenance must exist in some form for any programming
language compiled for modern computer architectures, but specifying a model for provenance
in a way that is useful to both compilers and programmers is an ongoing challenge.
The <a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a> experiment seeks to explore the question: <em>what if we just said you
couldn’t do all the nasty operations that make provenance so messy?</em></p>
<p>What APIs would have to be removed? What APIs would have to be added? How much would code
have to change, and is it worse or better now? Would any patterns become truly inexpressible?
Could we carve out special exceptions for those patterns? Should we?</p>
<p>A secondary goal of this project is to see if we can disambiguate the many functions of
pointer&lt;-&gt;integer casts enough for the definition of <code>usize</code> to be loosened so that it
isn’t <em>pointer</em>-sized but address-space/offset/allocation-sized (we’ll probably continue
to conflate these notions). This would potentially make it possible to more efficiently
target platforms where pointers are larger than offsets, such as CHERI and maybe some
segmented architectures.</p>
<h3 id="provenance"><a class="doc-anchor" href="#provenance">§</a>Provenance</h3>
<p><strong>This section is <em>non-normative</em> and is part of the <a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a> experiment.</strong></p>
<p>Pointers are not <em>simply</em> an “integer” or “address”. For instance, it’s uncontroversial
to say that a Use After Free is clearly Undefined Behaviour, even if you “get lucky”
and the freed memory gets reallocated before your read/write (in fact this is the
worst-case scenario, UAFs would be much less concerning if this didn’t happen!).
To rationalize this claim, pointers need to somehow be <em>more</em> than just their addresses:
they must have provenance.</p>
<p>When an allocation is created, that allocation has a unique Original Pointer. For alloc
APIs this is literally the pointer the call returns, and for local variables and statics,
this is the name of the variable/static. This is mildly overloading the term “pointer”
for the sake of brevity/exposition.</p>
<p>The Original Pointer for an allocation is guaranteed to have unique access to the entire
allocation and <em>only</em> that allocation. In this sense, an allocation can be thought of
as a “sandbox” that cannot be broken into or out of. <em>Provenance</em> is the permission
to access an allocation’s sandbox and has both a <em>spatial</em> and <em>temporal</em> component:</p>
<ul>
<li>Spatial: A range of bytes that the pointer is allowed to access.</li>
<li>Temporal: The lifetime (of the allocation) that access to these bytes is tied to.</li>
</ul>
<p>Spatial provenance makes sure you don’t go beyond your sandbox, while temporal provenance
makes sure that you can’t “get lucky” after your permission to access some memory
has been revoked (either through deallocations or borrows expiring).</p>
<p>Provenance is implicitly shared with all pointers transitively derived from
The Original Pointer through operations like <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.offset" title="method pointer::offset"><code>offset</code></a>, borrowing, and pointer casts.
Some operations may <em>shrink</em> the derived provenance, limiting how much memory it can
access or how long it’s valid for (i.e. borrowing a subfield and subslicing).</p>
<p>Shrinking provenance cannot be undone: even if you “know” there is a larger allocation, you
can’t derive a pointer with a larger provenance. Similarly, you cannot “recombine”
two contiguous provenances back into one (i.e. with a <code>fn merge(&amp;[T], &amp;[T]) -&gt; &amp;[T]</code>).</p>
<p>A reference to a value always has provenance over exactly the memory that field occupies.
A reference to a slice always has provenance over exactly the range that slice describes.</p>
<p>If an allocation is deallocated, all pointers with provenance to that allocation become
invalidated, and effectively lose their provenance.</p>
<p>The strict provenance experiment is mostly only interested in exploring stricter <em>spatial</em>
provenance. In this sense it can be thought of as a subset of the more ambitious and
formal <a href="https://plv.mpi-sws.org/rustbelt/stacked-borrows/">Stacked Borrows</a> research project, which is what tools like <a href="https://github.com/rust-lang/miri">Miri</a> are based on.
In particular, Stacked Borrows is necessary to properly describe what borrows are allowed
to do and when they become invalidated. This necessarily involves much more complex
<em>temporal</em> reasoning than simply identifying allocations. Adjusting APIs and code
for the strict provenance experiment will also greatly help Stacked Borrows.</p>
<h3 id="pointer-vs-addresses"><a class="doc-anchor" href="#pointer-vs-addresses">§</a>Pointer Vs Addresses</h3>
<p><strong>This section is <em>non-normative</em> and is part of the <a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a> experiment.</strong></p>
<p>One of the largest historical issues with trying to define provenance is that programmers
freely convert between pointers and integers. Once you allow for this, it generally becomes
impossible to accurately track and preserve provenance information, and you need to appeal
to very complex and unreliable heuristics. But of course, converting between pointers and
integers is very useful, so what can we do?</p>
<p>Also did you know WASM is actually a “Harvard Architecture”? As in function pointers are
handled completely differently from data pointers? And we kind of just shipped Rust on WASM
without really addressing the fact that we let you freely convert between function pointers
and data pointers, because it mostly Just Works? Let’s just put that on the “pointer casts
are dubious” pile.</p>
<p>Strict Provenance attempts to square these circles by decoupling Rust’s traditional conflation
of pointers and <code>usize</code> (and <code>isize</code>), and defining a pointer to semantically contain the
following information:</p>
<ul>
<li>The <strong>address-space</strong> it is part of (e.g. “data” vs “code” in WASM).</li>
<li>The <strong>address</strong> it points to, which can be represented by a <code>usize</code>.</li>
<li>The <strong>provenance</strong> it has, defining the memory it has permission to access.
Provenance can be absent, in which case the pointer does not have permission to access any memory.</li>
</ul>
<p>Under Strict Provenance, a usize <em>cannot</em> accurately represent a pointer, and converting from
a pointer to a usize is generally an operation which <em>only</em> extracts the address. It is
therefore <em>impossible</em> to construct a valid pointer from a usize because there is no way
to restore the address-space and provenance. In other words, pointer-integer-pointer
roundtrips are not possible (in the sense that the resulting pointer is not dereferenceable).</p>
<p>The key insight to making this model <em>at all</em> viable is the <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> method:</p>
<div class="example-wrap"><pre class="language-text"><code>    /// Creates a new pointer with the given address.
    ///
    /// This performs the same operation as an `addr as ptr` cast, but copies
    /// the *address-space* and *provenance* of `self` to the new pointer.
    /// This allows us to dynamically preserve and propagate this important
    /// information in a way that is otherwise impossible with a unary cast.
    ///
    /// This is equivalent to using `wrapping_offset` to offset `self` to the
    /// given address, and therefore has all the same capabilities and restrictions.
    pub fn with_addr(self, addr: usize) -&gt; Self;
</code></pre></div>
<p>So you’re still able to drop down to the address representation and do whatever
clever bit tricks you want <em>as long as</em> you’re able to keep around a pointer
into the allocation you care about that can “reconstitute” the other parts of the pointer.
Usually this is very easy, because you only are taking a pointer, messing with the address,
and then immediately converting back to a pointer. To make this use case more ergonomic,
we provide the <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.map_addr" title="method pointer::map_addr"><code>map_addr</code></a> method.</p>
<p>To help make it clear that code is “following” Strict Provenance semantics, we also provide an
<a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.addr" title="method pointer::addr"><code>addr</code></a> method which promises that the returned address is not part of a
pointer-usize-pointer roundtrip. In the future we may provide a lint for pointer&lt;-&gt;integer
casts to help you audit if your code conforms to strict provenance.</p>
<h3 id="using-strict-provenance"><a class="doc-anchor" href="#using-strict-provenance">§</a>Using Strict Provenance</h3>
<p>Most code needs no changes to conform to strict provenance, as the only really concerning
operation that <em>wasn’t</em> obviously already Undefined Behaviour is casts from usize to a
pointer. For code which <em>does</em> cast a usize to a pointer, the scope of the change depends
on exactly what you’re doing.</p>
<p>In general, you just need to make sure that if you want to convert a usize address to a
pointer and then use that pointer to read/write memory, you need to keep around a pointer
that has sufficient provenance to perform that read/write itself. In this way all of your
casts from an address to a pointer are essentially just applying offsets/indexing.</p>
<p>This is generally trivial to do for simple cases like tagged pointers <em>as long as you
represent the tagged pointer as an actual pointer and not a usize</em>. For instance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(strict_provenance)]

</span><span class="kw">unsafe </span>{
    <span class="comment">// A flag we want to pack into our pointer
    </span><span class="kw">static </span>HAS_DATA: usize = <span class="number">0x1</span>;
    <span class="kw">static </span>FLAG_MASK: usize = !HAS_DATA;

    <span class="comment">// Our value, which must have enough alignment to have spare least-significant-bits.
    </span><span class="kw">let </span>my_precious_data: u32 = <span class="number">17</span>;
    <span class="macro">assert!</span>(core::mem::align_of::&lt;u32&gt;() &gt; <span class="number">1</span>);

    <span class="comment">// Create a tagged pointer
    </span><span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>my_precious_data <span class="kw">as </span><span class="kw-2">*const </span>u32;
    <span class="kw">let </span>tagged = ptr.map_addr(|addr| addr | HAS_DATA);

    <span class="comment">// Check the flag:
    </span><span class="kw">if </span>tagged.addr() &amp; HAS_DATA != <span class="number">0 </span>{
        <span class="comment">// Untag and read the pointer
        </span><span class="kw">let </span>data = <span class="kw-2">*</span>tagged.map_addr(|addr| addr &amp; FLAG_MASK);
        <span class="macro">assert_eq!</span>(data, <span class="number">17</span>);
    } <span class="kw">else </span>{
        <span class="macro">unreachable!</span>()
    }
}</code></pre></div>
<p>(Yes, if you’ve been using AtomicUsize for pointers in concurrent datastructures, you should
be using AtomicPtr instead. If that messes up the way you atomically manipulate pointers,
we would like to know why, and what needs to be done to fix it.)</p>
<p>Something more complicated and just generally <em>evil</em> like an XOR-List requires more significant
changes like allocating all nodes in a pre-allocated Vec or Arena and using a pointer
to the whole allocation to reconstitute the XORed addresses.</p>
<p>Situations where a valid pointer <em>must</em> be created from just an address, such as baremetal code
accessing a memory-mapped interface at a fixed address, are an open question on how to support.
These situations <em>will</em> still be allowed, but we might require some kind of “I know what I’m
doing” annotation to explain the situation to the compiler. It’s also possible they need no
special attention at all, because they’re generally accessing memory outside the scope of
“the abstract machine”, or already using “I know what I’m doing” annotations like “volatile”.</p>
<p>Under <a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a> it is Undefined Behaviour to:</p>
<ul>
<li>
<p>Access memory through a pointer that does not have provenance over that memory.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.offset" title="method pointer::offset"><code>offset</code></a> a pointer to or from an address it doesn’t have provenance over.
This means it’s always UB to offset a pointer derived from something deallocated,
even if the offset is 0. Note that a pointer “one past the end” of its provenance
is not actually outside its provenance, it just has 0 bytes it can load/store.</p>
</li>
</ul>
<p>But it <em>is</em> still sound to:</p>
<ul>
<li>
<p>Create a pointer without provenance from just an address (see <a href="fn.dangling.html" title="fn wasmer_types::lib::std::ptr::dangling"><code>ptr::dangling</code></a>). Such a
pointer cannot be used for memory accesses (except for zero-sized accesses). This can still be
useful for sentinel values like <code>null</code> <em>or</em> to represent a tagged pointer that will never be
dereferenceable. In general, it is always sound for an integer to pretend to be a pointer “for
fun” as long as you don’t use operations on it which require it to be valid (non-zero-sized
offset, read, write, etc).</p>
</li>
<li>
<p>Forge an allocation of size zero at any sufficiently aligned non-null address.
i.e. the usual “ZSTs are fake, do what you want” rules apply <em>but</em> this only applies
for actual forgery (integers cast to pointers). If you borrow some struct’s field
that <em>happens</em> to be zero-sized, the resulting pointer will have provenance tied to
that allocation, and it will still get invalidated if the allocation gets deallocated.
In the future we may introduce an API to make such a forged allocation explicit.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset"><code>wrapping_offset</code></a> a pointer outside its provenance. This includes pointers
which have “no” provenance. Unfortunately there may be practical limits on this for a
particular platform, and it’s an open question as to how to specify this (if at all).
Notably, <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a> relies on a compression scheme that can’t handle a
pointer getting offset “too far” out of bounds. If this happens, the address
returned by <code>addr</code> will be the value you expect, but the provenance will get invalidated
and using it to read/write will fault. The details of this are architecture-specific
and based on alignment, but the buffer on either side of the pointer’s range is pretty
generous (think kilobytes, not bytes).</p>
</li>
<li>
<p>Compare arbitrary pointers by address. Addresses <em>are</em> just integers and so there is
always a coherent answer, even if the pointers are dangling or from different
address-spaces/provenances. Of course, comparing addresses from different address-spaces
is generally going to be <em>meaningless</em>, but so is comparing Kilograms to Meters, and Rust
doesn’t prevent that either. Similarly, if you get “lucky” and notice that a pointer
one-past-the-end is the “same” address as the start of an unrelated allocation, anything
you do with that fact is <em>probably</em> going to be gibberish. The scope of that gibberish
is kept under control by the fact that the two pointers <em>still</em> aren’t allowed to access
the other’s allocation (bytes), because they still have different provenance.</p>
</li>
<li>
<p>Perform pointer tagging tricks. This falls out of <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.wrapping_offset" title="method pointer::wrapping_offset"><code>wrapping_offset</code></a> but is worth
mentioning in more detail because of the limitations of <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a>. Low-bit tagging
is very robust, and often doesn’t even go out of bounds because types ensure
size &gt;= align (and over-aligning actually gives CHERI more flexibility). Anything
more complex than this rapidly enters “extremely platform-specific” territory as
certain things may or may not be allowed based on specific supported operations.
For instance, ARM explicitly supports high-bit tagging, and so CHERI on ARM inherits
that and should support it.</p>
</li>
</ul>
<h3 id="exposed-provenance"><a class="doc-anchor" href="#exposed-provenance">§</a>Exposed Provenance</h3>
<p><strong>This section is <em>non-normative</em> and is an extension to the <a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a> experiment.</strong></p>
<p>As discussed above, pointer-usize-pointer roundtrips are not possible under <a href="https://github.com/rust-lang/rust/issues/95228">Strict Provenance</a>.
This is by design: the goal of Strict Provenance is to provide a clear specification that we are
confident can be formalized unambiguously and can be subject to  precise formal reasoning.</p>
<p>However, there exist situations where pointer-usize-pointer roundtrips cannot be avoided, or
where avoiding them would require major refactoring. Legacy platform APIs also regularly assume
that <code>usize</code> can capture all the information that makes up a pointer. The goal of Strict
Provenance is not to rule out such code; the goal is to put all the <em>other</em> pointer-manipulating
code onto a more solid foundation. Strict Provenance is about improving the situation where
possible (all the code that can be written with Strict Provenance) without making things worse
for situations where Strict Provenance is insufficient.</p>
<p>For these situations, there is a highly experimental extension to Strict Provenance called
<em>Exposed Provenance</em>. This extension permits pointer-usize-pointer roundtrips. However, its
semantics are on much less solid footing than Strict Provenance, and at this point it is not yet
clear where a satisfying unambiguous semantics can be defined for Exposed Provenance.
Furthermore, Exposed Provenance will not work (well) with tools like <a href="https://github.com/rust-lang/miri">Miri</a> and <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a>.</p>
<p>Exposed Provenance is provided by the <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a> and <a href="fn.with_exposed_provenance.html" title="fn wasmer_types::lib::std::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a> methods,
which are meant to replace <code>as</code> casts between pointers and integers. <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a> is a lot like
<a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.addr" title="method pointer::addr"><code>addr</code></a>, but additionally adds the provenance of the pointer to a global list of ‘exposed’
provenances. (This list is purely conceptual, it exists for the purpose of specifying Rust but
is not materialized in actual executions, except in tools like <a href="https://github.com/rust-lang/miri">Miri</a>.) <a href="fn.with_exposed_provenance.html" title="fn wasmer_types::lib::std::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a>
can be used to construct a pointer with one of these previously ‘exposed’ provenances.
<a href="fn.with_exposed_provenance.html" title="fn wasmer_types::lib::std::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a> takes only <code>addr: usize</code> as arguments, so unlike in <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.with_addr" title="method pointer::with_addr"><code>with_addr</code></a> there is
no indication of what the correct provenance for the returned pointer is – and that is exactly
what makes pointer-usize-pointer roundtrips so tricky to rigorously specify! There is no
algorithm that decides which provenance will be used. You can think of this as “guessing” the
right provenance, and the guess will be “maximally in your favor”, in the sense that if there is
any way to avoid undefined behavior, then that is the guess that will be taken. However, if
there is <em>no</em> previously ‘exposed’ provenance that justifies the way the returned pointer will
be used, the program has undefined behavior.</p>
<p>Using <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a> or <a href="fn.with_exposed_provenance.html" title="fn wasmer_types::lib::std::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a> (or the <code>as</code> casts) means that code is
<em>not</em> following Strict Provenance rules. The goal of the Strict Provenance experiment is to
determine how far one can get in Rust without the use of <a href="https://doc.rust-lang.org/1.81.0/std/primitive.pointer.html#method.expose_provenance" title="method pointer::expose_provenance"><code>expose_provenance</code></a> and
<a href="fn.with_exposed_provenance.html" title="fn wasmer_types::lib::std::ptr::with_exposed_provenance"><code>with_exposed_provenance</code></a>, and to encourage code to be written with Strict Provenance APIs only.
Maximizing the amount of such code is a major win for avoiding specification complexity and to
facilitate adoption of tools like <a href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">CHERI</a> and <a href="https://github.com/rust-lang/miri">Miri</a> that can be a big help in increasing the
confidence in (unsafe) Rust code.</p>
</div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.addr_of.html" title="macro wasmer_types::lib::std::ptr::addr_of">addr_of</a></div><div class="desc docblock-short">Create a <code>const</code> raw pointer to a place, without creating an intermediate reference.</div></li><li><div class="item-name"><a class="macro" href="macro.addr_of_mut.html" title="macro wasmer_types::lib::std::ptr::addr_of_mut">addr_of_mut</a></div><div class="desc docblock-short">Create a <code>mut</code> raw pointer to a place, without creating an intermediate reference.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.NonNull.html" title="struct wasmer_types::lib::std::ptr::NonNull">NonNull</a></div><div class="desc docblock-short"><code>*mut T</code> but non-zero and <a href="https://doc.rust-lang.org/reference/subtyping.html">covariant</a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Alignment.html" title="struct wasmer_types::lib::std::ptr::Alignment">Alignment</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">A type storing a <code>usize</code> which is a power of two, and thus
represents a possible alignment in the Rust abstract machine.</div></li><li><div class="item-name"><a class="struct" href="struct.DynMetadata.html" title="struct wasmer_types::lib::std::ptr::DynMetadata">DynMetadata</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">The metadata for a <code>Dyn = dyn SomeTrait</code> trait object type.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Pointee.html" title="trait wasmer_types::lib::std::ptr::Pointee">Pointee</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Provides the pointer metadata type of any pointed-to type.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.addr_eq.html" title="fn wasmer_types::lib::std::ptr::addr_eq">addr_eq</a></div><div class="desc docblock-short">Compares the <em>addresses</em> of the two pointers for equality,
ignoring any metadata in fat pointers.</div></li><li><div class="item-name"><a class="fn" href="fn.copy.html" title="fn wasmer_types::lib::std::ptr::copy">copy</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The source
and destination may overlap.</div></li><li><div class="item-name"><a class="fn" href="fn.copy_nonoverlapping.html" title="fn wasmer_types::lib::std::ptr::copy_nonoverlapping">copy_nonoverlapping</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Copies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>dst</code>. The source
and destination must <em>not</em> overlap.</div></li><li><div class="item-name"><a class="fn" href="fn.drop_in_place.html" title="fn wasmer_types::lib::std::ptr::drop_in_place">drop_in_place</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Executes the destructor (if any) of the pointed-to value.</div></li><li><div class="item-name"><a class="fn" href="fn.eq.html" title="fn wasmer_types::lib::std::ptr::eq">eq</a></div><div class="desc docblock-short">Compares raw pointers for equality.</div></li><li><div class="item-name"><a class="fn" href="fn.from_mut.html" title="fn wasmer_types::lib::std::ptr::from_mut">from_mut</a></div><div class="desc docblock-short">Convert a mutable reference to a raw pointer.</div></li><li><div class="item-name"><a class="fn" href="fn.from_ref.html" title="fn wasmer_types::lib::std::ptr::from_ref">from_ref</a></div><div class="desc docblock-short">Convert a reference to a raw pointer.</div></li><li><div class="item-name"><a class="fn" href="fn.hash.html" title="fn wasmer_types::lib::std::ptr::hash">hash</a></div><div class="desc docblock-short">Hash a raw pointer.</div></li><li><div class="item-name"><a class="fn" href="fn.null.html" title="fn wasmer_types::lib::std::ptr::null">null</a></div><div class="desc docblock-short">Creates a null raw pointer.</div></li><li><div class="item-name"><a class="fn" href="fn.null_mut.html" title="fn wasmer_types::lib::std::ptr::null_mut">null_mut</a></div><div class="desc docblock-short">Creates a null mutable raw pointer.</div></li><li><div class="item-name"><a class="fn" href="fn.read.html" title="fn wasmer_types::lib::std::ptr::read">read</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Reads the value from <code>src</code> without moving it. This leaves the
memory in <code>src</code> unchanged.</div></li><li><div class="item-name"><a class="fn" href="fn.read_unaligned.html" title="fn wasmer_types::lib::std::ptr::read_unaligned">read_unaligned</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Reads the value from <code>src</code> without moving it. This leaves the
memory in <code>src</code> unchanged.</div></li><li><div class="item-name"><a class="fn" href="fn.read_volatile.html" title="fn wasmer_types::lib::std::ptr::read_volatile">read_volatile</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Performs a volatile read of the value from <code>src</code> without moving it. This
leaves the memory in <code>src</code> unchanged.</div></li><li><div class="item-name"><a class="fn" href="fn.replace.html" title="fn wasmer_types::lib::std::ptr::replace">replace</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Moves <code>src</code> into the pointed <code>dst</code>, returning the previous <code>dst</code> value.</div></li><li><div class="item-name"><a class="fn" href="fn.slice_from_raw_parts.html" title="fn wasmer_types::lib::std::ptr::slice_from_raw_parts">slice_from_raw_parts</a></div><div class="desc docblock-short">Forms a raw slice from a pointer and a length.</div></li><li><div class="item-name"><a class="fn" href="fn.slice_from_raw_parts_mut.html" title="fn wasmer_types::lib::std::ptr::slice_from_raw_parts_mut">slice_from_raw_parts_mut</a></div><div class="desc docblock-short">Forms a raw mutable slice from a pointer and a length.</div></li><li><div class="item-name"><a class="fn" href="fn.swap.html" title="fn wasmer_types::lib::std::ptr::swap">swap</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Swaps the values at two mutable locations of the same type, without
deinitializing either.</div></li><li><div class="item-name"><a class="fn" href="fn.swap_nonoverlapping.html" title="fn wasmer_types::lib::std::ptr::swap_nonoverlapping">swap_nonoverlapping</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Swaps <code>count * size_of::&lt;T&gt;()</code> bytes between the two regions of memory
beginning at <code>x</code> and <code>y</code>. The two regions must <em>not</em> overlap.</div></li><li><div class="item-name"><a class="fn" href="fn.write.html" title="fn wasmer_types::lib::std::ptr::write">write</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Overwrites a memory location with the given value without reading or
dropping the old value.</div></li><li><div class="item-name"><a class="fn" href="fn.write_bytes.html" title="fn wasmer_types::lib::std::ptr::write_bytes">write_bytes</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Sets <code>count * size_of::&lt;T&gt;()</code> bytes of memory starting at <code>dst</code> to
<code>val</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.write_unaligned.html" title="fn wasmer_types::lib::std::ptr::write_unaligned">write_unaligned</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Overwrites a memory location with the given value without reading or
dropping the old value.</div></li><li><div class="item-name"><a class="fn" href="fn.write_volatile.html" title="fn wasmer_types::lib::std::ptr::write_volatile">write_volatile</a><sup title="unsafe function">⚠</sup></div><div class="desc docblock-short">Performs a volatile write of a memory location with the given value without
reading or dropping the old value.</div></li><li><div class="item-name"><a class="fn" href="fn.dangling.html" title="fn wasmer_types::lib::std::ptr::dangling">dangling</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Creates a new pointer that is dangling, but well-aligned.</div></li><li><div class="item-name"><a class="fn" href="fn.dangling_mut.html" title="fn wasmer_types::lib::std::ptr::dangling_mut">dangling_mut</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Creates a new pointer that is dangling, but well-aligned.</div></li><li><div class="item-name"><a class="fn" href="fn.from_raw_parts.html" title="fn wasmer_types::lib::std::ptr::from_raw_parts">from_raw_parts</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Forms a (possibly-wide) raw pointer from a data pointer and metadata.</div></li><li><div class="item-name"><a class="fn" href="fn.from_raw_parts_mut.html" title="fn wasmer_types::lib::std::ptr::from_raw_parts_mut">from_raw_parts_mut</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Performs the same functionality as <a href="fn.from_raw_parts.html" title="fn wasmer_types::lib::std::ptr::from_raw_parts"><code>from_raw_parts</code></a>, except that a
raw <code>*mut</code> pointer is returned, as opposed to a raw <code>*const</code> pointer.</div></li><li><div class="item-name"><a class="fn" href="fn.metadata.html" title="fn wasmer_types::lib::std::ptr::metadata">metadata</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Extract the metadata component of a pointer.</div></li><li><div class="item-name"><a class="fn" href="fn.with_exposed_provenance.html" title="fn wasmer_types::lib::std::ptr::with_exposed_provenance">with_exposed_provenance</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Convert an address back to a pointer, picking up a previously ‘exposed’ provenance.</div></li><li><div class="item-name"><a class="fn" href="fn.with_exposed_provenance_mut.html" title="fn wasmer_types::lib::std::ptr::with_exposed_provenance_mut">with_exposed_provenance_mut</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Convert an address back to a mutable pointer, picking up a previously ‘exposed’ provenance.</div></li><li><div class="item-name"><a class="fn" href="fn.without_provenance.html" title="fn wasmer_types::lib::std::ptr::without_provenance">without_provenance</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Creates a pointer with the given address and no provenance.</div></li><li><div class="item-name"><a class="fn" href="fn.without_provenance_mut.html" title="fn wasmer_types::lib::std::ptr::without_provenance_mut">without_provenance_mut</a><span class="stab unstable" title="">Experimental</span></div><div class="desc docblock-short">Creates a pointer with the given address and no provenance.</div></li></ul></section></div></main></body></html>