<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module contains the bulk of the interesting code performing the translation between WebAssembly bytecode and Cranelift IR."><title>wasmer_compiler_cranelift::translator::code_translator - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="wasmer_compiler_cranelift" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.1 (e71f9a9a9 2025-01-27)" data-channel="1.84.1" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../wasmer_compiler_cranelift/index.html">wasmer_<wbr>compiler_<wbr>cranelift</a><span class="version">6.1.0-rc.3</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module code_<wbr>translator</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In wasmer_<wbr>compiler_<wbr>cranelift::<wbr>translator</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">wasmer_compiler_cranelift</a>::<wbr><a href="../index.html">translator</a></span><h1>Module <span>code_translator</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/wasmer_compiler_cranelift/translator/code_translator.rs.html#4-3427">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module contains the bulk of the interesting code performing the translation between
WebAssembly bytecode and Cranelift IR.</p>
<p>The translation is done in one pass, opcode by opcode. Two main data structures are used during
code translations: the value stack and the control stack. The value stack mimics the execution
of the WebAssembly stack machine: each instruction result is pushed onto the stack and
instruction arguments are popped off the stack. Similarly, when encountering a control flow
block, it is pushed onto the control stack and popped off when encountering the corresponding
<code>End</code>.</p>
<p>Another data structure, the translation state, records information concerning unreachable code
status and about if inserting a return at the end of the function is necessary.</p>
<p>Some of the WebAssembly instructions need information about the environment for which they
are being translated:</p>
<ul>
<li>the loads and stores need the memory base address;</li>
<li>the <code>get_global</code> and <code>set_global</code> instructions depend on how the globals are implemented;</li>
<li><code>memory.size</code> and <code>memory.grow</code> are runtime functions;</li>
<li><code>call_indirect</code> has to translate the function index into the address of where this
is;</li>
</ul>
<p>That is why <code>translate_function_body</code> takes an object having the <code>WasmRuntime</code> trait as
argument.</p>
<p>There is extra complexity associated with translation of 128-bit SIMD instructions.
Wasm only considers there to be a single 128-bit vector type.  But CLIF‚Äôs type system
distinguishes different lane configurations, so considers 8X16, 16X8, 32X4 and 64X2 to be
different types.  The result is that, in wasm, it‚Äôs perfectly OK to take the output of (eg)
an <code>add.16x8</code> and use that as an operand of a <code>sub.32x4</code>, without using any cast.  But when
translated into CLIF, that will cause a verifier error due to the apparent type mismatch.</p>
<p>This file works around that problem by liberally inserting <code>bitcast</code> instructions in many
places ‚Äì mostly, before the use of vector values, either as arguments to CLIF instructions
or as block actual parameters.  These are no-op casts which nevertheless have different
input and output types, and are used (mostly) to ‚Äúconvert‚Äù 16X8, 32X4 and 64X2-typed vectors
to the ‚Äúcanonical‚Äù type, 8X16.  Hence the functions <code>optionally_bitcast_vector</code>,
<code>bitcast_arguments</code>, <code>pop*_with_bitcast</code>, <code>canonicalise_then_jump</code>,
<code>canonicalise_then_br{z,nz}</code>, <code>is_non_canonical_v128</code> and <code>canonicalise_v128_values</code>.
Note that the <code>bitcast*</code> functions are occasionally used to convert to some type other than
8X16, but the <code>canonicalise*</code> functions always convert to type 8X16.</p>
<p>Be careful when adding support for new vector instructions.  And when adding new jumps, even
if they are apparently don‚Äôt have any connection to vectors.  Never generate any kind of
(inter-block) jump directly.  Instead use <code>canonicalise_then_jump</code> and
<code>canonicalise_then_br{z,nz}</code>.</p>
<p>The use of bitcasts is ugly and inefficient, but currently unavoidable:</p>
<ul>
<li>
<p>they make the logic in this file fragile: miss out a bitcast for any reason, and there is
the risk of the system failing in the verifier.  At least for debug builds.</p>
</li>
<li>
<p>in the new backends, they potentially interfere with pattern matching on CLIF ‚Äì the
patterns need to take into account the presence of bitcast nodes.</p>
</li>
<li>
<p>in the new backends, they get translated into machine-level vector-register-copy
instructions, none of which are actually necessary.  We then depend on the register
allocator to coalesce them all out.</p>
</li>
<li>
<p>they increase the total number of CLIF nodes that have to be processed, hence slowing down
the compilation pipeline.  Also, the extra coalescing work generates a slowdown.</p>
</li>
</ul>
<p>A better solution which would avoid all four problems would be to remove the 8X16, 16X8,
32X4 and 64X2 types from CLIF and instead have a single V128 type.</p>
<p>For further background see also:
<a href="https://github.com/bytecodealliance/wasmtime/issues/1147">https://github.com/bytecodealliance/wasmtime/issues/1147</a>
(‚ÄúToo many raw_bitcasts in SIMD code‚Äù)
<a href="https://github.com/bytecodealliance/cranelift/pull/1251">https://github.com/bytecodealliance/cranelift/pull/1251</a>
(‚ÄúAdd X128 type to represent WebAssembly‚Äôs V128 type‚Äù)
<a href="https://github.com/bytecodealliance/cranelift/pull/1236">https://github.com/bytecodealliance/cranelift/pull/1236</a>
(‚ÄúRelax verification to allow I8X16 to act as a default vector type‚Äù)</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="bounds_checks/index.html" title="mod wasmer_compiler_cranelift::translator::code_translator::bounds_checks">bounds_<wbr>checks</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Implementation of Wasm to CLIF memory access translation.</div></li></ul><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.unwrap_or_return_unreachable_state.html" title="macro wasmer_compiler_cranelift::translator::code_translator::unwrap_or_return_unreachable_state">unwrap_<wbr>or_<wbr>return_<wbr>unreachable_<wbr>state</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Given a <code>Reachability&lt;T&gt;</code>, unwrap the inner <code>T</code> or, when unreachable, set
<code>state.reachable = false</code> and return.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Reachability.html" title="enum wasmer_compiler_cranelift::translator::code_translator::Reachability">Reachability</a></div><div class="desc docblock-short">Like <code>Option&lt;T&gt;</code> but specifically for passing information about transitions
from reachable to unreachable state and the like from callees to callers.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">¬ß</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.align_atomic_addr.html" title="fn wasmer_compiler_cranelift::translator::code_translator::align_atomic_addr">align_<wbr>atomic_<wbr>addr</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.bitcast_arguments.html" title="fn wasmer_compiler_cranelift::translator::code_translator::bitcast_arguments">bitcast_<wbr>arguments</a></div></li><li><div class="item-name"><a class="fn" href="fn.bitcast_wasm_params.html" title="fn wasmer_compiler_cranelift::translator::code_translator::bitcast_wasm_params">bitcast_<wbr>wasm_<wbr>params</a></div><div class="desc docblock-short">Like <code>bitcast_wasm_returns</code>, but for the parameters being passed to a specified callee.</div></li><li><div class="item-name"><a class="fn" href="fn.bitcast_wasm_returns.html" title="fn wasmer_compiler_cranelift::translator::code_translator::bitcast_wasm_returns">bitcast_<wbr>wasm_<wbr>returns</a></div><div class="desc docblock-short">A helper for bitcasting a sequence of return values for the function currently being built. If
a value is a vector type that does not match its expected type, this will modify the value in
place to point to the result of a <code>bitcast</code>. This conversion is necessary to translate Wasm
code that uses <code>V128</code> as function parameters (or implicitly in block parameters) and still use
specific CLIF types (e.g. <code>I32X4</code>) in the function body.</div></li><li><div class="item-name"><a class="fn" href="fn.canonicalise_brif.html" title="fn wasmer_compiler_cranelift::translator::code_translator::canonicalise_brif">canonicalise_<wbr>brif</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">The same but for a <code>brif</code> instruction.</div></li><li><div class="item-name"><a class="fn" href="fn.canonicalise_then_jump.html" title="fn wasmer_compiler_cranelift::translator::code_translator::canonicalise_then_jump">canonicalise_<wbr>then_<wbr>jump</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Generate a <code>jump</code> instruction, but first cast all 128-bit vector values to I8X16 if they
don‚Äôt have that type.  This is done in somewhat roundabout way so as to ensure that we
almost never have to do any heap allocation.</div></li><li><div class="item-name"><a class="fn" href="fn.canonicalise_v128_values.html" title="fn wasmer_compiler_cranelift::translator::code_translator::canonicalise_v128_values">canonicalise_<wbr>v128_<wbr>values</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Cast to I8X16, any vector values in <code>values</code> that are of ‚Äúnon-canonical‚Äù type (meaning, not
I8X16), and return them in a slice.  A pre-scan is made to determine whether any casts are
actually necessary, and if not, the original slice is returned.  Otherwise the cast values
are returned in a slice that belongs to the caller-supplied <code>SmallVec</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.fold_atomic_mem_addr.html" title="fn wasmer_compiler_cranelift::translator::code_translator::fold_atomic_mem_addr">fold_<wbr>atomic_<wbr>mem_<wbr>addr</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.is_non_canonical_v128.html" title="fn wasmer_compiler_cranelift::translator::code_translator::is_non_canonical_v128">is_<wbr>non_<wbr>canonical_<wbr>v128</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.mem_op_size.html" title="fn wasmer_compiler_cranelift::translator::code_translator::mem_op_size">mem_<wbr>op_<wbr>size</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.optionally_bitcast_vector.html" title="fn wasmer_compiler_cranelift::translator::code_translator::optionally_bitcast_vector">optionally_<wbr>bitcast_<wbr>vector</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Some SIMD operations only operate on I8X16 in CLIF; this will convert them to that type by
adding a raw_bitcast if necessary.</div></li><li><div class="item-name"><a class="fn" href="fn.pop1_with_bitcast.html" title="fn wasmer_compiler_cranelift::translator::code_translator::pop1_with_bitcast">pop1_<wbr>with_<wbr>bitcast</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">A helper for popping and bitcasting a single value; since SIMD values can lose their type by
using v128 (i.e. CLIF‚Äôs I8x16) we must re-type the values using a bitcast to avoid CLIF
typing issues.</div></li><li><div class="item-name"><a class="fn" href="fn.pop2_with_bitcast.html" title="fn wasmer_compiler_cranelift::translator::code_translator::pop2_with_bitcast">pop2_<wbr>with_<wbr>bitcast</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">A helper for popping and bitcasting two values; since SIMD values can lose their type by
using v128 (i.e. CLIF‚Äôs I8x16) we must re-type the values using a bitcast to avoid CLIF
typing issues.</div></li><li><div class="item-name"><a class="fn" href="fn.prepare_addr.html" title="fn wasmer_compiler_cranelift::translator::code_translator::prepare_addr">prepare_<wbr>addr</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">This function is a generalized helper for validating that a wasm-supplied
heap address is in-bounds.</div></li><li><div class="item-name"><a class="fn" href="fn.prepare_atomic_addr.html" title="fn wasmer_compiler_cranelift::translator::code_translator::prepare_atomic_addr">prepare_<wbr>atomic_<wbr>addr</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Like <code>prepare_addr</code> but for atomic accesses.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_cas.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_cas">translate_<wbr>atomic_<wbr>cas</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_load.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_load">translate_<wbr>atomic_<wbr>load</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_rmw.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_rmw">translate_<wbr>atomic_<wbr>rmw</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_atomic_store.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_atomic_store">translate_<wbr>atomic_<wbr>store</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_br_if.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_br_if">translate_<wbr>br_<wbr>if</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_br_if_args.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_br_if_args">translate_<wbr>br_<wbr>if_<wbr>args</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_fcmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_fcmp">translate_<wbr>fcmp</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_icmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_icmp">translate_<wbr>icmp</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_load.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_load">translate_<wbr>load</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Translate a load instruction.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_operator.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_operator">translate_<wbr>operator</a></div><div class="desc docblock-short">Translates wasm operators into Cranelift IR instructions. Returns <code>true</code> if it inserted
a return.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_store.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_store">translate_<wbr>store</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Translate a store instruction.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_unreachable_operator.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_unreachable_operator">translate_<wbr>unreachable_<wbr>operator</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Deals with a Wasm instruction located in an unreachable portion of the code. Most of them
are dropped but special ones like <code>End</code> or <code>Else</code> signal the potential end of the unreachable
portion so the translation state must be updated accordingly.</div></li><li><div class="item-name"><a class="fn" href="fn.translate_vector_fcmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_vector_fcmp">translate_<wbr>vector_<wbr>fcmp</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.translate_vector_icmp.html" title="fn wasmer_compiler_cranelift::translator::code_translator::translate_vector_icmp">translate_<wbr>vector_<wbr>icmp</a><span title="Restricted Visibility">&nbsp;üîí</span> </div></li><li><div class="item-name"><a class="fn" href="fn.type_of.html" title="fn wasmer_compiler_cranelift::translator::code_translator::type_of">type_of</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">Determine the returned value type of a WebAssembly operator</div></li></ul></section></div></main></body></html>