searchState.loadedDescShard("wasmer_compiler_singlepass", 0, "A WebAssembly <code>Compiler</code> implementation using Singlepass.\nA compiler that compiles a WebAssembly module with …\nARM64 structures.\nCompile the module using Singlepass, producing a …\nSupport for compiling with Singlepass.\nTransform it into the compiler\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the middlewares for this compiler\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe middleware chain.\nPushes a middleware onto the back of the middleware chain.\nGets the supported features for this compiler in the given …\nWindows x64 ABI unwind information.\nX64 structures.\nA machine register under the x86-64 architecture.\nAn allocator that allocates registers for function …\nGeneral-purpose registers.\nGeneral-purpose registers.\nNEON registers.\nNEON (floating point/SIMD) registers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a GPR register\nConvert from an SIMD register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>MachineState</code> with default values.\nAllocates a register for argument type <code>ty</code>. Returns <code>None</code> if …\nReturns the index of the register.\nType of a pending canonicalization floating point value. …\nMetadata about a floating-point value.\nThe singlepass per-function code generator.\nAbstraction for a 2-input, 1-output operator. Can be an …\nEmits a Native ABI call sequence, specialized for labels …\nAcquires locations from the machine state.\nCalling convention to use.\nDo we need to canonicalize the value before its bit …\nModuleInfo compilation config.\nA list of frames describing the current control stack.\nCorresponding depth in the main value stack.\nEmits a Native ABI call sequence.\nMetadata about floating point values on the stack.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPrepare data for binary operator with 2 inputs and 1 …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex of a function defined locally inside the WebAssembly …\nTypes of local variables, including arguments.\nMemory locations of local variables.\nLow-level machine state.\nStatic module information.\nEmits a memory operation.\nReleases locations used for stack value.\nReleases locations used for stack value.\nRelocation information.\nSet the source location of the Wasm to the given offset.\nFunction signature.\nA set of special labels for trapping.\nNesting level of unreachable code.\nValue stack.\nOffsets of vmctx fields.\nA constant value.\nCopy Stack BP Relative.\nExplicit Shadow.\nA container for the state of a running wasm instance.\nA kind of machine value.\nPreserve Register.\nThis value is only known at runtime.\nUndefined.\nVmctx.\nWhether a value is determined at compile-time or run-time.\nWasm Local.\nWasm Stack.\nTwo Halves.\nVmctx Deref.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRegister values.\nStack values.\nWasm instruction offset.\nWasm stack.\nA compiler that compiles a WebAssembly module with …\nGets the config for this Compiler\nCreates a new Singlepass compiler\nThe middleware chain.\nCreates a new configuration object with the default …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlways executed\nUnsigned lower (or carry clear)\nUnsigned higher or same (or carry set)\nEqual\nSigned greater than or equal\nSigned greater than\nUnsigned higher\nSigned less than or equal\nUnsigned lower or same\nSigned less than\nNegative. The mnemonic stands for “minus”\nNot equal\nPositive or zero. The mnemonic stands for “plus”\nNo signed overflow. The mnemonic stands for “V clear”\nSigned overflow. The mnemonic stands for “V set”\nForce <code>dynasm!</code> to use the correct arch (aarch64) when …\nmsub : c - a*b -&gt; dst\nHelper function for validating that a given value can be …\nHelper function for validating that a given value can be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce <code>dynasm!</code> to use the correct arch (x64) when …\nA high-level assembler method. Emits an instruction …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMove a single or double precision XMM value to another if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a GPR register\nConvert from an SIMD register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the index of the register.\nGreatest Exact Float (32 bits) less-than i32::MIN when …\nGreatest Exact Float (32 bits) less-than i64::MIN when …\nGreatest Exact Float (32 bits) less-than u32::MIN when …\nGreatest Exact Float (32 bits) less-than u64::MIN when …\nGreatest Exact Float (64 bits) less-than i32::MIN when …\nGreatest Exact Float (64 bits) less-than i64::MIN when …\nGreatest Exact Float (64 bits) less-than u32::MIN when …\nGreatest Exact Float (64 bits) less-than u64::MIN when …\nLeast Exact Float (32 bits) greater-than i32::MAX when …\nLeast Exact Float (32 bits) greater-than i64::MAX when …\nLeast Exact Float (32 bits) greater-than u32::MAX when …\nLeast Exact Float (32 bits) greater-than u64::MAX when …\nLeast Exact Float (64 bits) greater-than i32::MAX when …\nLeast Exact Float (64 bits) greater-than i64::MAX when …\nLeast Exact Float (64 bits) greater-than u32::MAX when …\nLeast Exact Float (64 bits) greater-than u64::MAX when …\nA trap table for a <code>RunnableModuleInfo</code>.\nPicks an unused general pupose register and mark it as used\nAcquires a temporary XMM register.\nAdjust stack for locals Like assembler.emit_sub(Size::S64, …\nAlign for Loop (may do nothing, depending on the arch)\nindirect call with trampoline\nDoes an trampoline is neededfor indirect call\nIs NaN canonicalization supported\nFinalize the assembler\nGet current assembler offset\nCannonicalize a NaN (or panic if not supported)\nGet all current TrapInformation\nConvert a F64 to F32\nConvert a F32 from I32, signed or unsigned\nConvert a F32 from I64, signed or unsigned\nConvert a F32 to F64\nConvert a F64 from I32, signed or unsigned\nConvert a F64 from I64, signed or unsigned\nConvert a F32 to I32, signed or unsigned, without or …\nConvert a F64 to I32, signed or unsigned, without or …\nConvert a F32 to I64, signed or unsigned, without or …\nConvert a F64 to I64, signed or unsigned, without or …\nAdd with location directly from the stack\nAdd with location directly from the stack\nAnd with location directly from the stack\nAnd with location directly from the stack\nMultiply with location directly from the stack\nMultiply with location directly from the stack\nOr with location directly from the stack\nOr with location directly from the stack\nSigned Division with location directly from the stack. …\nSigned Division with location directly from the stack. …\nSigned Reminder (of a Division) with location directly …\nSigned Reminder (of a Division) with location directly …\nSub with location directly from the stack\nSub with location directly from the stack\nUnsigned Division with location directly from the stack. …\nUnsigned Division with location directly from the stack. …\nUnsigned Reminder (of a division) with location directly …\nUnsigned Reminder (of a division) with location directly …\nXor with location directly from the stack\nXor with location directly from the stack\nEmit a call to a label\nemit a call to a location\nEmit a call using the value in register\nemit a move function address to GPR ready for call, using …\nEmit a debug breakpoint\nemit native function epilog (depending on the calling …\nemit native function prolog (depending on the calling …\nHandle copy to SIMD register from ret value (if needed by …\nhandle return value, with optionnal cannonicalization if …\nCopy sign from tmp1 Self::GPR to tmp2 Self::GPR\nCopy sign from tmp1 Self::GPR to tmp2 Self::GPR\nemit an Illegal Opcode, associated with a trapcode\nMultiply location with immediate\njmp using a jump table at lable with cond as the indice\nemit a label\nEmit a memory fence. Can be nothing for x86_64 or a DMB on …\nStack pop of a location\nStack push of a location\nrelaxed cmp: compare from anywhere and anywhere\nrelaxed mov: move from anywhere to anywhere\nrelaxed move with sign extension\nrelaxed move with zero extension\nret (from a Call)\nGet the Absolute Value of an F32\nAdd 2 F32 values\nCeil of an F32\nEqual Compare 2 F32, result in a GPR\nGreater of Equal Compare 2 F32, result in a GPR\nGreater Than Compare 2 F32, result in a GPR\nLess of Equal Compare 2 F32, result in a GPR\nLess Than Compare 2 F32, result in a GPR\nNot Equal Compare 2 F32, result in a GPR\nDivide 2 F32 values\nFloor of an F32\nload an F32\nget Max for 2 F32 values\nget Min for 2 F32 values\nMultiply 2 F32 values\nRound at nearest int of an F32\nNegate an F32\nf32 save\nGet the Square Root of an F32\nSub 2 F32 values\nTrunc of an F32\nGet the Absolute Value of an F64\nAdd 2 F64 values\nCeil of an F64\nEqual Compare 2 F64, result in a GPR\nGreater of Equal Compare 2 F64, result in a GPR\nGreater Than Compare 2 F64, result in a GPR\nLess of Equal Compare 2 F64, result in a GPR\nLess Than Compare 2 F64, result in a GPR\nNot Equal Compare 2 F64, result in a GPR\nDivide 2 F64 values\nFloor of an F64\nload an F64\nget Max for 2 F64 values\nget Min for 2 F64 values\nMultiply 2 F64 values\nRound at nearest int of an F64\nNegate an F64\nf64 save\nGet the Square Root of an F64\nSub 2 F64 values\nTrunc of an F64\nfinalize a function\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ngenerate eh_frame instruction (or None if not possible / …\nSinglepass calls import functions through a trampoline.\nSinglepass calls import functions through a trampoline.\nGenerates dynamic import function call trampoline for a …\nGenerates dynamic import function call trampoline for a …\nStandard entry trampoline generation\nStandard function Trampoline generation\ngenerate Windows unwind instructions (or None if not …\nGet call param location (from a call, using FP for stack …\nget the gpr for the return of generic values\nget the gpr use for call. like RAX on x86_64\ncreate a new label\nDetermine a local’s location.\nget_offset of Assembler\nGet param location (to build a call, using SP for stack …\nget the simd for the return of float/double values\nGet simple param location\nGet all used GPR\nGet all used SIMD regs\nGet the GPR that hold vmctx\ni32 atomic Add with i32\ni32 atomic Add with unsigned 16bits\ni32 atomic Add with unsigned 8bits\ni32 atomic And with i32\ni32 atomic And with unsigned 16bits\ni32 atomic And with unsigned 8bits\ni32 atomic Compare and Exchange with i32\ni32 atomic Compare and Exchange with u16\ni32 atomic Compare and Exchange with u8\ni32 atomic load\ni32 atomic load of an unsigned 16bits\ni32 atomic load of an unsigned 8bits\ni32 atomic Or with i32\ni32 atomic Or with unsigned 16bits\ni32 atomic Or with unsigned 8bits\ni32 atomic save\ni32 atomic save of a the lower 16bits\ni32 atomic save of a the lower 8bits\ni32 atomic Sub with i32\ni32 atomic Sub with unsigned 16bits\ni32 atomic Sub with unsigned 8bits\ni32 atomic Exchange with i32\ni32 atomic Exchange with u16\ni32 atomic Exchange with u8\ni32 atomic Xor with i32\ni32 atomic Xor with unsigned 16bits\ni32 atomic Xor with unsigned 8bits\nCount Leading 0 bit of an i32\nEqual Compare 2 i32, result in a GPR\nSigned Greater of Equal Compare 2 i32, result in a GPR\nUnsigned Greater of Equal Compare 2 i32, result in a GPR\nSigned Greater Than Compare 2 i32, result in a GPR\nUnsigned Greater Than Compare 2 i32, result in a GPR\nSigned Less of Equal Compare 2 i32, result in a GPR\nUnsigned Less of Equal Compare 2 i32, result in a GPR\nSigned Less Than Compare 2 i32, result in a GPR\nUnsigned Less Than Compare 2 i32, result in a GPR\nNot Equal Compare 2 i32, result in a GPR\nCount Trailling 0 bit of an i32\ni32 load\ni32 load of an signed 16bits\ni32 load of an unsigned 16bits\ni32 load of an signed 8bits\ni32 load of an unsigned 8bits\nCount the number of 1 bit of an i32\ni32 Roll Left\ni32 Roll Right\ni32 Arithmetic Shift Right\ni32 save\ni32 save of the lower 16bits\ni32 save of the lower 8bits\ni32 Logical Shift Left\ni32 Logical Shift Right\ni64 atomic Add with i64\ni64 atomic Add with unsigned 16bits\ni64 atomic Add with unsigned 32bits\ni64 atomic Add with unsigned 8bits\ni64 atomic And with i64\ni64 atomic And with unsigned 16bits\ni64 atomic And with unsigned 32bits\ni64 atomic And with unsigned 8bits\ni64 atomic Compare and Exchange with i32\ni64 atomic Compare and Exchange with u16\ni64 atomic Compare and Exchange with u32\ni64 atomic Compare and Exchange with u8\ni64 atomic load\ni64 atomic load from unsigned 16bits\ni64 atomic load from unsigned 32bits\ni64 atomic load from unsigned 8bits\ni64 atomic Or with i64\ni64 atomic Or with unsigned 16bits\ni64 atomic Or with unsigned 32bits\ni64 atomic Or with unsigned 8bits\ni64 atomic save\ni64 atomic save of a the lower 16bits\ni64 atomic save of a the lower 32bits\ni64 atomic save of a the lower 8bits\ni64 atomic Sub with i64\ni64 atomic Sub with unsigned 16bits\ni64 atomic Sub with unsigned 32bits\ni64 atomic Sub with unsigned 8bits\ni64 atomic Exchange with i64\ni64 atomic Exchange with u16\ni64 atomic Exchange with u32\ni64 atomic Exchange with u8\ni64 atomic Xor with i64\ni64 atomic Xor with unsigned 16bits\ni64 atomic Xor with unsigned 32bits\ni64 atomic Xor with unsigned 8bits\nCount Leading 0 bit of an i64\nEqual Compare 2 i64, result in a GPR\nSigned Greater of Equal Compare 2 i64, result in a GPR\nUnsigned Greater of Equal Compare 2 i64, result in a GPR\nSigned Greater Than Compare 2 i64, result in a GPR\nUnsigned Greater Than Compare 2 i64, result in a GPR\nSigned Less of Equal Compare 2 i64, result in a GPR\nUnsigned Less of Equal Compare 2 i64, result in a GPR\nSigned Less Than Compare 2 i64, result in a GPR\nUnsigned Less Than Compare 2 i64, result in a GPR\nNot Equal Compare 2 i64, result in a GPR\nCount Trailling 0 bit of an i64\ni64 load\ni64 load of an signed 16bits\ni64 load of an signed 16bits\ni64 load of an signed 32bits\ni64 load of an unsigned 32bits\ni64 load of an signed 8bits\ni64 load of an unsigned 8bits\nCount the number of 1 bit of an i64\ni64 Roll Left\ni64 Roll Right\ni64 Arithmetic Shift Right\ni64 save\ni64 save of the lower 16bits\ni64 save of the lower 32bits\ni64 save of the lower 8bits\ni64 Logical Shift Left\ni64 Logical Shift Right\nConvert from a GPR register to index register\nConvert from an SIMD register\nInit the stack loc counter\nInsert a StackOverflow (at offset 0)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermine whether a local should be allocated on the stack.\njmp to label if the provided condition is true (when …\njmp without condidtion\nList of register to save, depending on the …\nLoad a memory value to a register, zero extending to …\nMemory location for a local on the stack Like …\nGPR Reg used for local pointer on the stack\nAdd src+dst -&gt; dst (with or without flags)\nload the address of a memory location (will panic if src …\nAnd src &amp; dst -&gt; dst (with or without flags)\nCmp src - dst and set flags\n-src -&gt; dst\nOr src &amp; dst -&gt; dst (with or without flags)\nSub dst-src -&gt; dst (with or without flags)\nTest src &amp; dst and set flags\nXor src &amp; dst -&gt; dst (with or without flags)\nMarks each address in the code range emitted by <code>f</code> with the …\nMarks one address as trappable with trap code <code>code</code>.\nPushes the instruction to the address map, calculating the …\nMarks the instruction as trappable with trap code <code>code</code>. …\nMove a local to the stack Like emit_mov(Size::S64, …\nmove a location to another\nmove a location to another, with zero or sign extension\npush a value on the stack for a native call\nCreate a new <code>MachineState</code> with default values.\nMappings from offsets in generated machine code to the …\nPicks an unused general purpose register for …\nPicks an unused SIMD register.\nPicks an unused general purpose register for internal …\nPicks an unused SIMD register for internal temporary use.\nPop a location\nPop stack of locals Like assembler.emit_add(Size::S64, …\nPop used gpr to the stack\nPop used simd regs to the stack\nPush used gpr to the stack. Return the bytes taken on the …\nPush used simd regs to the stack. Return bytes taken on …\nReleases a temporary GPR.\nReleases a temporary XMM register.\nreserve a GPR\nreserve a SIMD register\nSpecify that a given register is in use.\nRestore save_area\nrestore stack Like assembler.emit_add(Size::S64, …\nReturn a rounded stack adjustement value (must be multiple …\nSet the source location of the Wasm to the given offset.\nZero a location taht is 32bits\nGet all current TrapInformation\nI32 comparison with.\nI64 comparison with.\nReturns the argument unchanged.\nReturns the argument unchanged.\nA boolean flag signaling if this machine supports NEON.\nInsert a StackOverflow (at offset 0)\nMap from byte offset into wasm function to range of native …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks each address in the code range emitted by <code>f</code> with the …\nMarks one address as trappable with trap code <code>code</code>.\nPushes the instruction to the address map, calculating the …\nMarks the instruction as trappable with trap code <code>code</code>. …\nis last push on a 8byte multiple or 16bytes?\nSet the source location of the Wasm to the given offset.\nThe source location for the current operator.\nVector of unwind operations with offset\nGet all current TrapInformation\nI32 binary operation with both operands popped from the …\nI64 binary operation with both operands popped from the …\nEmit a CMP instruction that compares <code>left</code> against <code>right</code>.\nI32 comparison with.\nI64 comparison with.\nMoves <code>src1</code> and <code>src2</code> to valid locations and possibly adds a …\nMoves <code>src1</code> and <code>src2</code> to valid locations and possibly adds a …\nMoves <code>loc</code> to a valid location for <code>div</code>/<code>idiv</code>.\nI32 shift with both operands popped from the virtual stack.\nI64 shift with both operands popped from the virtual stack.\nReturns the argument unchanged.\nReturns the argument unchanged.\nthe actual inner\nInsert a StackOverflow (at offset 0)\nMap from byte offset into wasm function to range of native …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks each address in the code range emitted by <code>f</code> with the …\nMarks one address as trappable with trap code <code>code</code>.\nPushes the instruction to the address map, calculating the …\nMarks the instruction as trappable with trap code <code>code</code>. …\nSet the source location of the Wasm to the given offset.\nthe simd instructions set on the target. Currently only …\nThe source location for the current operator.\nFull Target cpu\nVector of unwind operations with offset\ngenerate a default systemv  cie\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nMaximum (inclusive) size of a “large” stack allocation …\nMaximum (inclusive) size of a “small” stack allocation\nThe supported unwind codes for the x64 Windows ABI.\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn allocator that allocates registers for function …\nGeneral-purpose registers.\nGeneral-purpose registers.\nA machine register under the x86-64 architecture.\nXMM registers.\nXMM (floating point/SIMD) registers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a GPR register\nConvert from an SIMD register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>MachineState</code> with default values.\nAllocates a register for argument type <code>ty</code>. Returns <code>None</code> if …\nReturns the index of the register.")