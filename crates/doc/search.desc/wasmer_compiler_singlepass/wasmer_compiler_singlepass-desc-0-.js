searchState.loadedDescShard("wasmer_compiler_singlepass", 0, "A WebAssembly <code>Compiler</code> implementation using Singlepass.\nCallbacks to the different Cranelift compilation phases.\nA compiler that compiles a WebAssembly module with …\nARM64 structures.\nCompile the module using Singlepass, producing a …\nSupport for compiling with Singlepass.\nTransform it into the compiler\nRISC-V emitter scaffolding.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the middlewares for this compiler\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRISC-V machine scaffolding.\nThe middleware chain.\nThe number of threads to use for compilation.\nPushes a middleware onto the back of the middleware chain.\nRISC-V structures.\nGets the supported features for this compiler in the given …\nWindows x64 ABI unwind information.\nX64 structures.\nA machine register under the x86-64 architecture.\nAn allocator that allocates registers for function …\nGeneral-purpose registers.\nGeneral-purpose registers.\nNEON registers.\nNEON (floating point/SIMD) registers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a GPR register\nConvert from an SIMD register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllocates a register for argument type <code>ty</code>. Returns <code>None</code> if …\nType of a pending canonicalization floating point value. …\nThe singlepass per-function code generator.\nAbstraction for a 2-input, 1-output operator. Can be an …\nType of native call we emit.\nAcquires location from the machine state.\nAcquire location that will live on the stack.\nAllocate return slots for block operands (Block, If, Loop) …\nAssembly comments.\nCalling convention to use.\nModuleInfo compilation config.\nA list of frames describing the current control stack.\nEmits a Native ABI call sequence.\nSimilar to <code>emit_return_values</code>, except it stores the …\nMoves the top <code>return_values</code> items from the value stack …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nName of the function.\nPrepare data for binary operator with 2 inputs and 1 …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex of a function defined locally inside the WebAssembly …\nTypes of local variables, including arguments.\nMemory locations of local variables.\nLow-level machine state.\nStatic module information.\nEmits a memory operation.\nReleases locations used for stack value.\nRelocation information.\nSet the source location of the Wasm to the given offset.\nFunction signature.\nA set of special labels for trapping.\nStack offset tracking in bytes.\nNesting level of unreachable code.\nValue stack.\nValue stack depth at the beginning of the frame (including …\nReturns the value stack depth at which resources should be …\nOffsets of vmctx fields.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA compiler that compiles a WebAssembly module with …\nGets the config for this Compiler\nCreates a new Singlepass compiler\nCallbacks to the different Cranelift compilation phases.\nWrites the assembly memory buffer to a debug file.\nCallbacks that will triggered in the different compilation …\nThe middleware chain.\nCreates a new instance of <code>SinglepassCallbacks</code> with the …\nCreates a new configuration object with the default …\nSet the number of threads to use for compilation.\nThe number of threads to use for compilation.\nWrites the object file memory buffer to a debug file.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAlways executed\nUnsigned lower (or carry clear)\nUnsigned higher or same (or carry set)\nEqual\nSigned greater than or equal\nSigned greater than\nUnsigned higher\nSigned less than or equal\nUnsigned lower or same\nSigned less than\nNegative. The mnemonic stands for “minus”\nNot equal\nPositive or zero. The mnemonic stands for “plus”\nNo signed overflow. The mnemonic stands for “V clear”\nSigned overflow. The mnemonic stands for “V set”\nForce <code>dynasm!</code> to use the correct arch (aarch64) when …\nmsub : c - a*b -&gt; dst\nHelper function for validating that a given value can be …\nHelper function for validating that a given value can be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAtomic binary operation type\nBranch conditions for RISC-V.\nEmitter trait for RISC-V.\nSigned equal\nSigned greater than or equal\nUnsigned greater than or equal\nSigned greater than\nUnsigned greater than\nSigned less than or equal\nUnsigned less than or equal\nLocation abstraction specialized to RISC-V.\nSigned less than\nUnsigned less than\nSigned not equal\nRound Down (towards -∞)\nRound to Nearest, ties to Even (default)\nFloating-point number rounding mode\nRound towards Zero\nRound Up (towards +∞)\nScratch register used in function call trampolines.\nForce <code>dynasm!</code> to use the correct arch (riscv64) when …\nFinalize the function, e.g., resolve labels.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates dynamic import function call trampoline for a …\nReturns the size of a jump instruction in bytes.\nGenerates a new internal label.\nGets the current code offset.\nReturns the SIMD (FPU) feature if available.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nForce <code>dynasm!</code> to use the correct arch (x64) when …\nA high-level assembler method. Emits an instruction …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMove a single or double precision XMM value to another if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a GPR register\nConvert from an SIMD register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGreatest Exact Float (32 bits) less-than i32::MIN when …\nGreatest Exact Float (32 bits) less-than i64::MIN when …\nGreatest Exact Float (32 bits) less-than u32::MIN when …\nGreatest Exact Float (32 bits) less-than u64::MIN when …\nGreatest Exact Float (64 bits) less-than i32::MIN when …\nGreatest Exact Float (64 bits) less-than i64::MIN when …\nGreatest Exact Float (64 bits) less-than u32::MIN when …\nGreatest Exact Float (64 bits) less-than u64::MIN when …\nLeast Exact Float (32 bits) greater-than i32::MAX when …\nLeast Exact Float (32 bits) greater-than i64::MAX when …\nLeast Exact Float (32 bits) greater-than u32::MAX when …\nLeast Exact Float (32 bits) greater-than u64::MAX when …\nLeast Exact Float (64 bits) greater-than i32::MAX when …\nLeast Exact Float (64 bits) greater-than i64::MAX when …\nLeast Exact Float (64 bits) greater-than u32::MAX when …\nLeast Exact Float (64 bits) greater-than u64::MAX when …\nA trap table for a <code>RunnableModuleInfo</code>.\nPicks an unused general pupose register and mark it as used\nAcquires a temporary XMM register.\nAlign for Loop (may do nothing, depending on the arch)\nindirect call with trampoline\nFinalize the assembler\nGet current assembler offset\nCannonicalize a NaN (or panic if not supported)\nGet all current TrapInformation\nConvert a F64 to F32\nConvert a F32 from I32, signed or unsigned\nConvert a F32 from I64, signed or unsigned\nConvert a F32 to F64\nConvert a F64 from I32, signed or unsigned\nConvert a F64 from I64, signed or unsigned\nConvert a F32 to I32, signed or unsigned, without or …\nConvert a F64 to I32, signed or unsigned, without or …\nConvert a F32 to I64, signed or unsigned, without or …\nConvert a F64 to I64, signed or unsigned, without or …\nAdd with location directly from the stack\nAdd with location directly from the stack\nAnd with location directly from the stack\nAnd with location directly from the stack\nMultiply with location directly from the stack\nMultiply with location directly from the stack\nOr with location directly from the stack\nOr with location directly from the stack\nSigned Division with location directly from the stack. …\nSigned Division with location directly from the stack. …\nSigned Reminder (of a Division) with location directly …\nSigned Reminder (of a Division) with location directly …\nSub with location directly from the stack\nSub with location directly from the stack\nUnsigned Division with location directly from the stack. …\nUnsigned Division with location directly from the stack. …\nUnsigned Reminder (of a division) with location directly …\nUnsigned Reminder (of a division) with location directly …\nXor with location directly from the stack\nXor with location directly from the stack\nEmit a call to a label\nemit a call to a location\nEmit a call using the value in register\nemit a move function address to GPR ready for call, using …\nEmit a debug breakpoint\nemit native function epilog (depending on the calling …\nemit native function prolog (depending on the calling …\nHandle copy to SIMD register from ret value (if needed by …\nCopy sign from tmp1 Self::GPR to tmp2 Self::GPR\nCopy sign from tmp1 Self::GPR to tmp2 Self::GPR\nemit an Illegal Opcode, associated with a trapcode\nMultiply location with immediate\njmp using a jump table at lable with cond as the indice\nemit a label\nEmit a memory fence. Can be nothing for x86_64 or a DMB on …\nStack pop of a location\nStack push of a location\nrelaxed cmp: compare from anywhere and anywhere\nrelaxed mov: move from anywhere to anywhere\nrelaxed move with sign extension\nret (from a Call)\nAllocate an extra space on the stack.\nGet the Absolute Value of an F32\nAdd 2 F32 values\nCeil of an F32\nEqual Compare 2 F32, result in a GPR\nGreater of Equal Compare 2 F32, result in a GPR\nGreater Than Compare 2 F32, result in a GPR\nLess of Equal Compare 2 F32, result in a GPR\nLess Than Compare 2 F32, result in a GPR\nNot Equal Compare 2 F32, result in a GPR\nDivide 2 F32 values\nFloor of an F32\nload an F32\nget Max for 2 F32 values\nget Min for 2 F32 values\nMultiply 2 F32 values\nRound at nearest int of an F32\nNegate an F32\nf32 save\nGet the Square Root of an F32\nSub 2 F32 values\nTrunc of an F32\nGet the Absolute Value of an F64\nAdd 2 F64 values\nCeil of an F64\nEqual Compare 2 F64, result in a GPR\nGreater of Equal Compare 2 F64, result in a GPR\nGreater Than Compare 2 F64, result in a GPR\nLess of Equal Compare 2 F64, result in a GPR\nLess Than Compare 2 F64, result in a GPR\nNot Equal Compare 2 F64, result in a GPR\nDivide 2 F64 values\nFloor of an F64\nload an F64\nget Max for 2 F64 values\nget Min for 2 F64 values\nMultiply 2 F64 values\nRound at nearest int of an F64\nNegate an F64\nf64 save\nGet the Square Root of an F64\nSub 2 F64 values\nTrunc of an F64\nfinalize a function\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ngenerate eh_frame instruction (or None if not possible / …\nSinglepass calls import functions through a trampoline.\nSinglepass calls import functions through a trampoline.\nGenerates dynamic import function call trampoline for a …\nGenerates dynamic import function call trampoline for a …\nStandard entry trampoline generation\nStandard function Trampoline generation\ngenerate Windows unwind instructions (or None if not …\nGet call param location (from a call, using FP for stack …\nGet return value location (from a call, using FP for stack …\nget the gpr used for call. like RAX on x86_64\ncreate a new label\nDetermine a local’s location.\nget_offset of Assembler\nGet param location (to build a call, using SP for stack …\nGet registers for first N function call parameters.\nGet return value location (to build a call, using SP for …\nGet param location (idx must point to an argument that is …\nGet all used GPR\nGet all used SIMD regs\nGet the GPR that hold vmctx\ni32 atomic Add with i32\ni32 atomic Add with unsigned 16bits\ni32 atomic Add with unsigned 8bits\ni32 atomic And with i32\ni32 atomic And with unsigned 16bits\ni32 atomic And with unsigned 8bits\ni32 atomic Compare and Exchange with i32\ni32 atomic Compare and Exchange with u16\ni32 atomic Compare and Exchange with u8\ni32 atomic load\ni32 atomic load of an unsigned 16bits\ni32 atomic load of an unsigned 8bits\ni32 atomic Or with i32\ni32 atomic Or with unsigned 16bits\ni32 atomic Or with unsigned 8bits\ni32 atomic save\ni32 atomic save of a the lower 16bits\ni32 atomic save of a the lower 8bits\ni32 atomic Sub with i32\ni32 atomic Sub with unsigned 16bits\ni32 atomic Sub with unsigned 8bits\ni32 atomic Exchange with i32\ni32 atomic Exchange with u16\ni32 atomic Exchange with u8\ni32 atomic Xor with i32\ni32 atomic Xor with unsigned 16bits\ni32 atomic Xor with unsigned 8bits\nCount Leading 0 bit of an i32\nEqual Compare 2 i32, result in a GPR\nSigned Greater of Equal Compare 2 i32, result in a GPR\nUnsigned Greater of Equal Compare 2 i32, result in a GPR\nSigned Greater Than Compare 2 i32, result in a GPR\nUnsigned Greater Than Compare 2 i32, result in a GPR\nSigned Less of Equal Compare 2 i32, result in a GPR\nUnsigned Less of Equal Compare 2 i32, result in a GPR\nSigned Less Than Compare 2 i32, result in a GPR\nUnsigned Less Than Compare 2 i32, result in a GPR\nNot Equal Compare 2 i32, result in a GPR\nCount Trailling 0 bit of an i32\ni32 load\ni32 load of an signed 16bits\ni32 load of an unsigned 16bits\ni32 load of an signed 8bits\ni32 load of an unsigned 8bits\nCount the number of 1 bit of an i32\ni32 Roll Left\ni32 Roll Right\ni32 Arithmetic Shift Right\ni32 save\ni32 save of the lower 16bits\ni32 save of the lower 8bits\ni32 Logical Shift Left\ni32 Logical Shift Right\ni64 atomic Add with i64\ni64 atomic Add with unsigned 16bits\ni64 atomic Add with unsigned 32bits\ni64 atomic Add with unsigned 8bits\ni64 atomic And with i64\ni64 atomic And with unsigned 16bits\ni64 atomic And with unsigned 32bits\ni64 atomic And with unsigned 8bits\ni64 atomic Compare and Exchange with i32\ni64 atomic Compare and Exchange with u16\ni64 atomic Compare and Exchange with u32\ni64 atomic Compare and Exchange with u8\ni64 atomic load\ni64 atomic load from unsigned 16bits\ni64 atomic load from unsigned 32bits\ni64 atomic load from unsigned 8bits\ni64 atomic Or with i64\ni64 atomic Or with unsigned 16bits\ni64 atomic Or with unsigned 32bits\ni64 atomic Or with unsigned 8bits\ni64 atomic save\ni64 atomic save of a the lower 16bits\ni64 atomic save of a the lower 32bits\ni64 atomic save of a the lower 8bits\ni64 atomic Sub with i64\ni64 atomic Sub with unsigned 16bits\ni64 atomic Sub with unsigned 32bits\ni64 atomic Sub with unsigned 8bits\ni64 atomic Exchange with i64\ni64 atomic Exchange with u16\ni64 atomic Exchange with u32\ni64 atomic Exchange with u8\ni64 atomic Xor with i64\ni64 atomic Xor with unsigned 16bits\ni64 atomic Xor with unsigned 32bits\ni64 atomic Xor with unsigned 8bits\nCount Leading 0 bit of an i64\nEqual Compare 2 i64, result in a GPR\nSigned Greater of Equal Compare 2 i64, result in a GPR\nUnsigned Greater of Equal Compare 2 i64, result in a GPR\nSigned Greater Than Compare 2 i64, result in a GPR\nUnsigned Greater Than Compare 2 i64, result in a GPR\nSigned Less of Equal Compare 2 i64, result in a GPR\nUnsigned Less of Equal Compare 2 i64, result in a GPR\nSigned Less Than Compare 2 i64, result in a GPR\nUnsigned Less Than Compare 2 i64, result in a GPR\nNot Equal Compare 2 i64, result in a GPR\nCount Trailling 0 bit of an i64\ni64 load\ni64 load of an signed 16bits\ni64 load of an signed 16bits\ni64 load of an signed 32bits\ni64 load of an unsigned 32bits\ni64 load of an signed 8bits\ni64 load of an unsigned 8bits\nCount the number of 1 bit of an i64\ni64 Roll Left\ni64 Roll Right\ni64 Arithmetic Shift Right\ni64 save\ni64 save of the lower 16bits\ni64 save of the lower 32bits\ni64 save of the lower 8bits\ni64 Logical Shift Left\ni64 Logical Shift Right\nInit the stack loc counter\nInsert a StackOverflow (at offset 0)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDetermine whether a local should be allocated on the stack.\njmp to label if the provided condition is true (when …\njmp without condidtion\nList of register to save, depending on the …\nMemory location for a local on the stack Like …\nGPR Reg used for local pointer on the stack\nAdd src+dst -&gt; dst (with or without flags)\nCmp src - dst and set flags\nMarks each address in the code range emitted by <code>f</code> with the …\nMarks one address as trappable with trap code <code>code</code>.\nPushes the instruction to the address map, calculating the …\nMarks the instruction as trappable with trap code <code>code</code>. …\nMove a local to the stack Like emit_mov(Size::S64, …\nmove a location to another\nmove a location to another, with zero or sign extension\npush a value on the stack for a native call\nMappings from offsets in generated machine code to the …\nPicks an unused general purpose register for …\nPicks an unused SIMD register.\nPicks an unused general purpose register for internal …\nPicks an unused SIMD register for internal temporary use.\nPop a location\nPop used gpr from the stack.\nPop used simd regs to the stack\nPush used gpr to the stack. Return the bytes taken on the …\nPush used simd regs to the stack. Return bytes taken on …\nReleases a temporary GPR.\nReleases a temporary XMM register.\nreserve a GPR\nreserve a SIMD register\nSpecify that a given register is in use.\nRestore save_area\nReturn a rounded stack adjustement value (must be multiple …\nSet the source location of the Wasm to the given offset.\nTruncate stack space by the <code>delta_stack_offset</code>.\nZero a location taht is 32bits\nGet registers for first N function return values. NOTE: …\nGet all current TrapInformation\nI32 comparison with.\nI64 comparison with.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet registers for first N function call parameters.\nA boolean flag signaling if this machine supports NEON.\nInsert a StackOverflow (at offset 0)\nMap from byte offset into wasm function to range of native …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks each address in the code range emitted by <code>f</code> with the …\nMarks one address as trappable with trap code <code>code</code>.\nPushes the instruction to the address map, calculating the …\nMarks the instruction as trappable with trap code <code>code</code>. …\nis last push on a 8byte multiple or 16bytes?\nSet the source location of the Wasm to the given offset.\nThe source location for the current operator.\nVector of unwind operations with offset\nThe RISC-V assembler wrapper, providing FPU feature …\nThe RISC-V machine state and code emitter.\nGet registers for first N function return values. NOTE: …\nGet all current TrapInformation\nI32 comparison with.\nI64 comparison with.\nFinalize to machine code bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet registers for first N function call parameters.\nInner dynasm assembler.\nInsert a StackOverflow (at offset 0)\nMap from byte offset into wasm function to range of native …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks the instruction as trappable with trap code <code>code</code>. …\nNOTE: As observed on the VisionFive 2 board, when an …\nCreate a new RISC-V assembler.\nCreates a new RISC-V machine for code generation.\nSet the source location of the Wasm to the given offset.\nThe source location for the current operator.\nVector of unwind operations with offset.\nGet registers for first N function return values. NOTE: …\nGet all current TrapInformation\nI32 binary operation with both operands popped from the …\nI64 binary operation with both operands popped from the …\nEmit a CMP instruction that compares <code>left</code> against <code>right</code>.\nI32 comparison with.\nI64 comparison with.\nMoves <code>src1</code> and <code>src2</code> to valid locations and possibly adds a …\nMoves <code>src1</code> and <code>src2</code> to valid locations and possibly adds a …\nMoves <code>loc</code> to a valid location for <code>div</code>/<code>idiv</code>.\nI32 shift with both operands popped from the virtual stack.\nI64 shift with both operands popped from the virtual stack.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet return value location (from a call, using FP for stack …\nGet registers for first N function call parameters.\nGet return value location (to build a call, using SP for …\nthe actual inner\nInsert a StackOverflow (at offset 0)\nMap from byte offset into wasm function to range of native …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarks each address in the code range emitted by <code>f</code> with the …\nMarks one address as trappable with trap code <code>code</code>.\nPushes the instruction to the address map, calculating the …\nMarks the instruction as trappable with trap code <code>code</code>. …\nSet the source location of the Wasm to the given offset.\nthe simd instructions set on the target. Currently only …\nThe source location for the current operator.\nFull Target cpu\nVector of unwind operations with offset\nAllocator for function argument registers according to the …\nFloating-point registers.\nFloating-point register.\nGeneral-purpose registers.\nGeneral-purpose register.\nA combined RISC-V register.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllocates a register for argument type <code>ty</code>. Returns <code>None</code> if …\ngenerate a default systemv  cie\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nMaximum (inclusive) size of a “large” stack allocation …\nMaximum (inclusive) size of a “small” stack allocation\nThe supported unwind codes for the x64 Windows ABI.\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn allocator that allocates registers for function …\nGeneral-purpose registers.\nGeneral-purpose registers.\nA machine register under the x86-64 architecture.\nXMM registers.\nXMM (floating point/SIMD) registers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a GPR register\nConvert from an SIMD register\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllocates a register for argument type <code>ty</code>. Returns <code>None</code> if …")