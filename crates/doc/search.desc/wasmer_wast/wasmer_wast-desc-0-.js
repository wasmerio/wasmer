searchState.loadedDescShard("wasmer_wast", 0, "Implementation of the WAST text format for wasmer.\nA Directive Error\nA structure holding the list of all executed directives\nInstruct the test runner to use <code>virtual_fs::host_fs</code>.\nInstruct the test runner to use <code>virtual_fs::mem_fs</code>.\nInstruct the test runner to use <code>virtual_fs::passtru_fs</code>\nInstruct the test runner to use the TempFs returned by …\nInstruct the test runner to use <code>virtual_fs::tmp_fs</code>\nInstruct the test runner to use …\nVersion number of this crate.\nThe kind of filesystem <code>WasiTest</code> is going to use.\nCrate holding metadata parsed from the WASI WAST about the …\nThe wast test script language allows modules to be defined …\nAllowed failures (ideally this should be empty)\nThe column where the directive is defined\nWast files have a concept of a “current” module, which …\nIf the current module was an allowed failure, we allow …\nA flag indicating that assert_exception should be skipped.\nA flag indicating that assert_trap and assert_exhaustion …\nThe list of errors\nA flag indicating if Wast tests should stop as soon as one …\nThe filename where the error occured\nThe Import Object that all wast tests will have\nThe instances in the test\nThe line where the directive is defined\nIf the (expected from .wast, actual) message pair is in …\nThe failing message received when running the directive\nReturn an instance implementing the “spectest” …\nThe store in which the tests are executing.\nA Directive Error\nA structure holding the list of all executed directives\nThe column where the directive is defined\nThe list of errors\nThe filename where the error occured\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe line where the directive is defined\nThe failing message received when running the directive\n<code>ToString::to_string</code>, but without panic on OOM.\nReturn an instance implementing the “spectest” …\nInstruct the test runner to use <code>virtual_fs::host_fs</code>.\nInstruct the test runner to use <code>virtual_fs::mem_fs</code>.\nInstruct the test runner to use <code>virtual_fs::passtru_fs</code>\nInstruct the test runner to use the TempFs returned by …\nInstruct the test runner to use <code>virtual_fs::tmp_fs</code>\nInstruct the test runner to use …\nThe kind of filesystem <code>WasiTest</code> is going to use.\nCrate holding metadata parsed from the WASI WAST about the …\nCreate the wasi env with the given metadata.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the correct WASI import object for the given module …\nGet the correct <code>WasiVersion</code> from the Wasm <code>Module</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurn a WASI WAST string into a list of tokens.\nWhen using <code>virtual_fs::mem_fs</code>, we cannot rely on …\nTurn a WASI WAST list of tokens into a <code>WasiTest</code> struct.\nExecute the WASI test and assert.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe wast test script language allows modules to be defined …\nA list of instantiation failures to allow.\nA list of alternative messages to permit for a trap …\nAllowed failures (ideally this should be empty)\nWast files have a concept of a “current” module, which …\nIf the current module was an allowed failure, we allow …\nDo not run any code in assert_trap or assert_exhaustion.\nDo not run any code in assert_exception.\nA flag indicating that assert_exception should be skipped.\nA flag indicating that assert_trap and assert_exhaustion …\nA flag indicating if Wast tests should stop as soon as one …\nReturns the argument unchanged.\nGet the value of an exported global from an instance.\nThe Import Object that all wast tests will have\nThe instances in the test\nCalls <code>U::from(self)</code>.\nInvoke an exported function from an instance.\nIf the (expected from .wast, actual) message pair is in …\nDefine a module and register it.\nConstruct a new instance of <code>Wast</code> with a given imports.\nConstruct a new instance of <code>Wast</code> with the spectests …\nPerform the action portion of a command.\nRegister an instance to make it available for performing …\nRun a wast script from a byte buffer.\nRun a wast script from a file.\nTranslate from a <code>script::Value</code> to a <code>Value</code>.\nThe store in which the tests are executing.\nDefine a module and register it.")