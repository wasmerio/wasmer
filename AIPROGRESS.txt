Analysis Summary:
- `lib/api` assumes at least one backend feature is enabled; `compile_error!` and feature-gated enums/patterns panic otherwise.
- Without a backend the generated enums become uninhabited, macros expand to empty matches, and backend-specific modules are missing, leading to numerous compile errors.
- Need a stub backend that provides no runtime functionality but satisfies the type-level contracts so crates depending on `wasmer` can compile with `--no-default-features`.
- The stub must auto-activate only when all other backend features are disabled and must integrate with macros, backend enums, and default selection logic.

Implementation Plan:
[x] 1. Add conditional configuration for the stub backend in `Cargo.toml` and centralize a `cfg` predicate representing “no real backend enabled”.
[ ] 2. Introduce a `backend::stub` module tree with minimal placeholder types/functions matching required interfaces (engine, store, module, memory, etc.), returning clear `unimplemented`/error fallbacks.
[ ] 3. Extend backend-related macros (`gen_rt_ty!`, `match_rt!`, VM helpers) and enums (`BackendKind`, `BackendEngine`, etc.) to include the stub variant guarded by the no-backend predicate.
[ ] 4. Replace the existing `compile_error!` guard with stub activation, ensure default backend selection uses stub when appropriate, and make API surface gracefully error when stub code paths execute.
[ ] 5. Run `cargo check --no-default-features` inside `lib/api`, fix residual compile issues, and update the progress file as steps complete.

Current Progress Notes:
- Added a `stub` feature flag and build script to emit `cfg(stub_backend)` when no real backend is enabled, wiring conditional compilation throughout macros/enums.
- Created `backend/stub` module tree (engine, module, store, memory, table, etc.) with placeholder structs; most functions currently panic or return errors.
- Updated backend macros (`gen_rt_ty!`, `match_rt!`), enums (`BackendKind`, `BackendEngine`, `StoreObjects`, etc.), and helpers (`utils/native/convert.rs`, `trap.rs`, memory infrastructure) to include stub branches.
- Replaced hardcoded compile errors with stub activation; `cargo check --no-default-features` now progresses deeper but still fails due to missing stub implementations generated by macros.

Remaining Tasks:
- For every backend entity generated by `gen_rt_ty!` (memory, table, global, instance, extern, exception, function env, etc.), supply a corresponding stub module with the methods the macros expect, even if they `panic!`.
- Ensure `BackendStore`, `BackendMemory`, `BackendTable`, and related enums handle the stub variant in all `match` statements (including `try_clone`, `copy`, `share`, etc.).
- Extend stub VM layer (`backend/stub/vm`) with types for all VM enums (externs, tables, globals, traps, callbacks) to satisfy macro-expanded code paths.
- Add stub trait implementations (e.g. function envs, memory buffers/views) so every `match_rt!` and macro-generated method compiles without unhandled variants.
- Rerun `cargo check --no-default-features`; iterate until the stub backend builds cleanly, then proceed to integrate higher-level API flows if needed.

Progress Snapshot (current state):
- Build script now emits `cfg(stub_backend)` and warns are suppressed; macros/enums use that cfg instead of ad-hoc `any(...)` checks.
- Stub modules exist for store, memory, table, global, tag, instance, extern refs, exception refs, function envs, etc., returning panics or simple errors.
- Most core enums (BackendKind/StoreObjects/BackendStore/BackendMemory/BackendTable/etc.) include stub variants and panic on use.
- `cargo check --no-default-features` still fails because macro-generated code calls into missing stub arms (e.g. memory/view/table copy, function env clones, host-function match arms) and some stub types need basic methods (e.g. `Clone` impls, placeholder `VM` conversions).

Immediate TODOs:
- Implement stub branches for every `match store.inner.store` / `match_rt!` expansion across entities (functions, globals, tables, tags, memories, extern refs, exceptions), making them panic.
- Ensure stub versions of macro-generated enums expose required helper methods (e.g. `VM` conversions, `is_from_store`, `len`, `ty`, etc.)—even if each method just `panic!`.
- Cover stub cases in host-function dispatch (`entities/function/host/imp.rs`) to avoid non-exhaustive `BackendKind` matches.
- Add missing stub helper types in `backend/stub/vm` (VMExtern classes, trap, env wrappers) so `match_rt!` arms compile.
- Re-run `cargo check --no-default-features`, iterate to resolve remaining compile errors and warnings (e.g. remove `Default`/`Eq` derives that require real data, adjust lifetimes where macros expect specific signatures).

Comprehensive Status Summary (current task paused):

Goal: allow `lib/api` crate to build with no real backends by compiling a stub backend that activates automatically when all other backends are disabled (`cargo check --no-default-features`).

Work Completed:
- Added `stub` feature and `build.rs` that emits `cfg(stub_backend)` whenever the stub feature is chosen or no real backend features are enabled.
- Updated `Cargo.toml` to run the build script; macros (`gen_rt_ty!`, `match_rt!`) and enums (`BackendKind`, `BackendEngine`, `BackendStore`, `StoreObjects`, etc.) now include a stub branch under `#[cfg(stub_backend)]`.
- Created initial `backend/stub` module tree with placeholder engine, module, store, memory, table, global, tag, instance, extern/exception refs, function envs, VM helpers, and error/trap definitions. Most methods currently `panic!` or return an error so the API type signatures exist.
- Added stub arms to many `match` statements (module/memory/table/global/tag/external/exception creation, copy, etc.) and to native conversion helpers so code compiles far enough to surface remaining gaps.

Current Build State:
- `cargo check --no-default-features` still fails. Main blockers:
  * Numerous macro-generated match arms still see the stub variant as “live” and need explicit `panic!` arms (e.g. host function dispatch (`entities/function/host/imp.rs`), `match_rt!` expansions for tables/globals/memory). Some matches currently return `()`, causing iterator type inference errors (e.g. `Module::custom_sections`).
  * Stub modules need minimal method implementations matching the real API signatures. Several currently return wrong types, derive unsupported traits (`Default`, `Eq`) on types storing non-Default/Non-Eq fields, or lack required methods (`vm_functions`, `is_from_store`, etc.).
  * Stub VM helpers must expose all constructors the macros expect (`VMFunctionEnvironment::contents`, `VMExceptionRef::into_raw`, `VMExtern::to_extern`, etc.) even if they panic.
  * Host-function macro `impl_host_function!` lacks a `BackendKind::Stub` arm, leading to non-exhaustive pattern errors.
  * Function environment stubs aren’t `Clone` in the correct shape expected by `BackendFunctionEnv` (the enum clones the concrete backend value).

Suggested Next Steps for the Next Agent:
1. Systematically locate every `match` generated by `match_rt!` or `match store.inner.store` and add a `#[cfg(stub_backend)]` arm that `panic!`s (or returns an immediate error) for the stub variant. Focus on entities in `lib/api/src/entities/**/inner.rs` (module/global/table/tag/memory/exception/function) and any other macros (`impl_host_function!`).
2. Flesh out the stub entity modules so they compile with those matches:
   - Remove derives that require real data (`Default`, `Eq`) unless the stub struct holds no non-defaultable fields.
   - Implement required methods with `panic!` or simple `Err`. Ensure return types match (e.g., `to_vm_extern` must return `VMExtern`, not `VMExternGlobal`).
   - Provide placeholder methods for stub VM types (`VMFunctionEnvironment::contents`, `VMExceptionRef::into_raw`, etc.).
3. Update host-function dispatch (`entities/function/host/imp.rs`) to include `BackendKind::Stub => panic!(...)` to make pattern exhaustive.
4. After all stub branches and methods compile, rerun `cargo check --no-default-features`, iterate on remaining compile errors/warnings (e.g., rename `wasm_trap_t`, adjust lifetime signatures in memory buffer stub) until the build succeeds.

This should set up the next agent to continue wiring the stub backend through the macro-heavy API surface and reach a clean build.
